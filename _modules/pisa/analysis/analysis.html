<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pisa.analysis.analysis &mdash; PISA 4.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=9f5556dd"></script>
        <script src="../../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            PISA
          </a>
              <div class="version">
                4.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">API reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">PISA</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">pisa.analysis.analysis</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pisa.analysis.analysis</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Common tools for performing an analysis collected into a single class</span>
<span class="sd">`Analysis` that can be subclassed by specific analyses.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Mapping</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">setitem</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.optimize</span> <span class="k">as</span> <span class="nn">optimize</span>
<span class="c1"># this is needed for the take_step option in basinhopping</span>
<span class="kn">from</span> <span class="nn">scipy._lib._util</span> <span class="kn">import</span> <span class="n">check_random_state</span>
<span class="kn">from</span> <span class="nn">iminuit</span> <span class="kn">import</span> <span class="n">Minuit</span>
<span class="kn">import</span> <span class="nn">nlopt</span>

<span class="kn">import</span> <span class="nn">pisa</span>
<span class="kn">from</span> <span class="nn">pisa</span> <span class="kn">import</span> <span class="n">EPSILON</span><span class="p">,</span> <span class="n">FTYPE</span><span class="p">,</span> <span class="n">ureg</span>
<span class="kn">from</span> <span class="nn">pisa.core.map</span> <span class="kn">import</span> <span class="n">Map</span><span class="p">,</span> <span class="n">MapSet</span>
<span class="kn">from</span> <span class="nn">pisa.core.param</span> <span class="kn">import</span> <span class="n">ParamSet</span><span class="p">,</span> <span class="n">Param</span>
<span class="kn">from</span> <span class="nn">pisa.core.pipeline</span> <span class="kn">import</span> <span class="n">Pipeline</span>
<span class="kn">from</span> <span class="nn">pisa.utils.comparisons</span> <span class="kn">import</span> <span class="n">recursiveEquality</span><span class="p">,</span> <span class="n">FTYPE_PREC</span><span class="p">,</span> <span class="n">ALLCLOSE_KW</span>
<span class="kn">from</span> <span class="nn">pisa.utils.log</span> <span class="kn">import</span> <span class="n">logging</span><span class="p">,</span> <span class="n">set_verbosity</span>
<span class="kn">from</span> <span class="nn">pisa.utils.fileio</span> <span class="kn">import</span> <span class="n">to_file</span>
<span class="kn">from</span> <span class="nn">pisa.utils.stats</span> <span class="kn">import</span> <span class="p">(</span><span class="n">METRICS_TO_MAXIMIZE</span><span class="p">,</span> <span class="n">METRICS_TO_MINIMIZE</span><span class="p">,</span>
                              <span class="n">LLH_METRICS</span><span class="p">,</span> <span class="n">CHI2_METRICS</span><span class="p">,</span> <span class="n">weighted_chi2</span><span class="p">,</span>
                              <span class="n">it_got_better</span><span class="p">,</span> <span class="n">is_metric_to_maximize</span><span class="p">)</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;MINIMIZERS_USING_SYMM_GRAD&#39;</span><span class="p">,</span> <span class="s1">&#39;MINIMIZERS_USING_CONSTRAINTS&#39;</span><span class="p">,</span>
           <span class="s1">&#39;set_minimizer_defaults&#39;</span><span class="p">,</span> <span class="s1">&#39;validate_minimizer_settings&#39;</span><span class="p">,</span>
           <span class="s1">&#39;Counter&#39;</span><span class="p">,</span> <span class="s1">&#39;Analysis&#39;</span><span class="p">,</span> <span class="s1">&#39;BasicAnalysis&#39;</span><span class="p">]</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s1">&#39;J.L. Lanfranchi, P. Eller, S. Wren, E. Bourbeau, A. Trettin&#39;</span>

<span class="n">__license__</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;Copyright (c) 2014-2020, The IceCube Collaboration</span>

<span class="s1"> Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s1"> you may not use this file except in compliance with the License.</span>
<span class="s1"> You may obtain a copy of the License at</span>

<span class="s1">   http://www.apache.org/licenses/LICENSE-2.0</span>

<span class="s1"> Unless required by applicable law or agreed to in writing, software</span>
<span class="s1"> distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s1"> WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s1"> See the License for the specific language governing permissions and</span>
<span class="s1"> limitations under the License.&#39;&#39;&#39;</span>


<span class="n">MINIMIZERS_USING_SYMM_GRAD</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;l-bfgs-b&#39;</span><span class="p">,</span> <span class="s1">&#39;slsqp&#39;</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;Minimizers that use symmetrical steps on either side of a point to compute</span>
<span class="sd">gradients. See https://github.com/scipy/scipy/issues/4916&quot;&quot;&quot;</span>

<span class="n">MINIMIZERS_USING_CONSTRAINTS</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;cobyla&#39;</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;Minimizers that cannot use the &#39;bounds&#39; argument and instead need bounds to</span>
<span class="sd">be formulated in terms of constraints.&quot;&quot;&quot;</span>

<span class="k">def</span> <span class="nf">merge_mapsets_together</span><span class="p">(</span><span class="n">mapset_list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Handle merging of multiple MapSets, when they come in</span>
<span class="sd">    the shape of a dict</span>

<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mapset_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Mapping</span><span class="p">):</span>
        <span class="n">new_dict</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">S</span> <span class="ow">in</span> <span class="n">mapset_list</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">S</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

                <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">new_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">maps</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">maps</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">new_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">new_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">MapSet</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;This function only works when mapsets are provided as dicts&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">new_dict</span>


<span class="c1"># TODO: add Nelder-Mead, as it was used previously...</span>
<div class="viewcode-block" id="set_minimizer_defaults">
<a class="viewcode-back" href="../../../pisa.analysis.html#pisa.analysis.analysis.set_minimizer_defaults">[docs]</a>
<span class="k">def</span> <span class="nf">set_minimizer_defaults</span><span class="p">(</span><span class="n">minimizer_settings</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Fill in default values for minimizer settings.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    minimizer_settings : dict</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    new_minimizer_settings : dict</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_minimizer_settings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">method</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">),</span>
        <span class="n">options</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="nb">dict</span><span class="p">(),</span> <span class="n">desc</span><span class="o">=</span><span class="nb">dict</span><span class="p">())</span>
    <span class="p">)</span>
    <span class="n">new_minimizer_settings</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">minimizer_settings</span><span class="p">)</span>

    <span class="n">sqrt_ftype_eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">FTYPE</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>
    <span class="n">opt_defaults</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">minimizer_settings</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;l-bfgs-b&#39;</span> <span class="ow">and</span> <span class="n">FTYPE</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span>
        <span class="c1"># From `scipy.optimize.lbfgsb._minimize_lbfgsb`</span>
        <span class="n">opt_defaults</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span>
            <span class="n">maxcor</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">ftol</span><span class="o">=</span><span class="mf">2.2204460492503131e-09</span><span class="p">,</span> <span class="n">gtol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span>
            <span class="n">maxfun</span><span class="o">=</span><span class="mi">15000</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">15000</span><span class="p">,</span> <span class="n">iprint</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">maxls</span><span class="o">=</span><span class="mi">20</span>
        <span class="p">))</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;l-bfgs-b&#39;</span> <span class="ow">and</span> <span class="n">FTYPE</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">:</span>
        <span class="c1"># Adapted to lower precision</span>
        <span class="n">opt_defaults</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span>
            <span class="n">maxcor</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">ftol</span><span class="o">=</span><span class="n">sqrt_ftype_eps</span><span class="p">,</span> <span class="n">gtol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span>
            <span class="n">maxfun</span><span class="o">=</span><span class="mi">15000</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">15000</span><span class="p">,</span> <span class="n">iprint</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">maxls</span><span class="o">=</span><span class="mi">20</span>
        <span class="p">))</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;slsqp&#39;</span> <span class="ow">and</span> <span class="n">FTYPE</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span>
        <span class="n">opt_defaults</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span>
            <span class="n">maxiter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">ftol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">,</span> <span class="n">iprint</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">sqrt_ftype_eps</span><span class="p">,</span>
        <span class="p">))</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;slsqp&#39;</span> <span class="ow">and</span> <span class="n">FTYPE</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">:</span>
        <span class="n">opt_defaults</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span>
            <span class="n">maxiter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">ftol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">iprint</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">sqrt_ftype_eps</span>
        <span class="p">))</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;cobyla&#39;</span><span class="p">:</span>
        <span class="n">opt_defaults</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span>
            <span class="n">rhobeg</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
        <span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unhandled minimizer &quot;</span><span class="si">%s</span><span class="s1">&quot; / FTYPE=</span><span class="si">%s</span><span class="s1">&#39;</span>
                         <span class="o">%</span> <span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">FTYPE</span><span class="p">))</span>

    <span class="n">opt_defaults</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_minimizer_settings</span><span class="p">[</span><span class="s1">&#39;options&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">])</span>

    <span class="n">new_minimizer_settings</span><span class="p">[</span><span class="s1">&#39;options&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">opt_defaults</span>

    <span class="c1"># Populate the descriptions with something</span>
    <span class="k">for</span> <span class="n">opt_name</span> <span class="ow">in</span> <span class="n">new_minimizer_settings</span><span class="p">[</span><span class="s1">&#39;options&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">opt_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">new_minimizer_settings</span><span class="p">[</span><span class="s1">&#39;options&#39;</span><span class="p">][</span><span class="s1">&#39;desc&#39;</span><span class="p">]:</span>
            <span class="n">new_minimizer_settings</span><span class="p">[</span><span class="s1">&#39;options&#39;</span><span class="p">][</span><span class="s1">&#39;desc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;no desc&#39;</span>

    <span class="k">return</span> <span class="n">new_minimizer_settings</span></div>



<span class="c1"># TODO: add Nelder-Mead, as it was used previously...</span>
<div class="viewcode-block" id="validate_minimizer_settings">
<a class="viewcode-back" href="../../../pisa.analysis.html#pisa.analysis.analysis.validate_minimizer_settings">[docs]</a>
<span class="k">def</span> <span class="nf">validate_minimizer_settings</span><span class="p">(</span><span class="n">minimizer_settings</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Validate minimizer settings.</span>

<span class="sd">    See source for specific thresholds set.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    minimizer_settings : dict</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If any minimizer settings are deemed to be invalid.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ftype_eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">FTYPE</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">minimizer_settings</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="n">options</span> <span class="o">=</span> <span class="n">minimizer_settings</span><span class="p">[</span><span class="s1">&#39;options&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;l-bfgs-b&#39;</span><span class="p">:</span>
        <span class="n">must_have</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;maxcor&#39;</span><span class="p">,</span> <span class="s1">&#39;ftol&#39;</span><span class="p">,</span> <span class="s1">&#39;gtol&#39;</span><span class="p">,</span> <span class="s1">&#39;eps&#39;</span><span class="p">,</span> <span class="s1">&#39;maxfun&#39;</span><span class="p">,</span> <span class="s1">&#39;maxiter&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;maxls&#39;</span><span class="p">)</span>
        <span class="n">may_have</span> <span class="o">=</span> <span class="n">must_have</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;args&#39;</span><span class="p">,</span> <span class="s1">&#39;jac&#39;</span><span class="p">,</span> <span class="s1">&#39;bounds&#39;</span><span class="p">,</span> <span class="s1">&#39;disp&#39;</span><span class="p">,</span> <span class="s1">&#39;iprint&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;callback&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;slsqp&#39;</span><span class="p">:</span>
        <span class="n">must_have</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;maxiter&#39;</span><span class="p">,</span> <span class="s1">&#39;ftol&#39;</span><span class="p">,</span> <span class="s1">&#39;eps&#39;</span><span class="p">)</span>
        <span class="n">may_have</span> <span class="o">=</span> <span class="n">must_have</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;args&#39;</span><span class="p">,</span> <span class="s1">&#39;jac&#39;</span><span class="p">,</span> <span class="s1">&#39;bounds&#39;</span><span class="p">,</span> <span class="s1">&#39;constraints&#39;</span><span class="p">,</span>
                                <span class="s1">&#39;iprint&#39;</span><span class="p">,</span> <span class="s1">&#39;disp&#39;</span><span class="p">,</span> <span class="s1">&#39;callback&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;cobyla&#39;</span><span class="p">:</span>
        <span class="n">must_have</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;maxiter&#39;</span><span class="p">,</span> <span class="s1">&#39;rhobeg&#39;</span><span class="p">,</span> <span class="s1">&#39;tol&#39;</span><span class="p">)</span>
        <span class="n">may_have</span> <span class="o">=</span> <span class="n">must_have</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;disp&#39;</span><span class="p">,</span> <span class="s1">&#39;catol&#39;</span><span class="p">)</span>

    <span class="n">missing</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">must_have</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">options</span><span class="p">))</span>
    <span class="n">excess</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">options</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">may_have</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">missing</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Missing the following options for </span><span class="si">%s</span><span class="s1"> minimizer: </span><span class="si">%s</span><span class="s1">&#39;</span>
                         <span class="o">%</span> <span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">missing</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">excess</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Excess options for </span><span class="si">%s</span><span class="s1"> minimizer: </span><span class="si">%s</span><span class="s1">&#39;</span>
                         <span class="o">%</span> <span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">excess</span><span class="p">))</span>

    <span class="n">eps_msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> minimizer option </span><span class="si">%s</span><span class="s1">(=</span><span class="si">%e</span><span class="s1">) is &lt; </span><span class="si">%d</span><span class="s1"> * </span><span class="si">%s</span><span class="s1">_EPS(=</span><span class="si">%e</span><span class="s1">)&#39;</span>
    <span class="n">eps_gt_msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> minimizer option </span><span class="si">%s</span><span class="s1">(=</span><span class="si">%e</span><span class="s1">) is &gt; </span><span class="si">%e</span><span class="s1">&#39;</span>
    <span class="n">fp64_eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;l-bfgs-b&#39;</span><span class="p">:</span>
        <span class="n">err_lim</span><span class="p">,</span> <span class="n">warn_lim</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ftol&#39;</span><span class="p">,</span> <span class="s1">&#39;gtol&#39;</span><span class="p">]:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">err_lim</span> <span class="o">*</span> <span class="n">ftype_eps</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">eps_msg</span> <span class="o">%</span> <span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">err_lim</span><span class="p">,</span> <span class="s1">&#39;FTYPE&#39;</span><span class="p">,</span>
                                            <span class="n">ftype_eps</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">warn_lim</span> <span class="o">*</span> <span class="n">ftype_eps</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">eps_msg</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">warn_lim</span><span class="p">,</span> <span class="s1">&#39;FTYPE&#39;</span><span class="p">,</span> <span class="n">ftype_eps</span><span class="p">)</span>

        <span class="n">val</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;eps&#39;</span><span class="p">]</span>
        <span class="n">err_lim</span><span class="p">,</span> <span class="n">warn_lim</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">err_lim</span> <span class="o">*</span> <span class="n">fp64_eps</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">eps_msg</span> <span class="o">%</span> <span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="s1">&#39;eps&#39;</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">err_lim</span><span class="p">,</span> <span class="s1">&#39;FP64&#39;</span><span class="p">,</span>
                                        <span class="n">fp64_eps</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">warn_lim</span> <span class="o">*</span> <span class="n">ftype_eps</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">eps_msg</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="s1">&#39;eps&#39;</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">warn_lim</span><span class="p">,</span> <span class="s1">&#39;FTYPE&#39;</span><span class="p">,</span> <span class="n">ftype_eps</span><span class="p">)</span>

        <span class="n">err_lim</span><span class="p">,</span> <span class="n">warn_lim</span> <span class="o">=</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.1</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">err_lim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">eps_gt_msg</span> <span class="o">%</span> <span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="s1">&#39;eps&#39;</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">err_lim</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">warn_lim</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">eps_gt_msg</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="s1">&#39;eps&#39;</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">warn_lim</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;slsqp&#39;</span><span class="p">:</span>
        <span class="n">err_lim</span><span class="p">,</span> <span class="n">warn_lim</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;ftol&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">err_lim</span> <span class="o">*</span> <span class="n">ftype_eps</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">eps_msg</span> <span class="o">%</span> <span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="s1">&#39;ftol&#39;</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">err_lim</span><span class="p">,</span> <span class="s1">&#39;FTYPE&#39;</span><span class="p">,</span>
                                        <span class="n">ftype_eps</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">warn_lim</span> <span class="o">*</span> <span class="n">ftype_eps</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">eps_msg</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="s1">&#39;ftol&#39;</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">warn_lim</span><span class="p">,</span> <span class="s1">&#39;FTYPE&#39;</span><span class="p">,</span> <span class="n">ftype_eps</span><span class="p">)</span>

        <span class="n">val</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;eps&#39;</span><span class="p">]</span>
        <span class="n">err_lim</span><span class="p">,</span> <span class="n">warn_lim</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">err_lim</span> <span class="o">*</span> <span class="n">fp64_eps</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">eps_msg</span> <span class="o">%</span> <span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="s1">&#39;eps&#39;</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;FP64&#39;</span><span class="p">,</span>
                                        <span class="n">fp64_eps</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">warn_lim</span> <span class="o">*</span> <span class="n">ftype_eps</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">eps_msg</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="s1">&#39;eps&#39;</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">warn_lim</span><span class="p">,</span> <span class="s1">&#39;FP64&#39;</span><span class="p">,</span> <span class="n">fp64_eps</span><span class="p">)</span>

        <span class="n">err_lim</span><span class="p">,</span> <span class="n">warn_lim</span> <span class="o">=</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.1</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">err_lim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">eps_gt_msg</span> <span class="o">%</span> <span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="s1">&#39;eps&#39;</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">err_lim</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">warn_lim</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">eps_gt_msg</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="s1">&#39;eps&#39;</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">warn_lim</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;cobyla&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;rhobeg&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;starting step-size &gt; 0.5 will overstep boundary&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="s1">&#39;rhobeg&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">1e-2</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;starting step-size is very low, convergence will be slow&#39;</span><span class="p">)</span></div>




<span class="k">def</span> <span class="nf">get_separate_octant_params</span><span class="p">(</span>
    <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">angle_name</span><span class="p">,</span> <span class="n">inflection_point</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This function creates versions of the angle param that are confined to</span>
<span class="sd">    a single octant. It does this for both octant cases. This is used to allow</span>
<span class="sd">    fits to be done where only one of the octants is allowed. The fit can then</span>
<span class="sd">    be done for the two octant cases and compared to find the best fit.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    hypo_maker : DistributionMaker or Detector</span>
<span class="sd">        The hypothesis maker being used by the fitter</span>
<span class="sd">    angle_name : string</span>
<span class="sd">        Name of the angle for which to create separate octant params.</span>
<span class="sd">    inflection_point : quantity</span>
<span class="sd">        Point distinguishing between the two octants, e.g. 45 degrees</span>
<span class="sd">    tolerance : quantity</span>
<span class="sd">        If the starting value is closer to the inflection point than the value of the</span>
<span class="sd">        tolerance, it is offset away from the inflection point by this amount.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    angle_orig : Param</span>
<span class="sd">        angle param as it was before applying the octant separation</span>
<span class="sd">    angle_case1 : Param</span>
<span class="sd">        angle param confined to first octant</span>
<span class="sd">    angle_case2 : Param</span>
<span class="sd">        angle param confined to second octant</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># Reset angle before starting</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">angle_name</span><span class="p">]</span>
    <span class="n">angle</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

    <span class="c1"># Store the original theta23 param before we mess with it</span>
    <span class="c1"># WARNING: Do not copy here, you want the original object (since this relates to the underlying</span>
    <span class="c1"># ParamSelector from which theta23 is extracted). Otherwise end up with an incosistent state</span>
    <span class="c1"># later (e.g. after a new call to ParamSelector.select_params, this copied, and potentially</span>
    <span class="c1"># modified param will be overwtiten by the original).</span>
    <span class="n">angle_orig</span> <span class="o">=</span> <span class="n">angle</span>

    <span class="c1"># Get the octant definition</span>
    <span class="n">octants</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">angle</span><span class="o">.</span><span class="n">range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">inflection_point</span><span class="p">)</span> <span class="p">,</span>
        <span class="p">(</span><span class="n">inflection_point</span><span class="p">,</span> <span class="n">angle</span><span class="o">.</span><span class="n">range</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="p">)</span>

    <span class="c1"># If angle is maximal (e.g. the transition between octants) or very close</span>
    <span class="c1"># to it, offset it slightly to be clearly in one octant (note that fit can</span>
    <span class="c1"># still move the value back to maximal). The reason for this is that</span>
    <span class="c1"># otherwise checks on the parameter bounds (which include a margin for</span>
    <span class="c1"># minimizer tolerance) can an throw exception.</span>
    <span class="k">if</span> <span class="n">tolerance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tolerance</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">ureg</span><span class="o">.</span><span class="n">degree</span>
    <span class="n">dist_from_inflection</span> <span class="o">=</span> <span class="n">angle</span><span class="o">.</span><span class="n">value</span> <span class="o">-</span> <span class="n">inflection_point</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dist_from_inflection</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tolerance</span> <span class="p">:</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.</span> <span class="k">if</span> <span class="n">dist_from_inflection</span> <span class="o">&lt;</span> <span class="mf">0.</span> <span class="k">else</span> <span class="o">+</span><span class="mf">1.</span> <span class="c1"># Note this creates +ve shift also for theta == 45 (arbitary)</span>
        <span class="n">angle</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">inflection_point</span> <span class="o">+</span> <span class="p">(</span><span class="n">sign</span> <span class="o">*</span> <span class="n">tolerance</span><span class="p">)</span>

    <span class="c1"># Store the cases</span>
    <span class="n">angle_case1</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
    <span class="n">angle_case2</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>

    <span class="c1"># Get case 1, e.g. the current octant</span>
    <span class="n">case1_octant_index</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">angle_case1</span><span class="o">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">inflection_point</span> <span class="k">else</span> <span class="mi">1</span>
    <span class="n">angle_case1</span><span class="o">.</span><span class="n">range</span> <span class="o">=</span> <span class="n">octants</span><span class="p">[</span><span class="n">case1_octant_index</span><span class="p">]</span>
    <span class="n">angle_case1</span><span class="o">.</span><span class="n">nominal_value</span> <span class="o">=</span> <span class="n">angle_case1</span><span class="o">.</span><span class="n">value</span>

    <span class="c1"># Also get case 2, e.g. the other octant</span>
    <span class="n">case2_octant_index</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">case1_octant_index</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">1</span>
    <span class="n">angle_case2</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">inflection_point</span> <span class="o">-</span> <span class="n">angle_case2</span><span class="o">.</span><span class="n">value</span>
    <span class="c1"># Also setting nominal value so that `reset_free` won&#39;t try to set it out of bounds</span>
    <span class="n">angle_case2</span><span class="o">.</span><span class="n">nominal_value</span> <span class="o">=</span> <span class="n">angle_case2</span><span class="o">.</span><span class="n">value</span>
    <span class="n">angle_case2</span><span class="o">.</span><span class="n">range</span> <span class="o">=</span> <span class="n">octants</span><span class="p">[</span><span class="n">case2_octant_index</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">angle_orig</span><span class="p">,</span> <span class="n">angle_case1</span><span class="p">,</span> <span class="n">angle_case2</span>

<span class="k">def</span> <span class="nf">update_param_values</span><span class="p">(</span>
    <span class="n">hypo_maker</span><span class="p">,</span>
    <span class="n">params</span><span class="p">,</span>
    <span class="n">update_nominal_values</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">update_range</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">update_is_fixed</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Update just the values of parameters of a DistributionMaker *without* replacing</span>
<span class="sd">    the memory references inside.</span>

<span class="sd">    This should be used in place of `hypo_maker.update_params(params)` unless one</span>
<span class="sd">    explicitly wants to replace the memory references to which the parameters in</span>
<span class="sd">    the DistributionMaker are pointing.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># it is possible that only a single param is given</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">Param</span><span class="p">):</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">params</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hypo_maker</span><span class="p">,</span> <span class="n">Pipeline</span><span class="p">):</span>
        <span class="n">hypo_maker</span> <span class="o">=</span> <span class="p">[</span><span class="n">hypo_maker</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">pipeline</span> <span class="ow">in</span> <span class="n">hypo_maker</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">names</span><span class="p">:</span> <span class="k">continue</span>
            <span class="c1"># it is crucial that we update the range first because the value</span>
            <span class="c1"># of the parameter in params might lie outside the range of those in</span>
            <span class="c1"># hypo_maker.</span>
            <span class="k">if</span> <span class="n">update_range</span><span class="p">:</span>
                <span class="n">pipeline</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">range</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">range</span>
            <span class="n">pipeline</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">value</span>
            <span class="k">if</span> <span class="n">update_nominal_values</span><span class="p">:</span>
                <span class="n">pipeline</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">nominal_value</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">nominal_value</span>
            <span class="k">if</span> <span class="n">update_is_fixed</span><span class="p">:</span>
                <span class="n">pipeline</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">is_fixed</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">is_fixed</span>

<span class="k">def</span> <span class="nf">update_param_values_detector</span><span class="p">(</span>
    <span class="n">hypo_maker</span><span class="p">,</span>
    <span class="n">params</span><span class="p">,</span>
    <span class="n">update_nominal_values</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">update_range</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">update_is_fixed</span><span class="o">=</span><span class="kc">False</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Modification of the update_param_values function to use with the Detectors class.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;Detectors&quot;</span><span class="p">,</span> <span class="s2">&quot;hypo_maker is not Detectors class&quot;</span>   
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">Param</span><span class="p">):</span> <span class="n">params</span> <span class="o">=</span> <span class="n">ParamSet</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        
    <span class="k">for</span> <span class="n">distribution_maker</span> <span class="ow">in</span> <span class="n">hypo_maker</span><span class="p">:</span>
        <span class="n">ps</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">ps</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">distribution_maker</span><span class="o">.</span><span class="n">detector_name</span> <span class="ow">in</span> <span class="n">p</span><span class="p">:</span>
                <span class="n">p_name</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">distribution_maker</span><span class="o">.</span><span class="n">detector_name</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">p_name</span> <span class="ow">in</span> <span class="n">ps</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                    <span class="n">ps</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">p_name</span><span class="p">)</span>
                <span class="n">ps</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">p_name</span>
        <span class="n">update_param_values</span><span class="p">(</span><span class="n">distribution_maker</span><span class="p">,</span> <span class="n">ps</span><span class="p">,</span> 
                            <span class="n">update_nominal_values</span><span class="p">,</span> <span class="n">update_range</span><span class="p">,</span> <span class="n">update_is_fixed</span><span class="p">)</span>
    <span class="n">hypo_maker</span><span class="o">.</span><span class="n">init_params</span><span class="p">()</span>

<span class="c1"># TODO: move this to a central location prob. in utils</span>
<div class="viewcode-block" id="Counter">
<a class="viewcode-back" href="../../../pisa.analysis.html#pisa.analysis.analysis.Counter">[docs]</a>
<span class="k">class</span> <span class="nc">Counter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Simple counter object for use as a minimizer callback.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_count</span> <span class="o">=</span> <span class="n">i</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_count</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inc</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_count</span> <span class="o">+=</span> <span class="n">inc</span>

<div class="viewcode-block" id="Counter.reset">
<a class="viewcode-back" href="../../../pisa.analysis.html#pisa.analysis.analysis.Counter.reset">[docs]</a>
    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reset counter&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_count</span> <span class="o">=</span> <span class="mi">0</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;int : Current count&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_count</span></div>


<span class="k">class</span> <span class="nc">BoundedRandomDisplacement</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add a bounded random displacement of maximum size `stepsize` to each coordinate</span>
<span class="sd">    Calling this updates `x` in-place.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    stepsize : float, optional</span>
<span class="sd">        Maximum stepsize in any dimension</span>
<span class="sd">    bounds : pair of float or sequence of pairs of float</span>
<span class="sd">        Bounds on x</span>
<span class="sd">    random_gen : {None, `np.random.RandomState`, `np.random.Generator`}</span>
<span class="sd">        The random number generator that generates the displacements</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stepsize</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">random_gen</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stepsize</span> <span class="o">=</span> <span class="n">stepsize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_gen</span> <span class="o">=</span> <span class="n">check_random_state</span><span class="p">(</span><span class="n">random_gen</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_gen</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">stepsize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stepsize</span><span class="p">,</span>
                                     <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>  <span class="c1"># bounds are automatically broadcast</span>
        <span class="k">return</span> <span class="n">x</span>

<span class="k">class</span> <span class="nc">HypoFitResult</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Holds all relevant information about a fit result.&quot;&quot;&quot;</span>

    
    <span class="n">_state_attrs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;metric&quot;</span><span class="p">,</span> <span class="s2">&quot;metric_val&quot;</span><span class="p">,</span> <span class="s2">&quot;params&quot;</span><span class="p">,</span> <span class="s2">&quot;param_selections&quot;</span><span class="p">,</span> 
                    <span class="s2">&quot;hypo_asimov_dist&quot;</span><span class="p">,</span> <span class="s2">&quot;detailed_metric_info&quot;</span><span class="p">,</span> <span class="s2">&quot;minimizer_time&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;num_distributions_generated&quot;</span><span class="p">,</span> <span class="s2">&quot;minimizer_metadata&quot;</span><span class="p">,</span> <span class="s2">&quot;fit_history&quot;</span><span class="p">]</span>

    <span class="c1"># TODO: initialize from serialized state</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">metric</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">metric_val</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">data_dist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">hypo_maker</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">minimizer_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">num_distributions_generated</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">minimizer_metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">fit_history</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">other_metrics</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">counter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">include_detailed_metric_info</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metric</span> <span class="o">=</span> <span class="n">metric</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metric_val</span> <span class="o">=</span> <span class="n">metric_val</span>
        <span class="c1"># deepcopy done in setter function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hypo_asimov_dist</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">hypo_maker</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">param_selections</span> <span class="o">=</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">param_selections</span>
            <span class="c1"># Record the distribution with the optimal param values</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hypo_asimov_dist</span> <span class="o">=</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">get_outputs</span><span class="p">(</span><span class="n">return_sum</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">detailed_metric_info</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">minimizer_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">minimizer_time</span> <span class="o">=</span> <span class="n">minimizer_time</span> <span class="o">*</span> <span class="n">ureg</span><span class="o">.</span><span class="n">sec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_distributions_generated</span> <span class="o">=</span> <span class="n">num_distributions_generated</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minimizer_metadata</span> <span class="o">=</span> <span class="n">minimizer_metadata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_history</span> <span class="o">=</span> <span class="n">fit_history</span>

        <span class="k">if</span> <span class="n">include_detailed_metric_info</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;missing input to calculate detailed metric info&quot;</span>
            <span class="k">assert</span> <span class="n">hypo_maker</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="n">msg</span>
            <span class="k">assert</span> <span class="n">data_dist</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="n">msg</span>
            <span class="k">assert</span> <span class="n">metric</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="n">msg</span>
            <span class="k">if</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;Detectors&quot;</span><span class="p">:</span>
                <span class="c1"># this passes through the setter method, but it should just pass through</span>
                <span class="c1"># without actually doing anything</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">detailed_metric_info</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_detailed_metric_info</span><span class="p">(</span>
                    <span class="n">data_dist</span><span class="o">=</span><span class="n">data_dist</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">hypo_asimov_dist</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hypo_asimov_dist</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="n">params</span><span class="o">=</span><span class="n">hypo_maker</span><span class="o">.</span><span class="n">distribution_makers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                    <span class="n">other_metrics</span><span class="o">=</span><span class="n">other_metrics</span><span class="p">,</span> <span class="n">detector_name</span><span class="o">=</span><span class="n">hypo_maker</span><span class="o">.</span><span class="n">det_names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">hypo_maker</span><span class="o">=</span><span class="n">hypo_maker</span>
                <span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_dist</span><span class="p">))]</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># DistributionMaker object</span>
                <span class="k">if</span> <span class="s1">&#39;generalized_poisson_llh&#39;</span> <span class="o">==</span> <span class="n">metric</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">generalized_poisson_dist</span> <span class="o">=</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">get_outputs</span><span class="p">(</span><span class="n">return_sum</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">force_standard_output</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">generalized_poisson_dist</span> <span class="o">=</span> <span class="n">merge_mapsets_together</span><span class="p">(</span><span class="n">mapset_list</span><span class="o">=</span><span class="n">generalized_poisson_dist</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">generalized_poisson_dist</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">detailed_metric_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_detailed_metric_info</span><span class="p">(</span>
                    <span class="n">data_dist</span><span class="o">=</span><span class="n">data_dist</span><span class="p">,</span> <span class="n">hypo_asimov_dist</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hypo_asimov_dist</span><span class="p">,</span> <span class="n">generalized_poisson_hypo</span><span class="o">=</span><span class="n">generalized_poisson_dist</span><span class="p">,</span>
                    <span class="n">params</span><span class="o">=</span><span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">other_metrics</span><span class="o">=</span><span class="n">other_metrics</span><span class="p">,</span>
                    <span class="n">detector_name</span><span class="o">=</span><span class="n">hypo_maker</span><span class="o">.</span><span class="n">detector_name</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="o">=</span><span class="n">hypo_maker</span>
                <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_attrs</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown property </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_rehash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_param_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">hash</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="c1"># Safety feature: Because we pass this object as a record of the best fit</span>
        <span class="c1"># through several function, we need to make sure the parameters are not</span>
        <span class="c1"># corrupted on the way.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">hash</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_param_hash</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;The parameter hash doesn&#39;t match, parameters might have&quot;</span>
                <span class="s2">&quot; been changed accidentally. This can happen if the parameters from&quot;</span>
                <span class="s2">&quot; this object have been used to update the params inside a&quot;</span>
                <span class="s2">&quot; DistributionMaker. Do not access private _params unless you are &quot;</span>
                <span class="s2">&quot; certain that you want to change the parameters and then _rehash.&quot;</span><span class="p">)</span>
        <span class="c1"># We MUST ensure that we don&#39;t hand out references to the internal params here</span>
        <span class="c1"># because they could otherwise be manipulated inadvertently.</span>
        <span class="k">return</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_params</span><span class="p">)</span>

    <span class="nd">@params</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newpars</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">newpars</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_params</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_param_hash</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">newpars</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="c1"># Comparing to `list`, not `Sequence`, because if `newpars` are a `ParamSet`</span>
            <span class="c1"># the test for membership of `Sequence` would return `True`.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_params</span> <span class="o">=</span> <span class="n">ParamSet</span><span class="p">(</span><span class="n">newpars</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The constructor of ParamSet is *not* a copy-constructor! The parameters</span>
            <span class="c1"># making up the ParamSet are instead taken over by reference only. This is</span>
            <span class="c1"># why we must use `deepcopy` here and can&#39;t just use ParamSet(newpars) for</span>
            <span class="c1"># everything.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_params</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">newpars</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rehash</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">detailed_metric_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_detailed_metric_info</span>

    <span class="nd">@detailed_metric_info</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">detailed_metric_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_info</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">new_info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_detailed_metric_info</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_info</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_detailed_metric_info</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">deserialize_detailed_metric_info</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">new_info</span>
            <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_detailed_metric_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deserialize_detailed_metric_info</span><span class="p">(</span><span class="n">new_info</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">hypo_asimov_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypo_asimov_dist</span>

    <span class="nd">@hypo_asimov_dist</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">hypo_asimov_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_had</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_had</span><span class="p">,</span> <span class="n">MapSet</span><span class="p">)</span> <span class="ow">or</span> <span class="n">new_had</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hypo_asimov_dist</span> <span class="o">=</span> <span class="n">new_had</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_had</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
            <span class="c1"># instantiating from serializable state</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hypo_asimov_dist</span> <span class="o">=</span> <span class="n">MapSet</span><span class="p">(</span><span class="o">**</span><span class="n">new_had</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_had</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">MapSet</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">new_had</span><span class="p">):</span>
            <span class="c1"># for detector class output</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hypo_asimov_dist</span> <span class="o">=</span> <span class="n">new_had</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid format for hypo_asimov_dist&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_attrs</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="s1">&#39;state&#39;</span><span class="p">):</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">state</span>
            <span class="n">setitem</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">state</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">serializable_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_state</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">_state_attrs</span><span class="p">),</span> <span class="s2">&quot;ill-formed state dict&quot;</span>
        <span class="n">new_obj</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_state_attrs</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">new_obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">state</span><span class="p">[</span><span class="n">attr</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">new_obj</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_detailed_metric_info</span><span class="p">(</span><span class="n">data_dist</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">hypo_asimov_dist</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span>
                                 <span class="n">generalized_poisson_hypo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">other_metrics</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">detector_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get detailed fit information, including e.g. maps that yielded the</span>
<span class="sd">        metric.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data_dist</span>
<span class="sd">        hypo_asimov_dist</span>
<span class="sd">        params</span>
<span class="sd">        metric</span>
<span class="sd">        other_metrics</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        detailed_metric_info : OrderedDict</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other_metrics</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">other_metrics</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other_metrics</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">other_metrics</span> <span class="o">=</span> <span class="p">[</span><span class="n">other_metrics</span><span class="p">]</span>
        <span class="n">all_metrics</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">metric</span><span class="p">]</span> <span class="o">+</span> <span class="n">other_metrics</span><span class="p">))</span>
        <span class="n">detailed_metric_info</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">detector_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">detailed_metric_info</span><span class="p">[</span><span class="s1">&#39;detector_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">detector_name</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">all_metrics</span><span class="p">:</span>
            <span class="n">name_vals_d</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

            <span class="c1"># if the metric is not generalized poisson, but the distribution is a dict,</span>
            <span class="c1"># retrieve the &#39;weights&#39; mapset from the distribution output</span>
            <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="s1">&#39;generalized_poisson_llh&#39;</span><span class="p">:</span>
                <span class="n">name_vals_d</span><span class="p">[</span><span class="s1">&#39;maps&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_dist</span><span class="o">.</span><span class="n">maps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">generalized_poisson_llh</span><span class="p">(</span><span class="n">expected_values</span><span class="o">=</span><span class="n">generalized_poisson_hypo</span><span class="p">)</span>
                <span class="n">llh_binned</span> <span class="o">=</span> <span class="n">data_dist</span><span class="o">.</span><span class="n">maps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">generalized_poisson_llh</span><span class="p">(</span><span class="n">expected_values</span><span class="o">=</span><span class="n">generalized_poisson_hypo</span><span class="p">,</span> <span class="n">binned</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">map_binned</span> <span class="o">=</span> <span class="n">Map</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span>
                                <span class="n">hist</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">llh_binned</span><span class="p">,</span> <span class="n">data_dist</span><span class="o">.</span><span class="n">maps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
                                <span class="n">binning</span><span class="o">=</span><span class="n">data_dist</span><span class="o">.</span><span class="n">maps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">binning</span>
                    <span class="p">)</span>
                <span class="n">name_vals_d</span><span class="p">[</span><span class="s1">&#39;maps_binned&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MapSet</span><span class="p">(</span><span class="n">map_binned</span><span class="p">)</span>
                <span class="n">name_vals_d</span><span class="p">[</span><span class="s1">&#39;priors&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">priors_penalties</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">)</span>
                <span class="n">detailed_metric_info</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">name_vals_d</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hypo_asimov_dist</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">):</span>
                    <span class="n">hypo_asimov_dist</span> <span class="o">=</span> <span class="n">hypo_asimov_dist</span><span class="p">[</span><span class="s1">&#39;weights&#39;</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="s1">&#39;weighted_chi2&#39;</span><span class="p">:</span>
                    <span class="n">actual_values</span> <span class="o">=</span> <span class="n">data_dist</span><span class="o">.</span><span class="n">hist</span><span class="p">[</span><span class="s1">&#39;total&#39;</span><span class="p">]</span>
                    <span class="n">expected_values</span> <span class="o">=</span> <span class="n">hypo_asimov_dist</span><span class="o">.</span><span class="n">hist</span><span class="p">[</span><span class="s1">&#39;total&#39;</span><span class="p">]</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;output_binning&#39;</span><span class="p">:</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">pipelines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">output_binning</span><span class="p">,</span>
                         <span class="s1">&#39;output_key&#39;</span><span class="p">:</span> <span class="s1">&#39;bin_unc2&#39;</span><span class="p">}</span>
                    <span class="n">bin_unc2</span> <span class="o">=</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">get_outputs</span><span class="p">(</span><span class="n">return_sum</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">hist</span><span class="p">[</span><span class="s1">&#39;total&#39;</span><span class="p">]</span>
                    <span class="n">metric_hists</span> <span class="o">=</span> <span class="n">weighted_chi2</span><span class="p">(</span><span class="n">actual_values</span><span class="p">,</span> <span class="n">expected_values</span><span class="p">,</span> <span class="n">bin_unc2</span><span class="p">)</span>
                    <span class="n">name_vals_d</span><span class="p">[</span><span class="s1">&#39;maps&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">metric_hists</span><span class="p">))</span>
                    <span class="n">metric_hists</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="n">metric_hists</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">name_vals_d</span><span class="p">[</span><span class="s1">&#39;maps&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_dist</span><span class="o">.</span><span class="n">metric_per_map</span><span class="p">(</span>
                        <span class="n">expected_values</span><span class="o">=</span><span class="n">hypo_asimov_dist</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">m</span>
                    <span class="p">)</span>
                    <span class="n">metric_hists</span> <span class="o">=</span> <span class="n">data_dist</span><span class="o">.</span><span class="n">metric_per_map</span><span class="p">(</span>
                        <span class="n">expected_values</span><span class="o">=</span><span class="n">hypo_asimov_dist</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;binned_&#39;</span><span class="o">+</span><span class="n">m</span>
                    <span class="p">)</span>

                <span class="n">maps_binned</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">asimov_map</span><span class="p">,</span> <span class="n">metric_hist</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hypo_asimov_dist</span><span class="p">,</span> <span class="n">metric_hists</span><span class="p">):</span>
                    <span class="n">map_binned</span> <span class="o">=</span> <span class="n">Map</span><span class="p">(</span>
                        <span class="n">name</span><span class="o">=</span><span class="n">asimov_map</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                        <span class="n">hist</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">metric_hists</span><span class="p">[</span><span class="n">metric_hist</span><span class="p">],</span>
                                        <span class="n">asimov_map</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
                        <span class="n">binning</span><span class="o">=</span><span class="n">asimov_map</span><span class="o">.</span><span class="n">binning</span>
                    <span class="p">)</span>
                    <span class="n">maps_binned</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">map_binned</span><span class="p">)</span>
                <span class="n">name_vals_d</span><span class="p">[</span><span class="s1">&#39;maps_binned&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MapSet</span><span class="p">(</span><span class="n">maps_binned</span><span class="p">)</span>
                <span class="n">name_vals_d</span><span class="p">[</span><span class="s1">&#39;priors&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">priors_penalties</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">)</span>
                <span class="n">detailed_metric_info</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">name_vals_d</span>
        <span class="k">return</span> <span class="n">detailed_metric_info</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">deserialize_detailed_metric_info</span><span class="p">(</span><span class="n">info_dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Re-instantiate all PISA objects that used to be in the dictionary.&quot;&quot;&quot;</span>

        <span class="n">detailed_metric_info</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">if</span> <span class="s2">&quot;detector_name&quot;</span> <span class="ow">in</span> <span class="n">info_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">detailed_metric_info</span><span class="p">[</span><span class="s1">&#39;detector_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">info_dict</span><span class="p">[</span><span class="s2">&quot;detector_name&quot;</span><span class="p">]</span>
        <span class="n">all_metrics</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">info_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">-</span> <span class="p">{</span><span class="s2">&quot;detector_name&quot;</span><span class="p">})</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">all_metrics</span><span class="p">:</span>
            <span class="n">name_vals_d</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="n">name_vals_d</span><span class="p">[</span><span class="s1">&#39;maps&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">info_dict</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="s2">&quot;maps&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">info_dict</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="s2">&quot;maps_binned&quot;</span><span class="p">],</span> <span class="n">MapSet</span><span class="p">):</span>
                <span class="c1"># If this has already been deserialized or never serialized in the</span>
                <span class="c1"># first place, just pass through.</span>
                <span class="n">name_vals_d</span><span class="p">[</span><span class="s2">&quot;maps_binned&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">info_dict</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="s2">&quot;maps_binned&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Deserialize if necessary</span>
                <span class="n">name_vals_d</span><span class="p">[</span><span class="s1">&#39;maps_binned&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MapSet</span><span class="p">(</span><span class="o">**</span><span class="n">info_dict</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="s2">&quot;maps_binned&quot;</span><span class="p">])</span>
            <span class="n">name_vals_d</span><span class="p">[</span><span class="s1">&#39;priors&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">info_dict</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="s2">&quot;priors&quot;</span><span class="p">]</span>
            <span class="n">detailed_metric_info</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">name_vals_d</span>
        <span class="k">return</span> <span class="n">detailed_metric_info</span>


<div class="viewcode-block" id="BasicAnalysis">
<a class="viewcode-back" href="../../../pisa.analysis.html#pisa.analysis.analysis.BasicAnalysis">[docs]</a>
<span class="k">class</span> <span class="nc">BasicAnalysis</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A bare-bones analysis that only fits a hypothesis to data.</span>

<span class="sd">    Full analyses with functionality beyond just fitting (doing scans, for example)</span>
<span class="sd">    should sub-class this class.</span>

<span class="sd">    Every fit is run with the `fit_recursively` method, where the fit strategy is</span>
<span class="sd">    defined by the three arguments `method`, `method_kwargs` and</span>
<span class="sd">    `local_fit_kwargs` (see documentation of :py:meth:`fit_recursively` below for</span>
<span class="sd">    other arguments.) The `method` argument determines which sub-routine should be</span>
<span class="sd">    run, `method_kwargs` is a dictionary with any keyword arguments of that</span>
<span class="sd">    sub-routine, and `local_fit_kwargs` is a dictionary (or list thereof) defining any</span>
<span class="sd">    nested sub-routines that are run within the outer sub-routine. A sub-sub-routine</span>
<span class="sd">    defined in `local_fit_kwargs` should again be a dictionary with the three keywords</span>
<span class="sd">    `method`, `method_kwargs` and `local_fit_kwargs`. In this way, sub-routines</span>
<span class="sd">    can be arbitrarily stacked to define complex fit strategies.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    A canonical standard oscillation fit fits octants in `theta23` separately and then</span>
<span class="sd">    runs a scipy minimizer to optimize locally in each octant. The arguments that would</span>
<span class="sd">    produce that result when passed to `fit_recursively` are:</span>
<span class="sd">    ::</span>
<span class="sd">        method = &quot;octants&quot;</span>
<span class="sd">        method_kwargs = {</span>
<span class="sd">            &quot;angle&quot;: &quot;theta23&quot;</span>
<span class="sd">            &quot;inflection_point&quot;: 45 * ureg.deg</span>
<span class="sd">        }</span>
<span class="sd">        local_fit_kwargs = {</span>
<span class="sd">            &quot;method&quot;: &quot;scipy&quot;,</span>
<span class="sd">            &quot;method_kwargs&quot;: minimizer_settings,</span>
<span class="sd">            &quot;local_fit_kwargs&quot;: None</span>
<span class="sd">        }</span>

<span class="sd">    Let&#39;s say we also have a CP violating phase `deltacp24` that we want to fit</span>
<span class="sd">    separately per quadrant split at 90 degrees. We want this done within each</span>
<span class="sd">    quadrant fit for `theta23`, making 4 fits in total. Then we would nest the</span>
<span class="sd">    quadrant fit for `deltacp24` inside the octant fit like so:</span>
<span class="sd">    ::</span>
<span class="sd">        method = &quot;octants&quot;</span>
<span class="sd">        method_kwargs = {</span>
<span class="sd">            &quot;angle&quot;: &quot;theta23&quot;</span>
<span class="sd">            &quot;inflection_point&quot;: 45 * ureg.deg</span>
<span class="sd">        }</span>
<span class="sd">        local_fit_kwargs = {</span>
<span class="sd">            &quot;method&quot;: &quot;octants&quot;,</span>
<span class="sd">            &quot;method_kwargs&quot;: {</span>
<span class="sd">                &quot;angle&quot;: &quot;deltacp24&quot;,</span>
<span class="sd">                &quot;inflection_point&quot;: 90 * ureg.deg,</span>
<span class="sd">            }</span>
<span class="sd">            &quot;local_fit_kwargs&quot;: {</span>
<span class="sd">                &quot;method&quot;: &quot;scipy&quot;,</span>
<span class="sd">                &quot;method_kwargs&quot;: minimizer_settings,</span>
<span class="sd">                &quot;local_fit_kwargs&quot;: None</span>
<span class="sd">            }</span>
<span class="sd">        }</span>

<span class="sd">    Let&#39;s suppose we want to apply a grid-scan global fit method to sterile mixing</span>
<span class="sd">    parameters `theta24` and `deltam41`, but we want to marginalize over all other</span>
<span class="sd">    parameters with a usual 3-flavor fit configuration. That could be achieved as</span>
<span class="sd">    follows:</span>
<span class="sd">    ::</span>
<span class="sd">        method = &quot;grid_scan&quot;</span>
<span class="sd">        method_kwargs = {</span>
<span class="sd">            &quot;grid&quot;: {</span>
<span class="sd">                &quot;theta24&quot;: np.geomspace(1, 20, 3) * ureg.deg,</span>
<span class="sd">                &quot;deltam41&quot;: np.geomspace(0.01, 0.5, 4) * ureg[&quot;eV^2&quot;],</span>
<span class="sd">            },</span>
<span class="sd">            &quot;fix_grid_params&quot;: False,</span>
<span class="sd">        }</span>
<span class="sd">        local_fit_kwargs = {</span>
<span class="sd">            &quot;method&quot;: &quot;octants&quot;,</span>
<span class="sd">            &quot;method_kwargs&quot;: {</span>
<span class="sd">                &quot;angle&quot;: &quot;theta23&quot;,</span>
<span class="sd">                &quot;inflection_point&quot;: 45 * ureg.deg,</span>
<span class="sd">            }</span>
<span class="sd">            &quot;local_fit_kwargs&quot;: {</span>
<span class="sd">                &quot;method&quot;: &quot;scipy&quot;,</span>
<span class="sd">                &quot;method_kwargs&quot;: minimizer_settings,</span>
<span class="sd">                &quot;local_fit_kwargs&quot;: None</span>
<span class="sd">            }</span>
<span class="sd">        }</span>

<span class="sd">    Instead of `scipy`, we can also use `iminuit` and `nlopt` for local minimization or</span>
<span class="sd">    global searches by writing a dictionary with ``&quot;method&quot;: &quot;iminuit&quot;`` or ``&quot;method&quot;:</span>
<span class="sd">    &quot;nlopt&quot;``, respectively.</span>

<span class="sd">    **NLOPT Options**</span>

<span class="sd">    NLOPT can be dropped in place of `scipy` and `iminuit` by writing a dictionary with</span>
<span class="sd">    ``&quot;method&quot;: &quot;nlopt&quot;`` and choosing the algorithm by its name of the form</span>
<span class="sd">    ``NLOPT_{G,L}{N}_XXXX``. PISA supports all of the derivative-free global</span>
<span class="sd">    (https://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/#global-optimization) and</span>
<span class="sd">    local</span>
<span class="sd">    (https://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/#local-derivative-free-optimization)</span>
<span class="sd">    algorithms. Algorithms requiring gradients such as BFGS are not supported. To use</span>
<span class="sd">    the Nelder-Mead algorithm, for example, the following settings could be used:</span>
<span class="sd">    ::</span>
<span class="sd">        nlopt_settings = {</span>
<span class="sd">            &quot;method&quot;: &quot;nlopt&quot;,</span>
<span class="sd">            &quot;method_kwargs&quot;: {</span>
<span class="sd">                &quot;algorithm&quot;: &quot;NLOPT_LN_NELDERMEAD&quot;,</span>
<span class="sd">                &quot;ftol_abs&quot;: 1e-5,</span>
<span class="sd">                &quot;ftol_rel&quot;: 1e-5,</span>
<span class="sd">                # other options that can be set here:</span>
<span class="sd">                # xtol_abs, xtol_rel, stopval, maxeval, maxtime</span>
<span class="sd">                # after maxtime seconds, stop and return best result so far</span>
<span class="sd">                &quot;maxtime&quot;: 60</span>
<span class="sd">            },</span>
<span class="sd">            &quot;local_fit_kwargs&quot;: None  # no further nesting available</span>
<span class="sd">        }</span>

<span class="sd">    and then run the fit with</span>
<span class="sd">    ::</span>
<span class="sd">        best_fit_info = ana.fit_recursively(</span>
<span class="sd">            data_dist,</span>
<span class="sd">            dm,</span>
<span class="sd">            &quot;chi2&quot;,</span>
<span class="sd">            None,</span>
<span class="sd">            **nlopt_settings</span>
<span class="sd">        )</span>

<span class="sd">    . Of course, you can also nest the `nlopt_settings` dictionary in any of the</span>
<span class="sd">    `octants`, `ranges` and so on by passing it as `local_fit_kwargs`.</span>

<span class="sd">    *Adding constraints*</span>

<span class="sd">    Adding inequality constraints to algorithms that support it is possible by writing a</span>
<span class="sd">    lambda function in a string that expects to get the current parameters as a</span>
<span class="sd">    `ParamSet` and returns a float. The result will satisfy that the passed function</span>
<span class="sd">    stays `negative` (to be consistent with scipy). The string will be passed to</span>
<span class="sd">    `eval` to build the callable function. For example, a silly way to bound</span>
<span class="sd">    `delta_index` &gt; 0.1 would be:</span>
<span class="sd">    ::</span>
<span class="sd">        &quot;method_kwargs&quot;: {</span>
<span class="sd">            &quot;algorithm&quot;: &quot;NLOPT_LN_COBYLA&quot;,</span>
<span class="sd">            &quot;ftol_abs&quot;: 1e-5,</span>
<span class="sd">            &quot;ftol_rel&quot;: 1e-5,</span>
<span class="sd">            &quot;maxtime&quot;: 30,</span>
<span class="sd">            &quot;ineq_constraints&quot;: [</span>
<span class="sd">                # be sure to convert parameters to their magnitude</span>
<span class="sd">                &quot;lambda params: params.delta_index.m - 0.1&quot;</span>
<span class="sd">            ]</span>
<span class="sd">        }</span>

<span class="sd">    Adding inequality constraints to algorithms that don&#39;t support it can be done by</span>
<span class="sd">    either nesting the local fit in the `constrained_fit` method or to use NLOPT&#39;s</span>
<span class="sd">    AUGLAG method that adds a penalty for constraint violations internally. For example,</span>
<span class="sd">    we could do this to fulfill the same constraint with the PRAXIS algorithm:</span>
<span class="sd">    ::</span>
<span class="sd">        &quot;method_kwargs&quot;: {</span>
<span class="sd">            &quot;algorithm&quot;: &quot;NLOPT_AUGLAG&quot;,</span>
<span class="sd">            &quot;ineq_constraints&quot;:[</span>
<span class="sd">                &quot;lambda params: params.delta_index.m - 0.1&quot;</span>
<span class="sd">            ],</span>
<span class="sd">            &quot;local_optimizer&quot;: {</span>
<span class="sd">                # supports all the same options as above</span>
<span class="sd">                &quot;algorithm&quot;: &quot;NLOPT_LN_PRAXIS&quot;,</span>
<span class="sd">                &quot;ftol_abs&quot;: 1e-5,</span>
<span class="sd">                &quot;ftol_rel&quot;: 1e-5,</span>
<span class="sd">            }</span>
<span class="sd">        }</span>

<span class="sd">    *Using global searches with local subsidiary minimizers*</span>

<span class="sd">    Some global searches, like evolutionary strategies, use local subsidiary minimizers.</span>
<span class="sd">    These can be defined just as above by passing a dictionary with the settings to the</span>
<span class="sd">    `local_optimizer` keyword. Note that, again, only gradient-free methods are</span>
<span class="sd">    supported. Here is an example for the &quot;Multi-Level single linkage&quot; (MLSL) algorithm,</span>
<span class="sd">    using PRAXIS as the local optimizer:</span>
<span class="sd">    ::</span>
<span class="sd">        &quot;method_kwargs&quot;: {</span>
<span class="sd">            &quot;algorithm&quot;: &quot;NLOPT_G_MLSL_LDS&quot;,</span>
<span class="sd">            &quot;local_optimizer&quot;: {</span>
<span class="sd">                &quot;algorithm&quot;: &quot;NLOPT_LN_PRAXIS&quot;,</span>
<span class="sd">                &quot;ftol_abs&quot;: 1e-5,</span>
<span class="sd">                &quot;ftol_rel&quot;: 1e-5,</span>
<span class="sd">            }</span>
<span class="sd">        }</span>
<span class="sd">    For some evolutionary strategies such as ISRES, the `population` option  can also</span>
<span class="sd">    be set.</span>
<span class="sd">    ::</span>
<span class="sd">        &quot;method_kwargs&quot;: {</span>
<span class="sd">            &quot;algorithm&quot;: &quot;NLOPT_GN_ISRES&quot;,</span>
<span class="sd">            &quot;population&quot;: 100,</span>
<span class="sd">        }</span>

<span class="sd">    **Custom fitting methods**</span>

<span class="sd">    Custom fitting methods are added by subclassing the analysis. The fit function</span>
<span class="sd">    name has to follow the scheme `_fit_{method}` where `method` is the name of the</span>
<span class="sd">    fit method. For instance, the function for `scipy` is called `_fit_scipy` and can</span>
<span class="sd">    be called by setting `&quot;method&quot;: &quot;scipy&quot;` in the fit strategy dict.</span>

<span class="sd">    The function has to accept the parameters `data_dist`, `hypo_maker`, `metric`,</span>
<span class="sd">    `external_priors_penalty`, `method_kwargs`, and `local_fit_kwargs`. See docstring</span>
<span class="sd">    of `fit_recursively` for descriptions of these arguments. The return value</span>
<span class="sd">    of the function must be a `HypoFitResult` object. As an example, the following</span>
<span class="sd">    sub-class of the BasicAnalysis has a custom fit method that, nonsensically,</span>
<span class="sd">    always sets 42 degrees as the starting value for theta23:</span>
<span class="sd">    ::</span>
<span class="sd">        class SubclassedAnalysis(BasicAnalysis):</span>

<span class="sd">            def _fit_nonsense(</span>
<span class="sd">                self, data_dist, hypo_maker, metric,</span>
<span class="sd">                external_priors_penalty, method_kwargs, local_fit_kwargs</span>
<span class="sd">            ):</span>
<span class="sd">                logging.info(&quot;Starting nonsense fit (setting theta23 to 42 deg)...&quot;)</span>

<span class="sd">                for pipeline in hypo_maker:</span>
<span class="sd">                    if &quot;theta23&quot; in pipeline.params.free.names:</span>
<span class="sd">                        pipeline.params.theta23.value = 42 * ureg[&quot;deg&quot;]</span>

<span class="sd">                best_fit_info = self.fit_recursively(</span>
<span class="sd">                    data_dist, hypo_maker, metric, external_priors_penalty,</span>
<span class="sd">                    local_fit_kwargs[&quot;method&quot;], local_fit_kwargs[&quot;method_kwargs&quot;],</span>
<span class="sd">                    local_fit_kwargs[&quot;local_fit_kwargs&quot;]</span>
<span class="sd">                )</span>

<span class="sd">                return best_fit_info</span>

<span class="sd">    Now, the `nonsense` fit method can be used and nested with any other fit method</span>
<span class="sd">    like so:</span>
<span class="sd">    ::</span>
<span class="sd">        ana = SubclassedAnalysis()</span>
<span class="sd">        local_minuit = OrderedDict(</span>
<span class="sd">            method=&quot;iminuit&quot;,</span>
<span class="sd">            method_kwargs={</span>
<span class="sd">                &quot;tol&quot;: 10,</span>
<span class="sd">            },</span>
<span class="sd">            local_fit_kwargs=None</span>
<span class="sd">        )</span>

<span class="sd">        local_nonsense_minuit = OrderedDict(</span>
<span class="sd">            method=&quot;nonsense&quot;,</span>
<span class="sd">            method_kwargs=None,</span>
<span class="sd">            local_fit_kwargs=local_minuit</span>
<span class="sd">        )</span>

<span class="sd">        fit_result = ana.fit_recursively(</span>
<span class="sd">            data_dist,</span>
<span class="sd">            distribution_maker,</span>
<span class="sd">            &quot;chi2&quot;,</span>
<span class="sd">            None,</span>
<span class="sd">            **local_nonsense_minuit</span>
<span class="sd">        )</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nit</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pprint</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blindness</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># TODO: Defer sub-fits to cluster</span>
<div class="viewcode-block" id="BasicAnalysis.fit_recursively">
<a class="viewcode-back" href="../../../pisa.analysis.html#pisa.analysis.analysis.BasicAnalysis.fit_recursively">[docs]</a>
    <span class="k">def</span> <span class="nf">fit_recursively</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">data_dist</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">external_priors_penalty</span><span class="p">,</span>
            <span class="n">method</span><span class="p">,</span> <span class="n">method_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">local_fit_kwargs</span><span class="o">=</span><span class="kc">None</span>
        <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Recursively apply global search strategies with local sub-fits.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        data_dist : Sequence of MapSets or MapSet</span>
<span class="sd">            Data distribution to be fit. Can be an actual-, Asimov-, or pseudo-data</span>
<span class="sd">            distribution (where the latter two are derived from simulation and so aren&#39;t</span>
<span class="sd">            technically &quot;data&quot;).</span>

<span class="sd">        hypo_maker : Detectors or DistributionMaker</span>
<span class="sd">            Creates the per-bin expectation values per map based on its param values.</span>
<span class="sd">            Free params in the `hypo_maker` are modified by the minimizer to achieve a</span>
<span class="sd">            &quot;best&quot; fit.</span>

<span class="sd">        metric : string or iterable of strings</span>
<span class="sd">            Metric by which to evaluate the fit. See documentation of Map.</span>

<span class="sd">        external_priors_penalty : func</span>
<span class="sd">            User defined prior penalty function, which takes `hypo_maker` and</span>
<span class="sd">            `metric` as arguments and returns numerical value of penalty to the metric</span>
<span class="sd">            value. It is expected sign of the penalty is correctly specified inside the</span>
<span class="sd">            `external_priors_penalty` (e.g. negative for llh or positive for chi2).</span>

<span class="sd">        method : str</span>
<span class="sd">            Name of the sub-routine to be run. Currently, the options are `scipy`,</span>
<span class="sd">            `octants`, `best_of`, `grid_scan`, `constrained`,</span>
<span class="sd">            `ranges`, `condition`, `iminuit`, and `nlopt`.</span>

<span class="sd">        method_kwargs : dict</span>
<span class="sd">            Any keyword arguments taken by the sub-routine. May be `None` if the</span>
<span class="sd">            sub-routine takes no additional arguments.</span>

<span class="sd">        local_fit_kwargs : dict or list thereof</span>
<span class="sd">            A dictionary defining subsidiary sub-routines with the keywords `method`,</span>
<span class="sd">            `method_kwargs` and `local_fit_kwargs`. May be `None` if the</span>
<span class="sd">            sub-routine is itself a local or global fit that runs no further subsidiary</span>
<span class="sd">            fits.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">metric</span> <span class="o">=</span> <span class="p">[</span><span class="n">metric</span><span class="p">]</span>

        <span class="c1"># Before starting any fit, check if we already have a perfect match between data and template</span>
        <span class="c1"># This can happen if using pseudodata that was generated with the nominal values for parameters</span>
        <span class="c1"># (which will also be the initial values in the fit) and blah...</span>
        <span class="c1"># If this is the case, don&#39;t both to fit and return results right away.</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">metric</span> <span class="o">=</span> <span class="p">[</span><span class="n">metric</span><span class="p">]</span>

        <span class="c1"># Grab the hypo map</span>
        <span class="n">hypo_asimov_dist</span> <span class="o">=</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">get_outputs</span><span class="p">(</span><span class="n">return_sum</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">metric</span> <span class="o">=</span> <span class="p">[</span><span class="n">metric</span><span class="p">]</span>
        <span class="c1"># Check number of used metrics</span>
        <span class="k">if</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;Detectors&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># One metric for all detectors</span>
                <span class="n">metric</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">hypo_maker</span><span class="o">.</span><span class="n">distribution_makers</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">hypo_maker</span><span class="o">.</span><span class="n">distribution_makers</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;Number of defined metrics does not match with number of detectors.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># DistributionMaker object</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

        <span class="c1"># Check if the hypo matches data</span>
        <span class="k">if</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">!=</span> <span class="s2">&quot;Detectors&quot;</span> <span class="ow">and</span> <span class="n">data_dist</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">hypo_asimov_dist</span><span class="p">)</span> <span class="p">:</span>

            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Initial hypo matches data, no need for fit&#39;</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="c1"># Get the metric value at this initial point</span>
            <span class="c1"># This is for returning as part of the &quot;fit&quot; results</span>
            <span class="n">initial_metric_val</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">data_dist</span><span class="o">.</span><span class="n">metric_total</span><span class="p">(</span><span class="n">expected_values</span><span class="o">=</span><span class="n">hypo_asimov_dist</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="o">+</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">priors_penalty</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="p">)</span>

            <span class="c1"># Return fit results, even though didn&#39;t technically fit</span>
            <span class="k">return</span> <span class="n">HypoFitResult</span><span class="p">(</span>
                <span class="n">metric</span><span class="p">,</span>
                <span class="n">initial_metric_val</span><span class="p">,</span>
                <span class="n">data_dist</span><span class="p">,</span>
                <span class="n">hypo_maker</span><span class="p">,</span>
                <span class="n">minimizer_time</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span>
                <span class="n">minimizer_metadata</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;success&quot;</span><span class="p">:</span><span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;nit&quot;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;message&quot;</span><span class="p">:</span><span class="n">msg</span><span class="p">},</span> <span class="c1"># Add some metadata in the format returned by `scipy.optimize.minimize`</span>
                <span class="n">fit_history</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">other_metrics</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">num_distributions_generated</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">include_detailed_metric_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;fit_octants&quot;</span><span class="p">,</span> <span class="s2">&quot;fit_ranges&quot;</span><span class="p">]:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;fit method &#39;fit_</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&#39; has been re-named to &#39;</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>

        <span class="c1"># If made it here, we have a fit to do...</span>
        <span class="n">fit_function</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;_fit_</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># Run the fit function</span>
        <span class="k">return</span> <span class="n">fit_function</span><span class="p">(</span><span class="n">data_dist</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">external_priors_penalty</span><span class="p">,</span>
                            <span class="n">method_kwargs</span><span class="p">,</span> <span class="n">local_fit_kwargs</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_fit_octants</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dist</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">external_priors_penalty</span><span class="p">,</span>
                     <span class="n">method_kwargs</span><span class="p">,</span> <span class="n">local_fit_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A simple global optimization scheme that searches mixing angle octants.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">angle_name</span> <span class="o">=</span> <span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;angle&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">angle_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">angle_name</span><span class="si">}</span><span class="s2"> is not a free parameter, skipping octant check&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_recursively</span><span class="p">(</span>
                <span class="n">data_dist</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">external_priors_penalty</span><span class="p">,</span>
                <span class="n">local_fit_kwargs</span><span class="p">[</span><span class="s2">&quot;method&quot;</span><span class="p">],</span> <span class="n">local_fit_kwargs</span><span class="p">[</span><span class="s2">&quot;method_kwargs&quot;</span><span class="p">],</span>
                <span class="n">local_fit_kwargs</span><span class="p">[</span><span class="s2">&quot;local_fit_kwargs&quot;</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="n">inflection_point</span> <span class="o">=</span> <span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;inflection_point&quot;</span><span class="p">]</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Entering octant fit for angle </span><span class="si">{</span><span class="n">angle_name</span><span class="si">}</span><span class="s2"> with inflection &quot;</span>
                      <span class="sa">f</span><span class="s2">&quot;point at </span><span class="si">{</span><span class="n">inflection_point</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1">#### Removed, fitting always separately.</span>
        <span class="c1">#    Is there a reason not to fit separately, ever?</span>
        <span class="c1"># fit_octants_separately = True</span>
        <span class="c1"># if &quot;fit_octants_separately&quot; in method_kwargs.keys():</span>
        <span class="c1">#     fit_octants_separately = method_kwargs[&quot;fit_octants_separately&quot;]</span>

        <span class="n">reset_free</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="s2">&quot;reset_free&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">reset_free</span> <span class="o">=</span> <span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;reset_free&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">reset_free</span><span class="p">:</span>
            <span class="c1"># store so we can reset to the values we currently have rather than</span>
            <span class="c1"># resetting free parameters back to their nominal value after the octant</span>
            <span class="c1"># check</span>
            <span class="n">minimizer_start_params</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>

        <span class="n">tolerance</span> <span class="o">=</span> <span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;tolerance&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="s2">&quot;tolerance&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="c1"># Get new angle parameters each limited to one octant</span>
        <span class="n">ang_orig</span><span class="p">,</span> <span class="n">ang_case1</span><span class="p">,</span> <span class="n">ang_case2</span> <span class="o">=</span> <span class="n">get_separate_octant_params</span><span class="p">(</span>
            <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">angle_name</span><span class="p">,</span> <span class="n">inflection_point</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span>
        <span class="p">)</span>

        <span class="c1"># Fit the first octant</span>
        <span class="c1"># In this case it is OK to replace the memory reference, we will reinstate it</span>
        <span class="c1"># later.</span>
        <span class="n">hypo_maker</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">ang_case1</span><span class="p">)</span>
        <span class="n">best_fit_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_recursively</span><span class="p">(</span>
            <span class="n">data_dist</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">external_priors_penalty</span><span class="p">,</span>
            <span class="n">local_fit_kwargs</span><span class="p">[</span><span class="s2">&quot;method&quot;</span><span class="p">],</span> <span class="n">local_fit_kwargs</span><span class="p">[</span><span class="s2">&quot;method_kwargs&quot;</span><span class="p">],</span>
            <span class="n">local_fit_kwargs</span><span class="p">[</span><span class="s2">&quot;local_fit_kwargs&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">blindness</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;found best fit at angle </span><span class="si">{</span><span class="n">best_fit_info</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">angle_name</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;checking other octant of </span><span class="si">{</span><span class="n">angle_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">reset_free</span><span class="p">:</span>
            <span class="n">hypo_maker</span><span class="o">.</span><span class="n">reset_free</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">minimizer_start_params</span><span class="p">:</span>
                <span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">value</span>

        <span class="c1"># Fit the second octant</span>
        <span class="n">hypo_maker</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">ang_case2</span><span class="p">)</span>
        <span class="n">new_fit_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_recursively</span><span class="p">(</span>
            <span class="n">data_dist</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">external_priors_penalty</span><span class="p">,</span>
            <span class="n">local_fit_kwargs</span><span class="p">[</span><span class="s2">&quot;method&quot;</span><span class="p">],</span> <span class="n">local_fit_kwargs</span><span class="p">[</span><span class="s2">&quot;method_kwargs&quot;</span><span class="p">],</span>
            <span class="n">local_fit_kwargs</span><span class="p">[</span><span class="s2">&quot;local_fit_kwargs&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">blindness</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;found best fit at angle </span><span class="si">{</span><span class="n">new_fit_info</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">angle_name</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


        <span class="c1"># We must not forget to reset the range of the angle to its original value!</span>
        <span class="c1"># Otherwise, the parameter returned by this function will have a different</span>
        <span class="c1"># range, which can cause failures further down the line!</span>
        <span class="c1"># This is one rare instance where we directly manipulate the parameters, so</span>
        <span class="c1"># we re-hash.</span>
        <span class="n">best_fit_info</span><span class="o">.</span><span class="n">_params</span><span class="p">[</span><span class="n">angle_name</span><span class="p">]</span><span class="o">.</span><span class="n">range</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">ang_orig</span><span class="o">.</span><span class="n">range</span><span class="p">)</span>
        <span class="n">best_fit_info</span><span class="o">.</span><span class="n">_rehash</span><span class="p">()</span>
        <span class="n">new_fit_info</span><span class="o">.</span><span class="n">_params</span><span class="p">[</span><span class="n">angle_name</span><span class="p">]</span><span class="o">.</span><span class="n">range</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">ang_orig</span><span class="o">.</span><span class="n">range</span><span class="p">)</span>
        <span class="n">new_fit_info</span><span class="o">.</span><span class="n">_rehash</span><span class="p">()</span>

        <span class="c1"># Take the one with the best fit</span>
        <span class="n">got_better</span> <span class="o">=</span> <span class="n">it_got_better</span><span class="p">(</span><span class="n">new_fit_info</span><span class="o">.</span><span class="n">metric_val</span><span class="p">,</span> <span class="n">best_fit_info</span><span class="o">.</span><span class="n">metric_val</span><span class="p">,</span> <span class="n">metric</span><span class="p">)</span>

        <span class="c1"># TODO: Pass alternative fits up the chain</span>
        <span class="k">if</span> <span class="n">got_better</span><span class="p">:</span>
            <span class="c1"># alternate_fits.append(best_fit_info)</span>
            <span class="n">best_fit_info</span> <span class="o">=</span> <span class="n">new_fit_info</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">blindness</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Accepting other-octant fit&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># alternate_fits.append(new_fit_info)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">blindness</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Accepting initial-octant fit&#39;</span><span class="p">)</span>

        <span class="c1"># Put the original angle parameter (as in, the actual object from memory)</span>
        <span class="c1"># back into the hypo maker</span>
        <span class="n">hypo_maker</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">ang_orig</span><span class="p">)</span>

        <span class="c1"># Copy the fitted parameter values from the best fit case into the hypo maker&#39;s</span>
        <span class="c1"># parameter values.</span>
        <span class="c1"># Also reinstate the original parameter range for the angle</span>
        <span class="k">if</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;Detectors&quot;</span><span class="p">:</span>
            <span class="n">update_param_values_detector</span><span class="p">(</span><span class="n">hypo_maker</span><span class="p">,</span> <span class="n">best_fit_info</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="p">,</span> <span class="n">update_range</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">update_param_values</span><span class="p">(</span><span class="n">hypo_maker</span><span class="p">,</span> <span class="n">best_fit_info</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="p">,</span> <span class="n">update_range</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">best_fit_info</span>

    <span class="k">def</span> <span class="nf">_fit_best_of</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dist</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span>
                     <span class="n">external_priors_penalty</span><span class="p">,</span> <span class="n">method_kwargs</span><span class="p">,</span> <span class="n">local_fit_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Run several manually configured fits and take the best one.</span>

<span class="sd">        The specialty here is that `local_fit_kwargs` is a list, where each element</span>
<span class="sd">        defines one fit.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;running several manually configured fits to choose optimum&quot;</span><span class="p">)</span>

        <span class="n">reset_free</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">method_kwargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="s2">&quot;reset_free&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">reset_free</span> <span class="o">=</span> <span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;reset_free&quot;</span><span class="p">]</span>

        <span class="n">all_fit_results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">fit_kwargs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">local_fit_kwargs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">reset_free</span><span class="p">:</span>
                <span class="n">hypo_maker</span><span class="o">.</span><span class="n">reset_free</span><span class="p">()</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Beginning fit </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2"> / </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">local_fit_kwargs</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">new_fit_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_recursively</span><span class="p">(</span>
                <span class="n">data_dist</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">external_priors_penalty</span><span class="p">,</span>
                <span class="n">fit_kwargs</span><span class="p">[</span><span class="s2">&quot;method&quot;</span><span class="p">],</span> <span class="n">fit_kwargs</span><span class="p">[</span><span class="s2">&quot;method_kwargs&quot;</span><span class="p">],</span>
                <span class="n">fit_kwargs</span><span class="p">[</span><span class="s2">&quot;local_fit_kwargs&quot;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">all_fit_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_fit_info</span><span class="p">)</span>

        <span class="n">all_fit_metric_vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">fit_info</span><span class="o">.</span><span class="n">metric_val</span> <span class="k">for</span> <span class="n">fit_info</span> <span class="ow">in</span> <span class="n">all_fit_results</span><span class="p">]</span>
        <span class="c1"># Take the one with the best fit</span>
        <span class="k">if</span> <span class="n">is_metric_to_maximize</span><span class="p">(</span><span class="n">metric</span><span class="p">):</span>
            <span class="n">best_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">all_fit_metric_vals</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">best_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">all_fit_metric_vals</span><span class="p">)</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found best fit being index </span><span class="si">{</span><span class="n">best_idx</span><span class="si">}</span><span class="s2"> with metric &quot;</span>
                     <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">all_fit_metric_vals</span><span class="p">[</span><span class="n">best_idx</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">all_fit_results</span><span class="p">[</span><span class="n">best_idx</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_fit_condition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dist</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span>
                       <span class="n">external_priors_penalty</span><span class="p">,</span> <span class="n">method_kwargs</span><span class="p">,</span> <span class="n">local_fit_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Run one fit strategy or the other depending on a condition being true.</span>

<span class="sd">        As in the constrained fit, the condition can be a callable or a string that</span>
<span class="sd">        can be evaluated to a callable via `eval()`.</span>

<span class="sd">        `local_fit_kwargs` has to be a list of length 2. The first fit runs if the</span>
<span class="sd">        condition is true, the second one runs if the condition is false.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="s2">&quot;condition_func&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">local_fit_kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;need to fit specs, first runs if True, &quot;</span>
                                            <span class="s2">&quot;second runs if false&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;condition_func&quot;</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Using eval() is potentially dangerous as it can execute &quot;</span>
                <span class="s2">&quot;arbitrary code! Do not store your config file in a place&quot;</span>
                <span class="s2">&quot;where others have writing access!&quot;</span>
            <span class="p">)</span>
            <span class="n">condition_func</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;condition_func&quot;</span><span class="p">])</span>
            <span class="k">assert</span> <span class="nb">callable</span><span class="p">(</span><span class="n">condition_func</span><span class="p">),</span> <span class="s2">&quot;evaluated object is not a valid function&quot;</span>
        <span class="k">elif</span> <span class="nb">callable</span><span class="p">(</span><span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;condition_func&quot;</span><span class="p">]):</span>
            <span class="n">condition_func</span> <span class="o">=</span> <span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;condition_func&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Condition function is neither a callable nor a &quot;</span>
                             <span class="s2">&quot;string that can be evaluated to a callable.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">condition_func</span><span class="p">(</span><span class="n">hypo_maker</span><span class="p">):</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;condition was TRUE, running first fit&quot;</span><span class="p">)</span>
            <span class="n">fit_kwargs</span> <span class="o">=</span> <span class="n">local_fit_kwargs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;condition was FALSE, running second fit&quot;</span><span class="p">)</span>
            <span class="n">fit_kwargs</span> <span class="o">=</span> <span class="n">local_fit_kwargs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_recursively</span><span class="p">(</span>
            <span class="n">data_dist</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">external_priors_penalty</span><span class="p">,</span>
            <span class="n">fit_kwargs</span><span class="p">[</span><span class="s2">&quot;method&quot;</span><span class="p">],</span> <span class="n">fit_kwargs</span><span class="p">[</span><span class="s2">&quot;method_kwargs&quot;</span><span class="p">],</span>
            <span class="n">fit_kwargs</span><span class="p">[</span><span class="s2">&quot;local_fit_kwargs&quot;</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_fit_grid_scan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dist</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span>
                       <span class="n">external_priors_penalty</span><span class="p">,</span> <span class="n">method_kwargs</span><span class="p">,</span> <span class="n">local_fit_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Do a grid scan over starting positions and choose the best fit from the grid.</span>

<span class="sd">        Alternatively, the parameters used for the grid can be fixed in the fit at each</span>
<span class="sd">        grid point, and only the very best fit is then freed up to be refined.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="s2">&quot;grid&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="n">reset_free</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="s2">&quot;reset_free&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">reset_free</span> <span class="o">=</span> <span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;reset_free&quot;</span><span class="p">]</span>
        <span class="n">fix_grid_params</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="s2">&quot;fix_grid_params&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">fix_grid_params</span> <span class="o">=</span> <span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;fix_grid_params&quot;</span><span class="p">]</span>
        <span class="n">grid_params</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;grid&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Starting grid scan over parameters </span><span class="si">{</span><span class="n">grid_params</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">grid_1d_arrs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">grid_units</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">grid_params</span><span class="p">:</span>
            <span class="n">d_spec</span> <span class="o">=</span> <span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;grid&quot;</span><span class="p">][</span><span class="n">p</span><span class="p">]</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">d_spec</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">grid_1d_arrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d_spec</span><span class="o">.</span><span class="n">m</span><span class="p">)</span>
            <span class="n">grid_units</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d_spec</span><span class="o">.</span><span class="n">u</span><span class="p">)</span>
        <span class="n">scan_mesh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">grid_1d_arrs</span><span class="p">)</span>
        <span class="n">scan_mesh</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="o">*</span> <span class="n">u</span> <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">scan_mesh</span><span class="p">,</span> <span class="n">grid_units</span><span class="p">)]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">fix_grid_params</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;This grid only defines the starting value of each fit, &quot;</span>
                         <span class="s2">&quot;all parameters that are free will stay free.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;The grid parameters will be fixed at each grid point.&quot;</span><span class="p">)</span>

        <span class="n">do_refined_fit</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;refined_fit&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="ow">and</span> <span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;refined_fit&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">do_refined_fit</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;The best fit on the grid will be refined using &quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">method_kwargs</span><span class="p">[</span><span class="s1">&#39;refined_fit&#39;</span><span class="p">][</span><span class="s1">&#39;method&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">reset_free</span><span class="p">:</span>
            <span class="n">hypo_maker</span><span class="o">.</span><span class="n">reset_free</span><span class="p">()</span>
        <span class="c1"># when we return from the scan, we want to set all parameters free again that</span>
        <span class="c1"># were free to begin with</span>
        <span class="n">originally_free</span> <span class="o">=</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="o">.</span><span class="n">names</span>
        <span class="n">all_fit_results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">grid_shape</span> <span class="o">=</span> <span class="n">scan_mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">for</span> <span class="n">grid_idx</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">grid_shape</span><span class="p">):</span>
            <span class="n">point</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">mesh</span><span class="p">[</span><span class="n">grid_idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">mesh</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">grid_params</span><span class="p">,</span> <span class="n">scan_mesh</span><span class="p">)}</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;working on grid point </span><span class="si">{</span><span class="n">point</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">reset_free</span><span class="p">:</span>
                <span class="n">hypo_maker</span><span class="o">.</span><span class="n">reset_free</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">param</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">point</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">mod_param</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">param</span><span class="p">])</span>
                <span class="n">mod_param</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
                <span class="k">if</span> <span class="n">fix_grid_params</span><span class="p">:</span>
                    <span class="c1"># it is possible to do a scan over fixed parameters as well as</span>
                    <span class="c1"># free ones; fixed ones always stay fixed, free ones are fixed</span>
                    <span class="c1"># if requested</span>
                    <span class="n">mod_param</span><span class="o">.</span><span class="n">is_fixed</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># It is important not to use hypo_maker.update_params(mod_param) here</span>
                <span class="c1"># because we don&#39;t want to overwrite the memory reference!</span>
                <span class="k">if</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;Detectors&quot;</span><span class="p">:</span>
                    <span class="n">update_param_values_detector</span><span class="p">(</span><span class="n">hypo_maker</span><span class="p">,</span> <span class="n">mod_param</span><span class="p">,</span> <span class="n">update_is_fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">update_param_values</span><span class="p">(</span><span class="n">hypo_maker</span><span class="p">,</span> <span class="n">mod_param</span><span class="p">,</span> <span class="n">update_is_fixed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">new_fit_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_recursively</span><span class="p">(</span>
                <span class="n">data_dist</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">external_priors_penalty</span><span class="p">,</span>
                <span class="n">local_fit_kwargs</span><span class="p">[</span><span class="s2">&quot;method&quot;</span><span class="p">],</span> <span class="n">local_fit_kwargs</span><span class="p">[</span><span class="s2">&quot;method_kwargs&quot;</span><span class="p">],</span>
                <span class="n">local_fit_kwargs</span><span class="p">[</span><span class="s2">&quot;local_fit_kwargs&quot;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">all_fit_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_fit_info</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">originally_free</span><span class="p">:</span>
            <span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">param</span><span class="p">]</span><span class="o">.</span><span class="n">is_fixed</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">all_fit_metric_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">fit_info</span><span class="o">.</span><span class="n">metric_val</span> <span class="k">for</span> <span class="n">fit_info</span> <span class="ow">in</span> <span class="n">all_fit_results</span><span class="p">])</span>
        <span class="n">all_fit_metric_vals</span> <span class="o">=</span> <span class="n">all_fit_metric_vals</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">grid_shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">blindness</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Grid scan metrics:</span><span class="se">\n</span><span class="si">{</span><span class="n">all_fit_metric_vals</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># Take the one with the best fit</span>
        <span class="k">if</span> <span class="n">is_metric_to_maximize</span><span class="p">(</span><span class="n">metric</span><span class="p">):</span>
            <span class="n">best_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">all_fit_metric_vals</span><span class="p">)</span>
            <span class="n">best_idx_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">best_idx</span><span class="p">,</span> <span class="n">all_fit_metric_vals</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">best_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">all_fit_metric_vals</span><span class="p">)</span>
            <span class="n">best_idx_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">best_idx</span><span class="p">,</span> <span class="n">all_fit_metric_vals</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found best fit being index </span><span class="si">{</span><span class="n">best_idx_grid</span><span class="si">}</span><span class="s2"> with metric &quot;</span>
                     <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">all_fit_metric_vals</span><span class="p">[</span><span class="n">best_idx_grid</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">best_fit_result</span> <span class="o">=</span> <span class="n">all_fit_results</span><span class="p">[</span><span class="n">best_idx</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">do_refined_fit</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;Detectors&quot;</span><span class="p">:</span>
                <span class="n">update_param_values_detector</span><span class="p">(</span><span class="n">hypo_maker</span><span class="p">,</span> <span class="n">best_fit_result</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">update_param_values</span><span class="p">(</span><span class="n">hypo_maker</span><span class="p">,</span> <span class="n">best_fit_result</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="p">)</span>
            <span class="c1"># the params stored in the best fit may come from a grid point where</span>
            <span class="c1"># parameters were fixed, so we free them up again</span>
            <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">originally_free</span><span class="p">:</span>
                <span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">param</span><span class="p">]</span><span class="o">.</span><span class="n">is_fixed</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Refining best fit result...&quot;</span><span class="p">)</span>
            <span class="c1"># definitely don&#39;t want to reset the parameters here, that would defeate</span>
            <span class="c1"># the entire purpose...</span>
            <span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;refined_fit&quot;</span><span class="p">][</span><span class="s2">&quot;reset_free&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">best_fit_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_recursively</span><span class="p">(</span>
                <span class="n">data_dist</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">external_priors_penalty</span><span class="p">,</span>
                <span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;refined_fit&quot;</span><span class="p">][</span><span class="s2">&quot;method&quot;</span><span class="p">],</span>
                <span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;refined_fit&quot;</span><span class="p">][</span><span class="s2">&quot;method_kwargs&quot;</span><span class="p">],</span>
                <span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;refined_fit&quot;</span><span class="p">][</span><span class="s2">&quot;local_fit_kwargs&quot;</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">best_fit_result</span>

    <span class="k">def</span> <span class="nf">_fit_constrained</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dist</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span>
                         <span class="n">external_priors_penalty</span><span class="p">,</span> <span class="n">method_kwargs</span><span class="p">,</span> <span class="n">local_fit_kwargs</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Run a fit subject to an arbitrary inequality constraint.</span>

<span class="sd">            The constraint is given as a function that must stay positive. The value of</span>
<span class="sd">            this function is scaled by a pre-factor and applied as a penalty to the test</span>
<span class="sd">            statistic, where the initial scaling factor is not too large to avoid</span>
<span class="sd">            minimizer problems. Should the fit converge to a point violating the</span>
<span class="sd">            constraint, the penalty scale is doubled.</span>

<span class="sd">            The constraining function should calculate the distance of the constraint</span>
<span class="sd">            over-stepping in *rescaled* parameter space to make the over-all scale</span>
<span class="sd">            uniform.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="k">assert</span> <span class="s2">&quot;ineq_func&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="c1"># If certain parameters aren&#39;t free, it will be impossible to satisfy the</span>
            <span class="c1"># constraint and we would end up in an infinite loop! If we detect that</span>
            <span class="c1"># these parameters aren&#39;t free, we just pass through the inner fit without</span>
            <span class="c1"># adding a constraining penalty.</span>
            <span class="k">assert</span> <span class="s2">&quot;necessary_free_params&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;necessary_free_params&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span>
                <span class="nb">set</span><span class="p">(</span><span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="o">.</span><span class="n">names</span><span class="p">)):</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Necessary parameters to satisfy the constraints aren&#39;t &quot;</span>
                             <span class="s2">&quot;free, running inner fit without constraint...&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_recursively</span><span class="p">(</span>
                    <span class="n">data_dist</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">external_priors_penalty</span><span class="p">,</span>
                    <span class="n">local_fit_kwargs</span><span class="p">[</span><span class="s2">&quot;method&quot;</span><span class="p">],</span> <span class="n">local_fit_kwargs</span><span class="p">[</span><span class="s2">&quot;method_kwargs&quot;</span><span class="p">],</span>
                    <span class="n">local_fit_kwargs</span><span class="p">[</span><span class="s2">&quot;local_fit_kwargs&quot;</span><span class="p">]</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="s2">&quot;starting_values&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span>
                        <span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;starting_values&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;necessary_free_params&quot;</span><span class="p">]))</span>

            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;entering constrained fit...&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;ineq_func&quot;</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Using eval() is potentially dangerous as it can execute &quot;</span>
                    <span class="s2">&quot;arbitrary code! Do not store your config file in a place&quot;</span>
                    <span class="s2">&quot;where others have writing access!&quot;</span>
                <span class="p">)</span>
                <span class="n">ineq_func</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;ineq_func&quot;</span><span class="p">])</span>
                <span class="k">assert</span> <span class="nb">callable</span><span class="p">(</span><span class="n">ineq_func</span><span class="p">),</span> <span class="s2">&quot;evaluated object is not a valid function&quot;</span>
            <span class="k">elif</span> <span class="nb">callable</span><span class="p">(</span><span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;ineq_func&quot;</span><span class="p">]):</span>
                <span class="n">ineq_func</span> <span class="o">=</span> <span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;ineq_func&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Inequality function is neither a callable nor a &quot;</span>
                                 <span class="s2">&quot;string that can be evaluated to a callable.&quot;</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">constraint_func</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">ineq_func</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
                <span class="c1"># inequality function must stay positive, so there is no penalty if</span>
                <span class="c1"># it is positive, but otherwise we want to return a *positive* penalty</span>
                <span class="k">return</span> <span class="mf">0.</span> <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="mf">0.</span> <span class="k">else</span> <span class="o">-</span><span class="n">value</span>

            <span class="n">penalty</span> <span class="o">=</span> <span class="mf">1000.</span>
            <span class="k">if</span> <span class="s2">&quot;minimum_penalty&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">penalty</span> <span class="o">=</span> <span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;minimum_penalty&quot;</span><span class="p">]</span>
            <span class="n">tol</span> <span class="o">=</span> <span class="mf">1e-4</span>
            <span class="k">if</span> <span class="s2">&quot;constraint_tol&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">tol</span> <span class="o">=</span> <span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;constraint_tol&quot;</span><span class="p">]</span>
            <span class="n">penalty_sign</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">is_metric_to_maximize</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span> <span class="k">else</span> <span class="mi">1</span>
            <span class="c1"># It would be very inefficient to reset all free values each time when</span>
            <span class="c1"># the penalty is doubled. However, we might still want to reset just once</span>
            <span class="c1"># at the beginning of the constrained fit. We could still, if we wanted</span>
            <span class="c1"># to, reset in the inner loop via the local_fit_kwargs.</span>
            <span class="n">reset_free</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="s2">&quot;reset_free&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">reset_free</span> <span class="o">=</span> <span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;reset_free&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">reset_free</span><span class="p">:</span>
                <span class="n">hypo_maker</span><span class="o">.</span><span class="n">reset_free</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">external_priors_penalty</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">penalty_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">metric</span><span class="p">:</span> <span class="p">(</span>
                    <span class="n">penalty_sign</span> <span class="o">*</span> <span class="n">penalty</span> <span class="o">*</span> <span class="n">constraint_func</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">penalty_func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">metric</span><span class="p">:</span> <span class="p">(</span>
                    <span class="n">penalty_sign</span> <span class="o">*</span> <span class="n">penalty</span> <span class="o">*</span> <span class="n">constraint_func</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
                    <span class="o">+</span> <span class="n">external_priors_penalty</span><span class="p">(</span><span class="n">hypo_maker</span><span class="o">=</span><span class="n">hypo_maker</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="c1"># emulating do-while loop</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;starting_values&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">param</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;starting_values&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="k">for</span> <span class="n">pipeline</span> <span class="ow">in</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">pipelines</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                                <span class="n">pipeline</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">param</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
                <span class="n">fit_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_recursively</span><span class="p">(</span>
                    <span class="n">data_dist</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">penalty_func</span><span class="p">,</span>
                    <span class="n">local_fit_kwargs</span><span class="p">[</span><span class="s2">&quot;method&quot;</span><span class="p">],</span> <span class="n">local_fit_kwargs</span><span class="p">[</span><span class="s2">&quot;method_kwargs&quot;</span><span class="p">],</span>
                    <span class="n">local_fit_kwargs</span><span class="p">[</span><span class="s2">&quot;local_fit_kwargs&quot;</span><span class="p">]</span>
                <span class="p">)</span>
                <span class="n">penalty</span> <span class="o">*=</span> <span class="mi">2</span>
                <span class="k">if</span> <span class="n">constraint_func</span><span class="p">(</span><span class="n">fit_result</span><span class="o">.</span><span class="n">params</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">tol</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">blindness</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Fit result violates constraint condition, re-running &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;with new penalty multiplier: </span><span class="si">{</span><span class="n">penalty</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">fit_result</span>

    <span class="k">def</span> <span class="nf">_fit_ranges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dist</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span>
                    <span class="n">external_priors_penalty</span><span class="p">,</span> <span class="n">method_kwargs</span><span class="p">,</span> <span class="n">local_fit_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fit given ranges of a parameter separately.&quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="s2">&quot;param_name&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">assert</span> <span class="s2">&quot;ranges&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;param_name&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;parameter </span><span class="si">{</span><span class="n">method_kwargs</span><span class="p">[</span><span class="s1">&#39;param_name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> not free, &quot;</span>
                          <span class="s2">&quot;skipping fit over ranges...&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_recursively</span><span class="p">(</span>
                <span class="n">data_dist</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">external_priors_penalty</span><span class="p">,</span>
                <span class="n">local_fit_kwargs</span><span class="p">[</span><span class="s2">&quot;method&quot;</span><span class="p">],</span> <span class="n">local_fit_kwargs</span><span class="p">[</span><span class="s2">&quot;method_kwargs&quot;</span><span class="p">],</span>
                <span class="n">local_fit_kwargs</span><span class="p">[</span><span class="s2">&quot;local_fit_kwargs&quot;</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;entering fit over separate ranges in </span><span class="si">{</span><span class="n">method_kwargs</span><span class="p">[</span><span class="s1">&#39;param_name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">reset_free</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="s2">&quot;reset_free&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">reset_free</span> <span class="o">=</span> <span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;reset_free&quot;</span><span class="p">]</span>

        <span class="c1"># Store a copy of the original parameter such that we can reset the ranges</span>
        <span class="c1"># and nominal values after the fit is done.</span>
        <span class="n">original_param</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;param_name&quot;</span><span class="p">]])</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">blindness</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;original parameter:</span><span class="se">\n</span><span class="si">{</span><span class="n">original_param</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># this is the param we play around with (NOT same object in memory)</span>
        <span class="n">mod_param</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">original_param</span><span class="p">)</span>
        <span class="c1"># The way this works is that we change the range and the set the rescaled</span>
        <span class="c1"># value of the parameter to the same number it originally had. This means</span>
        <span class="c1"># that, if the parameter was originally set at the lower end of the original</span>
        <span class="c1"># range, it will now always start at the lower end of each interval to be</span>
        <span class="c1"># fit separately. If it was in the middle, it will start in the middle of</span>
        <span class="c1"># each interval.</span>
        <span class="n">original_rescaled_value</span> <span class="o">=</span> <span class="n">original_param</span><span class="o">.</span><span class="n">_rescaled_value</span>
        <span class="n">all_fit_results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">interval</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;ranges&quot;</span><span class="p">]):</span>
            <span class="n">mod_param</span><span class="o">.</span><span class="n">range</span> <span class="o">=</span> <span class="n">interval</span>
            <span class="n">mod_param</span><span class="o">.</span><span class="n">_rescaled_value</span> <span class="o">=</span> <span class="n">original_rescaled_value</span>
            <span class="c1"># to make sure that a `reset_free` command will not try to reset the</span>
            <span class="c1"># parameter to a place outside of the modified range we also set the</span>
            <span class="c1"># nominal value</span>
            <span class="n">mod_param</span><span class="o">.</span><span class="n">nominal_value</span> <span class="o">=</span> <span class="n">mod_param</span><span class="o">.</span><span class="n">value</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;now fitting on interval </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">method_kwargs</span><span class="p">[</span><span class="s1">&#39;ranges&#39;</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">blindness</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;parameter with modified range:</span><span class="se">\n</span><span class="si">{</span><span class="n">mod_param</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="c1"># use update_param_values instead of hypo_maker.update_params so that we</span>
            <span class="c1"># don&#39;t overwrite the internal memory reference</span>
            <span class="k">if</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;Detectors&quot;</span><span class="p">:</span>
                <span class="n">update_param_values_detector</span><span class="p">(</span>
                    <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">mod_param</span><span class="p">,</span> <span class="n">update_range</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">update_nominal_values</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">update_param_values</span><span class="p">(</span>
                    <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">mod_param</span><span class="p">,</span> <span class="n">update_range</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">update_nominal_values</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
            <span class="n">fit_result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_recursively</span><span class="p">(</span>
                <span class="n">data_dist</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">external_priors_penalty</span><span class="p">,</span>
                <span class="n">local_fit_kwargs</span><span class="p">[</span><span class="s2">&quot;method&quot;</span><span class="p">],</span> <span class="n">local_fit_kwargs</span><span class="p">[</span><span class="s2">&quot;method_kwargs&quot;</span><span class="p">],</span>
                <span class="n">local_fit_kwargs</span><span class="p">[</span><span class="s2">&quot;local_fit_kwargs&quot;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">all_fit_results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit_result</span><span class="p">)</span>

        <span class="n">all_fit_metric_vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">fit_info</span><span class="o">.</span><span class="n">metric_val</span> <span class="k">for</span> <span class="n">fit_info</span> <span class="ow">in</span> <span class="n">all_fit_results</span><span class="p">]</span>
        <span class="c1"># Take the one with the best fit</span>
        <span class="k">if</span> <span class="n">is_metric_to_maximize</span><span class="p">(</span><span class="n">metric</span><span class="p">):</span>
            <span class="n">best_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">all_fit_metric_vals</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">best_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">all_fit_metric_vals</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">blindness</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found best fit being in interval </span><span class="si">{</span><span class="n">best_idx</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2"> with metric &quot;</span>
                         <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">all_fit_metric_vals</span><span class="p">[</span><span class="n">best_idx</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">best_fit_result</span> <span class="o">=</span> <span class="n">all_fit_results</span><span class="p">[</span><span class="n">best_idx</span><span class="p">]</span>
        <span class="c1"># resetting the range of the parameter we played with</span>
        <span class="c1"># This is one rare instance where we manipulate the parameters of a fit result.</span>
        <span class="n">best_fit_result</span><span class="o">.</span><span class="n">_params</span><span class="p">[</span><span class="n">original_param</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">range</span> <span class="o">=</span> <span class="n">original_param</span><span class="o">.</span><span class="n">range</span>
        <span class="n">best_fit_result</span><span class="o">.</span><span class="n">_params</span><span class="p">[</span><span class="n">original_param</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">nominal_value</span> <span class="o">=</span> <span class="n">original_param</span><span class="o">.</span><span class="n">nominal_value</span>
        <span class="n">best_fit_result</span><span class="o">.</span><span class="n">_rehash</span><span class="p">()</span>
        <span class="c1"># set the values of all parameters in the hypo_maker to the best fit values</span>
        <span class="c1"># without overwriting the memory reference.</span>
        <span class="c1"># Also reset ranges and nominal values that we might have changed above!</span>
        <span class="k">if</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;Detectors&quot;</span><span class="p">:</span>
            <span class="n">update_param_values_detector</span><span class="p">(</span>
                <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">best_fit_result</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="p">,</span>
                <span class="n">update_range</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">update_nominal_values</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">update_param_values</span><span class="p">(</span>
                <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">best_fit_result</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="p">,</span>
                <span class="n">update_range</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">update_nominal_values</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">best_fit_result</span>

    <span class="k">def</span> <span class="nf">_fit_staged</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dist</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span>
                    <span class="n">external_priors_penalty</span><span class="p">,</span> <span class="n">method_kwargs</span><span class="p">,</span> <span class="n">local_fit_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Run a staged fit of one or more sub-fits where later fits start where the</span>
<span class="sd">        earlier fits finished.</span>

<span class="sd">        The subsidiary fits are passed as a list of dicts to `local_fit_kwargs` and</span>
<span class="sd">        are worked on in order of the list. Internally, the `nominal_values` of the</span>
<span class="sd">        parameters are set to the best fit values of the previous fit, such that</span>
<span class="sd">        calls to `reset_free` do not destroy the progress of previous stages.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">local_fit_kwargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">local_fit_kwargs</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">local_fit_kwargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Starting staged fit...&quot;</span><span class="p">)</span>
        <span class="n">best_fit_params</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">best_fit_info</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># storing original nominal values</span>
        <span class="n">original_nominal_values</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="p">[(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">nominal_value</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">fit_kwargs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">local_fit_kwargs</span><span class="p">):</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Beginning fit </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2"> / </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">local_fit_kwargs</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">best_fit_params</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;Detectors&quot;</span><span class="p">:</span>
                    <span class="n">update_param_values_detector</span><span class="p">(</span>
                        <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">best_fit_params</span><span class="o">.</span><span class="n">free</span><span class="p">,</span> <span class="n">update_nominal_values</span><span class="o">=</span><span class="kc">True</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">update_param_values</span><span class="p">(</span>
                        <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">best_fit_params</span><span class="o">.</span><span class="n">free</span><span class="p">,</span> <span class="n">update_nominal_values</span><span class="o">=</span><span class="kc">True</span>
                    <span class="p">)</span>
            <span class="n">best_fit_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_recursively</span><span class="p">(</span>
                <span class="n">data_dist</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">external_priors_penalty</span><span class="p">,</span>
                <span class="n">fit_kwargs</span><span class="p">[</span><span class="s2">&quot;method&quot;</span><span class="p">],</span> <span class="n">fit_kwargs</span><span class="p">[</span><span class="s2">&quot;method_kwargs&quot;</span><span class="p">],</span>
                <span class="n">fit_kwargs</span><span class="p">[</span><span class="s2">&quot;local_fit_kwargs&quot;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">best_fit_params</span> <span class="o">=</span> <span class="n">best_fit_info</span><span class="o">.</span><span class="n">params</span>  <span class="c1"># makes a deepcopy anyway</span>
            <span class="c1"># We set the nominal values to the best fit values, so that a `reset_free`</span>
            <span class="c1"># call does not destroy the progress of the previous fit.</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">best_fit_params</span><span class="o">.</span><span class="n">free</span><span class="p">:</span>
                <span class="n">p</span><span class="o">.</span><span class="n">nominal_value</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">value</span>
        <span class="c1"># reset the nominal values to their original values as if nothing happened</span>
        <span class="c1"># note that we manipulate the internal `_params` object directly, circumventing</span>
        <span class="c1"># the getter method!</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">best_fit_info</span><span class="o">.</span><span class="n">_params</span><span class="o">.</span><span class="n">free</span><span class="p">:</span>
            <span class="n">p</span><span class="o">.</span><span class="n">nominal_value</span> <span class="o">=</span> <span class="n">original_nominal_values</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
        <span class="c1"># Because we directly manipulated the internal parameters, we need to update</span>
        <span class="c1"># the hash.</span>
        <span class="n">best_fit_info</span><span class="o">.</span><span class="n">_rehash</span><span class="p">()</span>
        <span class="c1"># Make sure that the hypo_maker has its params also at the best fit point</span>
        <span class="c1"># with the original nominal parameter values.</span>
        <span class="k">if</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;Detectors&quot;</span><span class="p">:</span>
            <span class="n">update_param_values_detector</span><span class="p">(</span>
                <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">best_fit_info</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="p">,</span> <span class="n">update_nominal_values</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">update_param_values</span><span class="p">(</span>
                <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">best_fit_info</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="p">,</span> <span class="n">update_nominal_values</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">best_fit_info</span>

    <span class="k">def</span> <span class="nf">_fit_scipy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dist</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span>
                   <span class="n">external_priors_penalty</span><span class="p">,</span> <span class="n">method_kwargs</span><span class="p">,</span> <span class="n">local_fit_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Run an arbitrary scipy minimizer to modify hypo dist maker&#39;s free params</span>
<span class="sd">        until the data_dist is most likely to have come from this hypothesis.</span>

<span class="sd">        This function uses only local optimization and does not attempt to find</span>
<span class="sd">        a global optimum among several local optima.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data_dist : MapSet or List of MapSets</span>
<span class="sd">            Data distribution(s)</span>

<span class="sd">        hypo_maker : Detectors, DistributionMaker or convertible thereto</span>

<span class="sd">        metric : string or iterable of strings</span>

<span class="sd">        minimizer_settings : dict</span>

<span class="sd">        external_priors_penalty : func</span>
<span class="sd">            User defined prior penalty function</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fit_info : HypoFitResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">global_scipy_methods</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;differential_evolution&quot;</span><span class="p">,</span> <span class="s2">&quot;basinhopping&quot;</span><span class="p">,</span>
                                <span class="s2">&quot;dual_annealing&quot;</span><span class="p">,</span> <span class="s2">&quot;shgo&quot;</span><span class="p">]</span>
        <span class="n">methods_using_local_fits</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;basinhopping&quot;</span><span class="p">,</span> <span class="s2">&quot;dual_annealing&quot;</span><span class="p">,</span> <span class="s2">&quot;shgo&quot;</span><span class="p">]</span>

        <span class="n">global_method</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s2">&quot;global_method&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">global_method</span> <span class="o">=</span> <span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;global_method&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">local_fit_kwargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">global_method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">methods_using_local_fits</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;local_fit_kwargs are ignored by global method </span><span class="si">{</span><span class="n">global_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">global_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;entering local scipy fit using </span><span class="si">{</span><span class="n">method_kwargs</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">global_method</span> <span class="ow">in</span> <span class="n">global_scipy_methods</span><span class="p">,</span> <span class="s2">&quot;unsupported global fit method&quot;</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;entering global scipy fit using </span><span class="si">{</span><span class="n">global_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">blindness</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;free parameters:&quot;</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">global_method</span> <span class="ow">in</span> <span class="n">methods_using_local_fits</span><span class="p">:</span>
            <span class="n">minimizer_settings</span> <span class="o">=</span> <span class="n">set_minimizer_defaults</span><span class="p">(</span><span class="n">local_fit_kwargs</span><span class="p">)</span>
            <span class="n">validate_minimizer_settings</span><span class="p">(</span><span class="n">minimizer_settings</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">global_method</span> <span class="o">==</span> <span class="s2">&quot;differential_evolution&quot;</span><span class="p">:</span>
            <span class="c1"># Unfortunately we are not allowed to pass these, DE with polish=True always</span>
            <span class="c1"># uses L-BFGS-B with default settings.</span>
            <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;polish&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;options&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="ow">and</span> <span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;options&quot;</span><span class="p">][</span><span class="s2">&quot;polish&quot;</span><span class="p">]):</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Differential Evolution result will be polished using L-BFGS-B&quot;</span><span class="p">)</span>
                <span class="c1"># We need to put the method here so that the bounds will be adjusted</span>
                <span class="c1"># below, otherwise the polishing fit can cause crashes if it hits the</span>
                <span class="c1"># bounds.</span>
                <span class="n">minimizer_settings</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="s2">&quot;L-BFGS-B&quot;</span><span class="p">},</span>
                    <span class="s2">&quot;options&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;eps&quot;</span><span class="p">:</span> <span class="mf">1e-8</span><span class="p">}}</span>
                <span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># We put this here such that the checks farther down don&#39;t crash</span>
                <span class="n">minimizer_settings</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="s2">&quot;None&quot;</span><span class="p">}}</span>
        <span class="k">elif</span> <span class="n">global_method</span> <span class="o">==</span> <span class="s2">&quot;dual_annealing&quot;</span><span class="p">:</span>
            <span class="n">minimizer_settings</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="s2">&quot;L-BFGS-B&quot;</span><span class="p">},</span>
                <span class="s2">&quot;options&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;eps&quot;</span><span class="p">:</span> <span class="mf">1e-8</span><span class="p">}}</span>
            <span class="p">}</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Due to a scipy bug, local minimization can only use default&quot;</span>
                         <span class="s2">&quot;L-BFGS-B settings. The given settings are ignored.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">minimizer_settings</span> <span class="o">=</span> <span class="n">set_minimizer_defaults</span><span class="p">(</span><span class="n">method_kwargs</span><span class="p">)</span>
            <span class="n">validate_minimizer_settings</span><span class="p">(</span><span class="n">minimizer_settings</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">metric</span> <span class="o">=</span> <span class="p">[</span><span class="n">metric</span><span class="p">]</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">metric</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">METRICS_TO_MAXIMIZE</span> <span class="ow">and</span> <span class="n">sign</span> <span class="o">!=</span> <span class="o">+</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">elif</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">METRICS_TO_MINIMIZE</span> <span class="ow">and</span> <span class="n">sign</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="o">+</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Defined metrics are not compatible&quot;</span><span class="p">)</span>
        <span class="c1"># Get starting free parameter values</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="o">.</span><span class="n">_rescaled_values</span><span class="p">)</span> <span class="c1"># pylint: disable=protected-access</span>

        <span class="c1"># Indicate indices where x0 should be reflected around the mid-point at 0.5.</span>
        <span class="c1"># This is only used for the COBYLA minimizer.</span>
        <span class="n">flip_x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="n">minimizer_method</span> <span class="o">=</span> <span class="n">minimizer_settings</span><span class="p">[</span><span class="s2">&quot;method&quot;</span><span class="p">][</span><span class="s2">&quot;value&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">cons</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">if</span> <span class="n">minimizer_method</span> <span class="ow">in</span> <span class="n">MINIMIZERS_USING_CONSTRAINTS</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s1">&#39;Minimizer </span><span class="si">%s</span><span class="s1"> requires bounds to be formulated in terms of constraints.&#39;</span>
                <span class="s1">&#39; Constraining functions are auto-generated now.&#39;</span><span class="p">,</span>
                <span class="n">minimizer_method</span>
            <span class="p">)</span>
            <span class="n">cons</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x0</span><span class="p">)):</span>
                <span class="n">l</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;ineq&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="n">idx</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">FTYPE_PREC</span><span class="p">}</span>  <span class="c1"># lower bound at zero</span>
                <span class="n">u</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;ineq&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="o">=</span><span class="n">idx</span><span class="p">:</span> <span class="mf">1.</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]}</span>  <span class="c1"># upper bound at 1</span>
                <span class="n">cons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
                <span class="n">cons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
            <span class="c1"># The minimizer begins with a step of size `rhobeg` in the positive</span>
            <span class="c1"># direction. Flipping around 0.5 ensures that this initial step will not</span>
            <span class="c1"># overstep boundaries if `rhobeg` is 0.5.</span>
            <span class="n">flip_x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.5</span>
            <span class="c1"># The minimizer can&#39;t handle bounds, but they still need to be passed for</span>
            <span class="c1"># the interface to be uniform even though they are not used.</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>

        <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">flip_x0</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">global_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Running the </span><span class="si">%s</span><span class="s1"> minimizer...&#39;</span><span class="p">,</span> <span class="n">minimizer_method</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Running the </span><span class="si">{</span><span class="n">global_method</span><span class="si">}</span><span class="s2"> global fit method...&quot;</span><span class="p">)</span>
        <span class="c1"># Using scipy.optimize.minimize allows a whole host of minimizers to be</span>
        <span class="c1"># used.</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>

        <span class="n">fit_history</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fit_history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="p">])</span>

        <span class="n">start_t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pprint</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">blindness</span><span class="p">:</span>
            <span class="n">free_p</span> <span class="o">=</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pprint_header</span><span class="p">(</span><span class="n">free_p</span><span class="p">,</span> <span class="n">external_priors_penalty</span><span class="p">,</span> <span class="n">metric</span><span class="p">)</span>

        <span class="c1"># reset number of iterations before each minimization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nit</span> <span class="o">=</span> <span class="mi">0</span>


        <span class="c1"># Before starting minimization, check if we already have a perfect match between data and template</span>
        <span class="c1"># This can happen if using pseudodata that was generated with the nominal values for parameters</span>
        <span class="c1"># (which will also be the initial values in the fit) and blah...</span>
        <span class="c1"># If this is the case, don&#39;t both to fit and return results right away. </span>

        <span class="c1"># Grab the hypo map</span>
        <span class="n">hypo_asimov_dist</span> <span class="o">=</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">get_outputs</span><span class="p">(</span><span class="n">return_sum</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="c1"># Check if the hypo matches data</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="kc">False</span> 
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data_dist</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">matches</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span> <span class="n">entry</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">hypo_asimov_dist</span><span class="p">[</span><span class="n">ie</span><span class="p">])</span> <span class="k">for</span> <span class="n">ie</span><span class="p">,</span> <span class="n">entry</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data_dist</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">matches</span> <span class="o">=</span> <span class="n">data_dist</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">hypo_asimov_dist</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">matches</span><span class="p">:</span>

            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Initial hypo matches data, no need for fit&#39;</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="c1"># Get the metric value at this initial point (for the returned data)</span>
            <span class="n">initial_metric_val</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">data_dist</span><span class="o">.</span><span class="n">metric_total</span><span class="p">(</span><span class="n">expected_values</span><span class="o">=</span><span class="n">hypo_asimov_dist</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="o">+</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">priors_penalty</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="p">)</span>

            <span class="c1"># Return fit results, even though didn&#39;t technically fit</span>
            <span class="k">return</span> <span class="n">HypoFitResult</span><span class="p">(</span>
                <span class="n">metric</span><span class="p">,</span>
                <span class="n">initial_metric_val</span><span class="p">,</span>
                <span class="n">data_dist</span><span class="p">,</span>
                <span class="n">hypo_maker</span><span class="p">,</span>
                <span class="n">minimizer_time</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span>
                <span class="n">minimizer_metadata</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;success&quot;</span><span class="p">:</span><span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;nit&quot;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;message&quot;</span><span class="p">:</span><span class="n">msg</span><span class="p">},</span> <span class="c1"># Add some metadata in the format returned by `scipy.optimize.minimize`</span>
                <span class="n">fit_history</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">other_metrics</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">num_distributions_generated</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">include_detailed_metric_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>


        <span class="c1">#</span>
        <span class="c1"># From that point on, optimize starts using the metric and</span>
        <span class="c1"># iterates, no matter what you do</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="n">global_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">optimize_result</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span>
                <span class="n">fun</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_minimizer_callable</span><span class="p">,</span>
                <span class="n">x0</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span>
                <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">hypo_maker</span><span class="p">,</span> <span class="n">data_dist</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">counter</span><span class="p">,</span> <span class="n">fit_history</span><span class="p">,</span>
                      <span class="n">flip_x0</span><span class="p">,</span> <span class="n">external_priors_penalty</span><span class="p">),</span>
                <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
                <span class="n">constraints</span><span class="o">=</span><span class="n">cons</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="n">minimizer_settings</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">],</span>
                <span class="n">options</span><span class="o">=</span><span class="n">minimizer_settings</span><span class="p">[</span><span class="s1">&#39;options&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">],</span>
                <span class="n">callback</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_minimizer_callback</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">global_method</span> <span class="o">==</span> <span class="s2">&quot;differential_evolution&quot;</span><span class="p">:</span>
            <span class="n">optimize_result</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">differential_evolution</span><span class="p">(</span>
                <span class="n">func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_minimizer_callable</span><span class="p">,</span>
                <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
                <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">hypo_maker</span><span class="p">,</span> <span class="n">data_dist</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">counter</span><span class="p">,</span> <span class="n">fit_history</span><span class="p">,</span>
                      <span class="n">flip_x0</span><span class="p">,</span> <span class="n">external_priors_penalty</span><span class="p">),</span>
                <span class="n">callback</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_minimizer_callback</span><span class="p">,</span>
                <span class="o">**</span><span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;options&quot;</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">global_method</span> <span class="o">==</span> <span class="s2">&quot;basinhopping&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;seed&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;options&quot;</span><span class="p">]:</span>
                <span class="n">seed</span> <span class="o">=</span> <span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;options&quot;</span><span class="p">][</span><span class="s2">&quot;seed&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">seed</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="n">check_random_state</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

            <span class="k">if</span> <span class="s2">&quot;step_size&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;options&quot;</span><span class="p">]:</span>
                <span class="n">step_size</span> <span class="o">=</span> <span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;options&quot;</span><span class="p">][</span><span class="s2">&quot;step_size&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">step_size</span> <span class="o">=</span> <span class="mf">0.5</span>

            <span class="n">take_step</span> <span class="o">=</span> <span class="n">BoundedRandomDisplacement</span><span class="p">(</span><span class="n">step_size</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">rng</span><span class="p">)</span>
            <span class="n">minimizer_kwargs</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">local_fit_kwargs</span><span class="p">)</span>
            <span class="n">minimizer_kwargs</span><span class="p">[</span><span class="s2">&quot;args&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">data_dist</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">counter</span><span class="p">,</span> <span class="n">fit_history</span><span class="p">,</span>
                <span class="n">flip_x0</span><span class="p">,</span> <span class="n">external_priors_penalty</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;reset_free&quot;</span> <span class="ow">in</span> <span class="n">minimizer_kwargs</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">minimizer_kwargs</span><span class="p">[</span><span class="s2">&quot;reset_free&quot;</span><span class="p">]</span>
            <span class="n">minimizer_kwargs</span><span class="p">[</span><span class="s2">&quot;method&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_fit_kwargs</span><span class="p">[</span><span class="s2">&quot;method&quot;</span><span class="p">][</span><span class="s2">&quot;value&quot;</span><span class="p">]</span>
            <span class="n">minimizer_kwargs</span><span class="p">[</span><span class="s2">&quot;options&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_fit_kwargs</span><span class="p">[</span><span class="s2">&quot;options&quot;</span><span class="p">][</span><span class="s2">&quot;value&quot;</span><span class="p">]</span>
            <span class="n">minimizer_kwargs</span><span class="p">[</span><span class="s2">&quot;bounds&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bounds</span>
            <span class="k">def</span> <span class="nf">basinhopping_callback</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">accept</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_nit</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">optimize_result</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">basinhopping</span><span class="p">(</span>
                <span class="n">func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_minimizer_callable</span><span class="p">,</span>
                <span class="n">x0</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span>
                <span class="n">take_step</span><span class="o">=</span><span class="n">take_step</span><span class="p">,</span>
                <span class="n">callback</span><span class="o">=</span><span class="n">basinhopping_callback</span><span class="p">,</span>
                <span class="n">minimizer_kwargs</span><span class="o">=</span><span class="n">minimizer_kwargs</span><span class="p">,</span>
                <span class="o">**</span><span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;options&quot;</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">optimize_result</span><span class="o">.</span><span class="n">success</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># basinhopping doesn&#39;t set this property</span>
        <span class="k">elif</span> <span class="n">global_method</span> <span class="o">==</span> <span class="s2">&quot;dual_annealing&quot;</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">annealing_callback</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_nit</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># TODO: Enable use of custom minimization if scipy is fixed</span>
            <span class="c1"># The scipy implementation is buggy insofar as it doesn&#39;t apply bounds to</span>
            <span class="c1"># the inner minimization and there is no way to pass bounds through that</span>
            <span class="c1"># doesn&#39;t crash. This leads to evaluations outside of the bounds.</span>
            <span class="n">optimize_result</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">dual_annealing</span><span class="p">(</span>
                <span class="n">func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_minimizer_callable</span><span class="p">,</span>
                <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
                <span class="n">x0</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span>
                <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">hypo_maker</span><span class="p">,</span> <span class="n">data_dist</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">counter</span><span class="p">,</span> <span class="n">fit_history</span><span class="p">,</span>
                      <span class="n">flip_x0</span><span class="p">,</span> <span class="n">external_priors_penalty</span><span class="p">),</span>
                <span class="n">callback</span><span class="o">=</span><span class="n">annealing_callback</span><span class="p">,</span>
                <span class="o">**</span><span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;options&quot;</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">global_method</span> <span class="o">==</span> <span class="s2">&quot;shgo&quot;</span><span class="p">:</span>
            <span class="n">minimizer_kwargs</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">local_fit_kwargs</span><span class="p">)</span>
            <span class="n">minimizer_kwargs</span><span class="p">[</span><span class="s2">&quot;args&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">data_dist</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">counter</span><span class="p">,</span> <span class="n">fit_history</span><span class="p">,</span>
                <span class="n">flip_x0</span><span class="p">,</span> <span class="n">external_priors_penalty</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;reset_free&quot;</span> <span class="ow">in</span> <span class="n">minimizer_kwargs</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">minimizer_kwargs</span><span class="p">[</span><span class="s2">&quot;reset_free&quot;</span><span class="p">]</span>
            <span class="n">minimizer_kwargs</span><span class="p">[</span><span class="s2">&quot;method&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_fit_kwargs</span><span class="p">[</span><span class="s2">&quot;method&quot;</span><span class="p">][</span><span class="s2">&quot;value&quot;</span><span class="p">]</span>
            <span class="n">minimizer_kwargs</span><span class="p">[</span><span class="s2">&quot;options&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_fit_kwargs</span><span class="p">[</span><span class="s2">&quot;options&quot;</span><span class="p">][</span><span class="s2">&quot;value&quot;</span><span class="p">]</span>
            <span class="n">optimize_result</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">shgo</span><span class="p">(</span>
                <span class="n">func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_minimizer_callable</span><span class="p">,</span>
                <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
                <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">hypo_maker</span><span class="p">,</span> <span class="n">data_dist</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">counter</span><span class="p">,</span> <span class="n">fit_history</span><span class="p">,</span>
                      <span class="n">flip_x0</span><span class="p">,</span> <span class="n">external_priors_penalty</span><span class="p">),</span>
                <span class="n">callback</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_minimizer_callback</span><span class="p">,</span>
                <span class="n">minimizer_kwargs</span><span class="o">=</span><span class="n">minimizer_kwargs</span><span class="p">,</span>
                <span class="o">**</span><span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;options&quot;</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unsupported global fit method&quot;</span><span class="p">)</span>

        <span class="n">end_t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pprint</span><span class="p">:</span>
            <span class="c1"># clear the line</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

        <span class="n">minimizer_time</span> <span class="o">=</span> <span class="n">end_t</span> <span class="o">-</span> <span class="n">start_t</span>

        <span class="c1"># Check for minimization failure</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">optimize_result</span><span class="o">.</span><span class="n">success</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">blindness</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">optimize_result</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Optimization failed.&#39;</span> <span class="o">+</span> <span class="n">msg</span><span class="p">)</span>
            <span class="c1"># Instead of crashing completely, return a fit result with an infinite</span>
            <span class="c1"># test statistic value.</span>
            <span class="n">metadata</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;success&quot;</span><span class="p">:</span><span class="n">optimize_result</span><span class="o">.</span><span class="n">success</span><span class="p">,</span> <span class="s2">&quot;message&quot;</span><span class="p">:</span><span class="n">optimize_result</span><span class="o">.</span><span class="n">message</span><span class="p">,}</span>
            <span class="k">return</span> <span class="n">HypoFitResult</span><span class="p">(</span>
                <span class="n">metric</span><span class="p">,</span>
                <span class="n">sign</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
                <span class="n">data_dist</span><span class="p">,</span>
                <span class="n">hypo_maker</span><span class="p">,</span>
                <span class="n">minimizer_time</span><span class="o">=</span><span class="n">minimizer_time</span><span class="p">,</span>
                <span class="n">minimizer_metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
                <span class="n">fit_history</span><span class="o">=</span><span class="n">fit_history</span><span class="p">,</span>
                <span class="n">other_metrics</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">num_distributions_generated</span><span class="o">=</span><span class="n">counter</span><span class="o">.</span><span class="n">count</span><span class="p">,</span>
                <span class="n">include_detailed_metric_info</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s1">&#39;Total time to optimize: </span><span class="si">%8.4f</span><span class="s1"> s; # of dists generated: </span><span class="si">%6d</span><span class="s1">;&#39;</span>
            <span class="s1">&#39; avg dist gen time: </span><span class="si">%10.4f</span><span class="s1"> ms&#39;</span><span class="p">,</span>
            <span class="n">minimizer_time</span><span class="p">,</span> <span class="n">counter</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="n">minimizer_time</span><span class="o">*</span><span class="mf">1000.</span><span class="o">/</span><span class="n">counter</span><span class="o">.</span><span class="n">count</span>
        <span class="p">)</span>

        <span class="c1"># Will not assume that the minimizer left the hypo maker in the</span>
        <span class="c1"># minimized state, so set the values now (also does conversion of</span>
        <span class="c1"># values from [0,1] back to physical range)</span>
        <span class="n">rescaled_pvals</span> <span class="o">=</span> <span class="n">optimize_result</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
        <span class="n">rescaled_pvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">flip_x0</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">rescaled_pvals</span><span class="p">,</span> <span class="n">rescaled_pvals</span><span class="p">)</span>
        <span class="n">hypo_maker</span><span class="o">.</span><span class="n">_set_rescaled_free_params</span><span class="p">(</span><span class="n">rescaled_pvals</span><span class="p">)</span> <span class="c1"># pylint: disable=protected-access</span>
        <span class="k">if</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;Detectors&quot;</span><span class="p">:</span>
            <span class="n">update_param_values_detector</span><span class="p">(</span><span class="n">hypo_maker</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="p">)</span> <span class="c1">#updates values for ALL detectors</span>

        <span class="c1"># Get the best-fit metric value</span>
        <span class="n">metric_val</span> <span class="o">=</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">optimize_result</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;fun&#39;</span><span class="p">)</span>

        <span class="c1"># Record minimizer metadata (all info besides &#39;x&#39; and &#39;fun&#39;; also do</span>
        <span class="c1"># not record some attributes if performing blinded analysis)</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">optimize_result</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">blindness</span> <span class="ow">and</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;jac&#39;</span><span class="p">,</span> <span class="s1">&#39;hess&#39;</span><span class="p">,</span> <span class="s1">&#39;hess_inv&#39;</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">k</span><span class="o">==</span><span class="s1">&#39;hess_inv&#39;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">k</span><span class="o">==</span><span class="s2">&quot;message&quot;</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">optimize_result</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="nb">bytes</span><span class="p">):</span>
                <span class="c1"># A little fix for deserialization: After serialization and</span>
                <span class="c1"># deserialization, the string would be decoded anyway and then the</span>
                <span class="c1"># recovered object would look different.</span>
                <span class="n">metadata</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">optimize_result</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="n">metadata</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">optimize_result</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">blindness</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># only at stricter blindness level</span>
            <span class="c1"># undo flip</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">flip_x0</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x0</span><span class="p">)</span>
            <span class="c1"># Reset to starting value of the fit, rather than nominal values because</span>
            <span class="c1"># the nominal value might be out of range if this is inside an octant check.</span>
            <span class="n">hypo_maker</span><span class="o">.</span><span class="n">_set_rescaled_free_params</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;Detectors&quot;</span><span class="p">:</span>
                <span class="n">update_param_values_detector</span><span class="p">(</span><span class="n">hypo_maker</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="p">)</span> <span class="c1">#updates values for ALL detectors</span>

        <span class="c1"># TODO: other metrics</span>
        <span class="n">fit_info</span> <span class="o">=</span> <span class="n">HypoFitResult</span><span class="p">(</span>
            <span class="n">metric</span><span class="p">,</span>
            <span class="n">metric_val</span><span class="p">,</span>
            <span class="n">data_dist</span><span class="p">,</span>
            <span class="n">hypo_maker</span><span class="p">,</span>
            <span class="n">minimizer_time</span><span class="o">=</span><span class="n">minimizer_time</span><span class="p">,</span>
            <span class="n">minimizer_metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
            <span class="n">fit_history</span><span class="o">=</span><span class="n">fit_history</span><span class="p">,</span>
            <span class="n">other_metrics</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">num_distributions_generated</span><span class="o">=</span><span class="n">counter</span><span class="o">.</span><span class="n">count</span><span class="p">,</span>
            <span class="n">include_detailed_metric_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">blindness</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;found best fit: </span><span class="si">{</span><span class="n">fit_info</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fit_info</span>

    <span class="k">def</span> <span class="nf">_fit_iminuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dist</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span>
                     <span class="n">external_priors_penalty</span><span class="p">,</span> <span class="n">method_kwargs</span><span class="p">,</span> <span class="n">local_fit_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Run the Minuit minimizer to modify hypo dist maker&#39;s free params</span>
<span class="sd">        until the data_dist is most likely to have come from this hypothesis.</span>

<span class="sd">        This function uses only local optimization and does not attempt to find</span>
<span class="sd">        a global optimum among several local optima.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data_dist : MapSet or List of MapSets</span>
<span class="sd">            Data distribution(s)</span>

<span class="sd">        hypo_maker : Detectors, DistributionMaker or convertible thereto</span>

<span class="sd">        metric : string or iterable of strings</span>

<span class="sd">        external_priors_penalty : func</span>
<span class="sd">            User defined prior penalty function</span>

<span class="sd">        method_kwargs : dict</span>
<span class="sd">            Options passed on for Minuit</span>

<span class="sd">        local_fit_kwargs : dict</span>
<span class="sd">            Ignored since no local fit happens inside this fit</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fit_info : HypoFitResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Entering local fit using Minuit&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">local_fit_kwargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Local fit kwargs are ignored by &#39;fit_minuit&#39;.&quot;</span>
                         <span class="s2">&quot;Use &#39;method_kwargs&#39; to set Minuit options.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">method_kwargs</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># use all defaults</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">blindness</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;free parameters:&quot;</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">metric</span> <span class="o">=</span> <span class="p">[</span><span class="n">metric</span><span class="p">]</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">metric</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">METRICS_TO_MAXIMIZE</span> <span class="ow">and</span> <span class="n">sign</span> <span class="o">!=</span> <span class="o">+</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">elif</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">METRICS_TO_MINIMIZE</span> <span class="ow">and</span> <span class="n">sign</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="o">+</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Defined metrics are not compatible&quot;</span><span class="p">)</span>
        <span class="c1"># Get starting free parameter values</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="o">.</span><span class="n">_rescaled_values</span><span class="p">)</span> <span class="c1"># pylint: disable=protected-access</span>

        <span class="n">bounds</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>

        <span class="n">counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>

        <span class="n">fit_history</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fit_history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="p">])</span>

        <span class="n">start_t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pprint</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">blindness</span><span class="p">:</span>
            <span class="n">free_p</span> <span class="o">=</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pprint_header</span><span class="p">(</span><span class="n">free_p</span><span class="p">,</span> <span class="n">external_priors_penalty</span><span class="p">,</span> <span class="n">metric</span><span class="p">)</span>

        <span class="c1"># reset number of iterations before each minimization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nit</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># we never flip in minuit, but we still need to set it</span>
        <span class="n">flip_x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">hypo_maker</span><span class="p">,</span> <span class="n">data_dist</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">counter</span><span class="p">,</span> <span class="n">fit_history</span><span class="p">,</span>
              <span class="n">flip_x0</span><span class="p">,</span> <span class="n">external_priors_penalty</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">loss_func</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="c1"># In rare circumstances, minuit will try setting one of the parameters</span>
            <span class="c1"># to NaN. Minuit might be able to recover when we return NaN.</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Minuit tried evaluating at invalid parameters: </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minimizer_callable</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

        <span class="n">m</span> <span class="o">=</span> <span class="n">Minuit</span><span class="p">(</span><span class="n">loss_func</span><span class="p">,</span> <span class="n">x0</span><span class="p">)</span>
        <span class="n">m</span><span class="o">.</span><span class="n">limits</span> <span class="o">=</span> <span class="n">bounds</span>
        <span class="c1"># only initial step size, not very important</span>
        <span class="k">if</span> <span class="s2">&quot;errors&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">m</span><span class="o">.</span><span class="n">errors</span> <span class="o">=</span> <span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;errors&quot;</span><span class="p">]</span>
        <span class="c1"># Precision with which the likelihood is calculated</span>
        <span class="k">if</span> <span class="s2">&quot;precision&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">m</span><span class="o">.</span><span class="n">precision</span> <span class="o">=</span> <span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;precision&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Documentation states that this value should be set to &quot;some multiple of</span>
            <span class="c1"># the smallest relative change of a parameter that still changes the</span>
            <span class="c1"># function&quot;.</span>
            <span class="n">m</span><span class="o">.</span><span class="n">precision</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">FTYPE_PREC</span>
        <span class="k">if</span> <span class="s2">&quot;tol&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">m</span><span class="o">.</span><span class="n">tol</span> <span class="o">=</span> <span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;tol&quot;</span><span class="p">]</span>
        <span class="n">simplex</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="s2">&quot;run_simplex&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">simplex</span> <span class="o">=</span> <span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;run_simplex&quot;</span><span class="p">]</span>
        <span class="n">migrad</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="s2">&quot;run_migrad&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">migrad</span> <span class="o">=</span> <span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;run_migrad&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">migrad</span> <span class="ow">or</span> <span class="n">simplex</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must select at least one of MIGRAD or SIMPLEX to run&quot;</span><span class="p">)</span>
        <span class="c1"># Minuit needs to know if the loss function is interpretable as a likelihood</span>
        <span class="c1"># or as a least-squares loss. It influences the stopping condition where the</span>
        <span class="c1"># estimated uncertainty on parameters is small compared to their covariance.</span>
        <span class="k">if</span> <span class="n">metric</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">LLH_METRICS</span><span class="p">:</span>
            <span class="n">m</span><span class="o">.</span><span class="n">errordef</span> <span class="o">=</span> <span class="n">Minuit</span><span class="o">.</span><span class="n">LIKELIHOOD</span>
        <span class="k">elif</span> <span class="n">metric</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">CHI2_METRICS</span><span class="p">:</span>
            <span class="n">m</span><span class="o">.</span><span class="n">errordef</span> <span class="o">=</span> <span class="n">Minuit</span><span class="o">.</span><span class="n">LEAST_SQUARES</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Metric neither LLH or CHI2, unknown error definition.&quot;</span><span class="p">)</span>
        <span class="c1"># Minuit can sometimes try to evaluate at NaN parameters if the liklihood</span>
        <span class="c1"># is badly behaved. We don&#39;t want to completely crash in that case.</span>
        <span class="n">m</span><span class="o">.</span><span class="n">throw_nan</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># actually run the minimization!</span>
        <span class="k">if</span> <span class="n">simplex</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Running SIMPLEX&quot;</span><span class="p">)</span>
            <span class="n">m</span><span class="o">.</span><span class="n">simplex</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">migrad</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Running MIGRAD&quot;</span><span class="p">)</span>
            <span class="n">m</span><span class="o">.</span><span class="n">migrad</span><span class="p">()</span>

        <span class="n">end_t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pprint</span><span class="p">:</span>
            <span class="c1"># clear the line</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

        <span class="n">minimizer_time</span> <span class="o">=</span> <span class="n">end_t</span> <span class="o">-</span> <span class="n">start_t</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s1">&#39;Total time to optimize: </span><span class="si">%8.4f</span><span class="s1"> s; # of dists generated: </span><span class="si">%6d</span><span class="s1">;&#39;</span>
            <span class="s1">&#39; avg dist gen time: </span><span class="si">%10.4f</span><span class="s1"> ms&#39;</span><span class="p">,</span>
            <span class="n">minimizer_time</span><span class="p">,</span> <span class="n">counter</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="n">minimizer_time</span><span class="o">*</span><span class="mf">1000.</span><span class="o">/</span><span class="n">counter</span><span class="o">.</span><span class="n">count</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="o">.</span><span class="n">accurate</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Covariance matrix invalid.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="o">.</span><span class="n">valid</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Minimum not valid according to Minuit&#39;s criteria.&quot;</span><span class="p">)</span>

        <span class="c1"># Will not assume that the minimizer left the hypo maker in the</span>
        <span class="c1"># minimized state, so set the values now (also does conversion of</span>
        <span class="c1"># values from [0,1] back to physical range)</span>
        <span class="n">rescaled_pvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="n">hypo_maker</span><span class="o">.</span><span class="n">_set_rescaled_free_params</span><span class="p">(</span><span class="n">rescaled_pvals</span><span class="p">)</span> <span class="c1"># pylint: disable=protected-access</span>
        <span class="k">if</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;Detectors&quot;</span><span class="p">:</span>
            <span class="n">update_param_values_detector</span><span class="p">(</span><span class="n">hypo_maker</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="p">)</span> <span class="c1">#updates values for ALL detectors</span>

        <span class="c1"># Get the best-fit metric value</span>
        <span class="n">metric_val</span> <span class="o">=</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">m</span><span class="o">.</span><span class="n">fval</span>

        <span class="c1"># Record minimizer metadata (all info besides &#39;x&#39; and &#39;fun&#39;; also do</span>
        <span class="c1"># not record some attributes if performing blinded analysis)</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="c1"># param names are relevant because they allow one to reconstruct which</span>
        <span class="c1"># parameter corresponds to which entry in the covariance matrix</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;param_names&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="o">.</span><span class="n">names</span>
        <span class="c1"># The criteria to deem a minimum &quot;valid&quot; are too strict for our purposes, so</span>
        <span class="c1"># we accept the value even if m.valid is False.</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;success&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">metric_val</span><span class="p">)</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;valid&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">valid</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;accurate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">accurate</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;edm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">fmin</span><span class="o">.</span><span class="n">edm</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;edm_goal&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">fmin</span><span class="o">.</span><span class="n">edm_goal</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;has_reached_call_limit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">fmin</span><span class="o">.</span><span class="n">has_reached_call_limit</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;has_parameters_at_limit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">fmin</span><span class="o">.</span><span class="n">has_parameters_at_limit</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">nfcn</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;message&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Minuit finished.&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">blindness</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">blindness</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;rescaled_values&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;rescaled_values&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">values</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">accurate</span><span class="p">:</span>
                <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;hess_inv&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">covariance</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;hess_inv&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">x0</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">x0</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">blindness</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># only at stricter blindness level</span>
            <span class="c1"># undo flip</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">flip_x0</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">x0</span><span class="p">,</span> <span class="n">x0</span><span class="p">)</span>
            <span class="c1"># Reset to starting value of the fit, rather than nominal values because</span>
            <span class="c1"># the nominal value might be out of range if this is inside an octant check.</span>
            <span class="n">hypo_maker</span><span class="o">.</span><span class="n">_set_rescaled_free_params</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;Detectors&quot;</span><span class="p">:</span>
                <span class="n">update_param_values_detector</span><span class="p">(</span><span class="n">hypo_maker</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="p">)</span> <span class="c1">#updates values for ALL detectors</span>

        <span class="c1"># TODO: other metrics</span>
        <span class="n">fit_info</span> <span class="o">=</span> <span class="n">HypoFitResult</span><span class="p">(</span>
            <span class="n">metric</span><span class="p">,</span>
            <span class="n">metric_val</span><span class="p">,</span>
            <span class="n">data_dist</span><span class="p">,</span>
            <span class="n">hypo_maker</span><span class="p">,</span>
            <span class="n">minimizer_time</span><span class="o">=</span><span class="n">minimizer_time</span><span class="p">,</span>
            <span class="n">minimizer_metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
            <span class="n">fit_history</span><span class="o">=</span><span class="n">fit_history</span><span class="p">,</span>
            <span class="n">other_metrics</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">num_distributions_generated</span><span class="o">=</span><span class="n">counter</span><span class="o">.</span><span class="n">count</span><span class="p">,</span>
            <span class="n">include_detailed_metric_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">blindness</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;found best fit: </span><span class="si">{</span><span class="n">fit_info</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fit_info</span>

    <span class="k">def</span> <span class="nf">_fit_nlopt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dist</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span>
                   <span class="n">external_priors_penalty</span><span class="p">,</span> <span class="n">method_kwargs</span><span class="p">,</span> <span class="n">local_fit_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Run any of the (gradient-free) NLOPT optimizers to modify hypo dist maker&#39;s</span>
<span class="sd">        free params until the data_dist is most likely to have come from this</span>
<span class="sd">        hypothesis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data_dist : MapSet or List of MapSets</span>
<span class="sd">            Data distribution(s)</span>

<span class="sd">        hypo_maker : Detectors, DistributionMaker or convertible thereto</span>

<span class="sd">        metric : string or iterable of strings</span>

<span class="sd">        external_priors_penalty : func</span>
<span class="sd">            User defined prior penalty function</span>

<span class="sd">        method_kwargs : dict</span>
<span class="sd">            Options passed on for NLOPT</span>

<span class="sd">        local_fit_kwargs : dict</span>
<span class="sd">            Ignored since no local fit happens inside this fit</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fit_info : HypoFitResult</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Entering fit using NLOPT&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">local_fit_kwargs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;`local_fit_kwargs` are ignored by &#39;fit_nlopt&#39;.&quot;</span>
                         <span class="s2">&quot;Use `method_kwargs` to set nlopt options and use &quot;</span>
                         <span class="s2">&quot;`method_kwargs[&#39;local_optimizer&#39;]` to define the settings of &quot;</span>
                         <span class="s2">&quot;a subsidiary NLOPT optimizer.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need to specify at least the algorithm to run.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">blindness</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;free parameters:&quot;</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">metric</span> <span class="o">=</span> <span class="p">[</span><span class="n">metric</span><span class="p">]</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">metric</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">METRICS_TO_MAXIMIZE</span> <span class="ow">and</span> <span class="n">sign</span> <span class="o">!=</span> <span class="o">+</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">elif</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">METRICS_TO_MINIMIZE</span> <span class="ow">and</span> <span class="n">sign</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="o">+</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Defined metrics are not compatible&quot;</span><span class="p">)</span>
        <span class="c1"># Get starting free parameter values</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="o">.</span><span class="n">_rescaled_values</span><span class="p">)</span> <span class="c1"># pylint: disable=protected-access</span>

        <span class="n">counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>

        <span class="n">fit_history</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fit_history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="p">])</span>

        <span class="n">start_t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pprint</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">blindness</span><span class="p">:</span>
            <span class="n">free_p</span> <span class="o">=</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pprint_header</span><span class="p">(</span><span class="n">free_p</span><span class="p">,</span> <span class="n">external_priors_penalty</span><span class="p">,</span> <span class="n">metric</span><span class="p">)</span>

        <span class="c1"># reset number of iterations before each minimization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nit</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># we never flip in nlopt, but we still need to set it</span>
        <span class="n">flip_x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">hypo_maker</span><span class="p">,</span> <span class="n">data_dist</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">counter</span><span class="p">,</span> <span class="n">fit_history</span><span class="p">,</span>
              <span class="n">flip_x0</span><span class="p">,</span> <span class="n">external_priors_penalty</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">loss_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">grad</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;NLOPT tried evaluating at invalid parameters: </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">if</span> <span class="n">grad</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Gradients cannot be calculated, use a gradient-free&quot;</span>
                                   <span class="s2">&quot; optimization routine instead.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minimizer_callable</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

        <span class="n">opt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_define_nlopt_opt</span><span class="p">(</span><span class="n">method_kwargs</span><span class="p">,</span> <span class="n">loss_func</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="p">)</span>

        <span class="c1"># For some stochastic optimization methods such as CRS2, a seed parameter may</span>
        <span class="c1"># be used to make the optimization deterministic. Otherwise, nlopt will use a</span>
        <span class="c1"># random seed based on the current system time.</span>
        <span class="k">if</span> <span class="s2">&quot;seed&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="p">:</span>
            <span class="n">nlopt</span><span class="o">.</span><span class="n">srand</span><span class="p">(</span><span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;seed&quot;</span><span class="p">])</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Starting optimization using </span><span class="si">{</span><span class="n">opt</span><span class="o">.</span><span class="n">get_algorithm_name</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">xopt</span> <span class="o">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">optimize</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>

        <span class="n">end_t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pprint</span><span class="p">:</span>
            <span class="c1"># clear the line</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

        <span class="n">minimizer_time</span> <span class="o">=</span> <span class="n">end_t</span> <span class="o">-</span> <span class="n">start_t</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s1">&#39;Total time to optimize: </span><span class="si">%8.4f</span><span class="s1"> s; # of dists generated: </span><span class="si">%6d</span><span class="s1">;&#39;</span>
            <span class="s1">&#39; avg dist gen time: </span><span class="si">%10.4f</span><span class="s1"> ms&#39;</span><span class="p">,</span>
            <span class="n">minimizer_time</span><span class="p">,</span> <span class="n">counter</span><span class="o">.</span><span class="n">count</span><span class="p">,</span> <span class="n">minimizer_time</span><span class="o">*</span><span class="mf">1000.</span><span class="o">/</span><span class="n">counter</span><span class="o">.</span><span class="n">count</span>
        <span class="p">)</span>

        <span class="c1"># Will not assume that the minimizer left the hypo maker in the</span>
        <span class="c1"># minimized state, so set the values now (also does conversion of</span>
        <span class="c1"># values from [0,1] back to physical range)</span>
        <span class="n">rescaled_pvals</span> <span class="o">=</span> <span class="n">xopt</span>
        <span class="n">hypo_maker</span><span class="o">.</span><span class="n">_set_rescaled_free_params</span><span class="p">(</span><span class="n">rescaled_pvals</span><span class="p">)</span> <span class="c1"># pylint: disable=protected-access</span>
        <span class="k">if</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;Detectors&quot;</span><span class="p">:</span>
            <span class="n">update_param_values_detector</span><span class="p">(</span><span class="n">hypo_maker</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="p">)</span> <span class="c1">#updates values for ALL detectors</span>

        <span class="c1"># Get the best-fit metric value</span>
        <span class="n">metric_val</span> <span class="o">=</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">opt</span><span class="o">.</span><span class="n">last_optimum_value</span><span class="p">()</span>

        <span class="c1"># Record minimizer metadata (all info besides &#39;x&#39; and &#39;fun&#39;; also do</span>
        <span class="c1"># not record some attributes if performing blinded analysis)</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">nlopt_result</span> <span class="o">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">last_optimize_result</span><span class="p">()</span>
        <span class="c1"># Positive return values are successes, negative return values are failures.</span>
        <span class="c1"># see https://nlopt.readthedocs.io/en/latest/NLopt_Reference/#return-values</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;success&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nlopt_result</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nlopt_result&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nlopt_result</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;nit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">get_numevals</span><span class="p">()</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;message&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;NLOPT_SUCCESS&quot;</span><span class="p">,</span>
            <span class="mi">2</span><span class="p">:</span> <span class="s2">&quot;NLOPT_STOPVAL_REACHED&quot;</span><span class="p">,</span>
            <span class="mi">3</span><span class="p">:</span> <span class="s2">&quot;NLOPT_FTOL_REACHED&quot;</span><span class="p">,</span>
            <span class="mi">4</span><span class="p">:</span> <span class="s2">&quot;NLOPT_XTOL_REACHED&quot;</span><span class="p">,</span>
            <span class="mi">5</span><span class="p">:</span> <span class="s2">&quot;NLOPT_MAXEVAL_REACHED&quot;</span><span class="p">,</span>
            <span class="mi">6</span><span class="p">:</span> <span class="s2">&quot;NLOPT_MAXTIME_REACHED&quot;</span><span class="p">,</span>
            <span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;NLOPT_FAILURE&quot;</span><span class="p">,</span>
            <span class="o">-</span><span class="mi">2</span><span class="p">:</span> <span class="s2">&quot;NLOPT_INVALID_ARGS&quot;</span><span class="p">,</span>
            <span class="o">-</span><span class="mi">3</span><span class="p">:</span> <span class="s2">&quot;NLOPT_OUT_OF_MEMORY&quot;</span><span class="p">,</span>
            <span class="o">-</span><span class="mi">4</span><span class="p">:</span> <span class="s2">&quot;NLOPT_ROUNDOFF_LIMITED&quot;</span><span class="p">,</span>
            <span class="o">-</span><span class="mi">5</span><span class="p">:</span> <span class="s2">&quot;NLOPT_FORCED_STOP&quot;</span>
        <span class="p">}[</span><span class="n">nlopt_result</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">blindness</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;rescaled_values&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rescaled_pvals</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;rescaled_values&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">values</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="c1"># we don&#39;t get a Hessian from nlopt</span>
        <span class="n">metadata</span><span class="p">[</span><span class="s2">&quot;hess_inv&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">x0</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">x0</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">blindness</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># only at stricter blindness level</span>
            <span class="n">hypo_maker</span><span class="o">.</span><span class="n">_set_rescaled_free_params</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;Detectors&quot;</span><span class="p">:</span>
                <span class="n">update_param_values_detector</span><span class="p">(</span><span class="n">hypo_maker</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="p">)</span> <span class="c1">#updates values for ALL detectors</span>

        <span class="c1"># TODO: other metrics</span>
        <span class="n">fit_info</span> <span class="o">=</span> <span class="n">HypoFitResult</span><span class="p">(</span>
            <span class="n">metric</span><span class="p">,</span>
            <span class="n">metric_val</span><span class="p">,</span>
            <span class="n">data_dist</span><span class="p">,</span>
            <span class="n">hypo_maker</span><span class="p">,</span>
            <span class="n">minimizer_time</span><span class="o">=</span><span class="n">minimizer_time</span><span class="p">,</span>
            <span class="n">minimizer_metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
            <span class="n">fit_history</span><span class="o">=</span><span class="n">fit_history</span><span class="p">,</span>
            <span class="n">other_metrics</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">num_distributions_generated</span><span class="o">=</span><span class="n">counter</span><span class="o">.</span><span class="n">count</span><span class="p">,</span>
            <span class="n">include_detailed_metric_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">blindness</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;found best fit: </span><span class="si">{</span><span class="n">fit_info</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fit_info</span>

    <span class="k">def</span> <span class="nf">_define_nlopt_opt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method_kwargs</span><span class="p">,</span> <span class="n">loss_func</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper function that reads the options from a dictionary and configures</span>
<span class="sd">        an nlopt.opt object with all the options applied. Some global search algorithms</span>
<span class="sd">        also need a local/subsidiary optimizer. Its options can be specified in</span>
<span class="sd">        `method_kwargs[&#39;local_optimizer&#39;]` as a dictionary of the same form that is</span>
<span class="sd">        passed to this function again to build the nlopt.opt object.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="s2">&quot;algorithm&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need to specify the algorithm to use.&quot;</span><span class="p">)</span>
        <span class="n">alg_name_splits</span> <span class="o">=</span> <span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;algorithm&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">alg_name_splits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;NLOPT&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Algorithm name should be specified as `NLOPT_{G,L}N_XXX`&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">alg_name_splits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">alg_name_splits</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;D&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Only gradient-free algorithms (NLOPT_GN or NLOPT_LN) are &quot;</span>
                             <span class="s2">&quot;supported.&quot;</span><span class="p">)</span>

        <span class="n">algorithm</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">nlopt</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">alg_name_splits</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="o">.</span><span class="n">_rescaled_values</span><span class="p">)</span>
        <span class="n">opt</span> <span class="o">=</span> <span class="n">nlopt</span><span class="o">.</span><span class="n">opt</span><span class="p">(</span><span class="n">algorithm</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x0</span><span class="p">))</span>
        <span class="n">opt</span><span class="o">.</span><span class="n">set_min_objective</span><span class="p">(</span><span class="n">loss_func</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;ftol_abs&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">opt</span><span class="o">.</span><span class="n">set_ftol_abs</span><span class="p">(</span><span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;ftol_abs&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="s2">&quot;ftol_rel&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">opt</span><span class="o">.</span><span class="n">set_ftol_rel</span><span class="p">(</span><span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;ftol_rel&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="s2">&quot;xtol_abs&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">opt</span><span class="o">.</span><span class="n">set_xtol_abs</span><span class="p">(</span><span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;xtol_abs&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="s2">&quot;xtol_rel&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">opt</span><span class="o">.</span><span class="n">set_xtol_rel</span><span class="p">(</span><span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;xtol_rel&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="s2">&quot;stopval&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">opt</span><span class="o">.</span><span class="n">set_stopval</span><span class="p">(</span><span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;stopval&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="s2">&quot;maxeval&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">opt</span><span class="o">.</span><span class="n">set_maxeval</span><span class="p">(</span><span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;maxeval&quot;</span><span class="p">])</span>
        <span class="c1"># Maximum runtime in seconds</span>
        <span class="k">if</span> <span class="s2">&quot;maxtime&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">opt</span><span class="o">.</span><span class="n">set_maxtime</span><span class="p">(</span><span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;maxtime&quot;</span><span class="p">])</span>
        <span class="c1"># set algorithm-specific parameters (see</span>
        <span class="c1"># https://nlopt.readthedocs.io/en/latest/NLopt_Reference/#algorithm-specific-parameters)</span>
        <span class="k">if</span> <span class="s2">&quot;algorithm_params&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;algorithm_params&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">opt</span><span class="o">.</span><span class="n">set_param</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;ineq_constraints&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Using eval() is potentially dangerous as it can execute &quot;</span>
                <span class="s2">&quot;arbitrary code! Do not store your config file in a place&quot;</span>
                <span class="s2">&quot;where others have writing access!&quot;</span>
            <span class="p">)</span>
            <span class="n">constr_list</span> <span class="o">=</span> <span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;ineq_constraints&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">constr_list</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">constr_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">constr_list</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">constr</span> <span class="ow">in</span> <span class="n">constr_list</span><span class="p">:</span>
                <span class="c1"># the inequality function is specified as a function that takes a</span>
                <span class="c1"># ParamSet as its input</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;adding constraint (must stay positive): </span><span class="si">{</span><span class="n">constr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">ineq_func_params</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">constr</span><span class="p">)</span>
                <span class="k">assert</span> <span class="nb">callable</span><span class="p">(</span><span class="n">ineq_func_params</span><span class="p">),</span> <span class="s2">&quot;evaluated object is not a valid function&quot;</span>
                <span class="k">def</span> <span class="nf">ineq_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">grad</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">grad</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;gradients not supported&quot;</span><span class="p">)</span>
                    <span class="n">hypo_maker</span><span class="o">.</span><span class="n">_set_rescaled_free_params</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;Detectors&quot;</span><span class="p">:</span>
                        <span class="n">update_param_values_detector</span><span class="p">(</span><span class="n">hypo_maker</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="p">)</span> <span class="c1">#updates values for ALL detectors</span>
                    <span class="c1"># In NLOPT, the inequality function must stay negative, while in</span>
                    <span class="c1"># scipy, the inequality function must stay positive. We keep with</span>
                    <span class="c1"># the scipy convention by flipping the sign.</span>
                    <span class="k">return</span> <span class="o">-</span><span class="n">ineq_func_params</span><span class="p">(</span><span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
                <span class="n">opt</span><span class="o">.</span><span class="n">add_inequality_constraint</span><span class="p">(</span><span class="n">ineq_func</span><span class="p">)</span>

        <span class="c1"># Population size for stochastic search algorithms, see</span>
        <span class="c1"># https://nlopt.readthedocs.io/en/latest/NLopt_Reference/#stochastic-population</span>
        <span class="k">if</span> <span class="s2">&quot;population&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">opt</span><span class="o">.</span><span class="n">set_population</span><span class="p">(</span><span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;population&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="s2">&quot;initial_step&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">opt</span><span class="o">.</span><span class="n">set_initial_step</span><span class="p">(</span><span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;initial_step&quot;</span><span class="p">])</span>

        <span class="n">opt</span><span class="o">.</span><span class="n">set_lower_bounds</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
        <span class="n">opt</span><span class="o">.</span><span class="n">set_upper_bounds</span><span class="p">(</span><span class="mf">1.</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;local_optimizer&quot;</span> <span class="ow">in</span> <span class="n">method_kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">local_opt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_define_nlopt_opt</span><span class="p">(</span><span class="n">method_kwargs</span><span class="p">[</span><span class="s2">&quot;local_optimizer&quot;</span><span class="p">],</span>
                                               <span class="n">loss_func</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="p">)</span>
            <span class="n">opt</span><span class="o">.</span><span class="n">set_local_optimizer</span><span class="p">(</span><span class="n">local_opt</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">opt</span>

    <span class="k">def</span> <span class="nf">_pprint_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">free_p</span><span class="p">,</span> <span class="n">external_priors_penalty</span><span class="p">,</span> <span class="n">metric</span><span class="p">):</span>
        <span class="c1"># Display any units on top</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(^[+0-9.eE-]* )|(^[+0-9.eE-]*$)&#39;</span><span class="p">)</span>
        <span class="n">hdr</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">*</span><span class="p">(</span><span class="mi">6</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">10</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="mi">12</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">unt</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">free_p</span><span class="p">:</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;~&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">u</span><span class="p">:</span>
                <span class="n">u</span> <span class="o">=</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="n">u</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span>
            <span class="n">unt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="mi">12</span><span class="p">))</span>
        <span class="n">hdr</span> <span class="o">+=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">unt</span><span class="p">)</span>
        <span class="n">hdr</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>

        <span class="c1"># Header names</span>
        <span class="n">hdr</span> <span class="o">+=</span> <span class="p">(</span><span class="s1">&#39;iter&#39;</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="s1">&#39;funcalls&#39;</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span>
                <span class="n">metric</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">12</span><span class="p">]</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; | &#39;</span><span class="p">)</span>
        <span class="n">hdr</span> <span class="o">+=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">12</span><span class="p">]</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">free_p</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">external_priors_penalty</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hdr</span> <span class="o">+=</span> <span class="s2">&quot; |   penalty  &quot;</span>
        <span class="n">hdr</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>

        <span class="c1"># Underscores</span>
        <span class="n">hdr</span> <span class="o">+=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;-&#39;</span><span class="o">*</span><span class="mi">6</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="o">*</span><span class="mi">10</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="o">*</span><span class="mi">12</span><span class="p">,</span> <span class="s1">&#39;+&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;-&#39;</span><span class="o">*</span><span class="mi">12</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">free_p</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">external_priors_penalty</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hdr</span> <span class="o">+=</span> <span class="s2">&quot; + -----------&quot;</span>
        <span class="n">hdr</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>

        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">hdr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_minimizer_callable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scaled_param_vals</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">data_dist</span><span class="p">,</span>
                            <span class="n">metric</span><span class="p">,</span> <span class="n">counter</span><span class="p">,</span> <span class="n">fit_history</span><span class="p">,</span> <span class="n">flip_x0</span><span class="p">,</span>
                            <span class="n">external_priors_penalty</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Simple callback for use by scipy.optimize minimizers.</span>

<span class="sd">        This should *not* in general be called by users, as `scaled_param_vals`</span>
<span class="sd">        are stripped of their units and scaled to the range [0, 1], and hence</span>
<span class="sd">        some validation of inputs is bypassed by this method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scaled_param_vals : sequence of floats</span>
<span class="sd">            If called from a scipy.optimize minimizer, this sequence is</span>
<span class="sd">            provieded by the minimizer itself. These values are all expected to</span>
<span class="sd">            be in the range [0, 1] and be simple floats (no units or</span>
<span class="sd">            uncertainties attached, etc.). Rescaling the parameter values to</span>
<span class="sd">            their original (physical) ranges (including units) is handled</span>
<span class="sd">            within this method.</span>

<span class="sd">        hypo_maker : Detectors or DistributionMaker</span>
<span class="sd">            Creates the per-bin expectation values per map</span>
<span class="sd">            based on its param values. Free params in the</span>
<span class="sd">            `hypo_maker` are modified by the minimizer to achieve a &quot;best&quot; fit.</span>

<span class="sd">        data_dist : Sequence of MapSets or MapSet</span>
<span class="sd">            Data distribution to be fit. Can be an actual-, Asimov-, or</span>
<span class="sd">            pseudo-data distribution (where the latter two are derived from</span>
<span class="sd">            simulation and so aren&#39;t technically &quot;data&quot;).</span>

<span class="sd">        metric : string or iterable of strings</span>
<span class="sd">            Metric by which to evaluate the fit. See Map</span>

<span class="sd">        counter : Counter</span>
<span class="sd">            Mutable object to keep track--outside this method--of the number of</span>
<span class="sd">            times this method is called.</span>

<span class="sd">        flip_x0 : ndarray of type bool</span>
<span class="sd">            Indicates which indices of x0 should be flipped around 0.5.</span>

<span class="sd">        external_priors_penalty : func</span>
<span class="sd">            User defined prior penalty function, which takes `hypo_maker` and</span>
<span class="sd">            `metric` as arguments and returns numerical value of penalty to</span>
<span class="sd">            the metric value. It is expected sign of the penalty is correctly</span>
<span class="sd">            specified inside the `external_priors_penalty` (e.g. negative for</span>
<span class="sd">            llh or positive for chi2).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Want to *maximize* e.g. log-likelihood but we&#39;re using a minimizer,</span>
        <span class="c1"># so flip sign of metric in those cases.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">metric</span> <span class="o">=</span> <span class="p">[</span><span class="n">metric</span><span class="p">]</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">metric</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">METRICS_TO_MAXIMIZE</span> <span class="ow">and</span> <span class="n">sign</span> <span class="o">!=</span> <span class="o">+</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">elif</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">METRICS_TO_MINIMIZE</span> <span class="ow">and</span> <span class="n">sign</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">sign</span> <span class="o">=</span> <span class="o">+</span><span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Defined metrics are not compatible&#39;</span><span class="p">)</span>

        <span class="n">scaled_param_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">flip_x0</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">scaled_param_vals</span><span class="p">,</span> <span class="n">scaled_param_vals</span><span class="p">)</span>
        <span class="c1"># Set param values from the scaled versions the minimizer works with</span>
        <span class="n">hypo_maker</span><span class="o">.</span><span class="n">_set_rescaled_free_params</span><span class="p">(</span><span class="n">scaled_param_vals</span><span class="p">)</span> <span class="c1"># pylint: disable=protected-access</span>
        <span class="k">if</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;Detectors&quot;</span><span class="p">:</span>
            <span class="n">update_param_values_detector</span><span class="p">(</span><span class="n">hypo_maker</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="p">)</span> <span class="c1">#updates values for ALL detectors</span>

        <span class="c1"># Get the map set</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">metric</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;generalized_poisson_llh&#39;</span><span class="p">:</span>
                <span class="n">hypo_asimov_dist</span> <span class="o">=</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">get_outputs</span><span class="p">(</span><span class="n">return_sum</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">output_mode</span><span class="o">=</span><span class="s1">&#39;binned&#39;</span><span class="p">,</span> <span class="n">force_standard_output</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">hypo_asimov_dist</span> <span class="o">=</span> <span class="n">merge_mapsets_together</span><span class="p">(</span><span class="n">mapset_list</span><span class="o">=</span><span class="n">hypo_asimov_dist</span><span class="p">)</span>
                <span class="n">data_dist</span> <span class="o">=</span> <span class="n">data_dist</span><span class="o">.</span><span class="n">maps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># Extract the map from the MapSet</span>
                <span class="n">metric_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;empty_bins&#39;</span><span class="p">:</span><span class="n">hypo_maker</span><span class="o">.</span><span class="n">empty_bin_indices</span><span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">hypo_asimov_dist</span> <span class="o">=</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">get_outputs</span><span class="p">(</span><span class="n">return_sum</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hypo_asimov_dist</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">):</span>
                    <span class="n">hypo_asimov_dist</span> <span class="o">=</span> <span class="n">hypo_asimov_dist</span><span class="p">[</span><span class="s1">&#39;weights&#39;</span><span class="p">]</span>
                <span class="n">metric_kwargs</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">blindness</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Minimizer failed&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="s1">&#39;Failed to generate distribution with free&#39;</span>
                    <span class="s1">&#39; params </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span>
                <span class="p">)</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
            <span class="k">raise</span>

        <span class="c1">#</span>
        <span class="c1"># Assess the fit: whether the data came from the hypo_asimov_dist</span>
        <span class="c1">#</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;Detectors&quot;</span><span class="p">:</span>
                <span class="n">metric_val</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hypo_maker</span><span class="o">.</span><span class="n">distribution_makers</span><span class="p">)):</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data_dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">metric_total</span><span class="p">(</span><span class="n">expected_values</span><span class="o">=</span><span class="n">hypo_asimov_dist</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                                  <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">metric_kwargs</span><span class="o">=</span><span class="n">metric_kwargs</span><span class="p">)</span>
                    <span class="n">metric_val</span> <span class="o">+=</span> <span class="n">data</span>
                <span class="n">priors</span> <span class="o">=</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">priors_penalty</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># uses just the &quot;first&quot; metric for prior</span>
                <span class="n">metric_val</span> <span class="o">+=</span> <span class="n">priors</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># DistributionMaker object</span>
                <span class="k">if</span> <span class="n">metric</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;weighted_chi2&#39;</span><span class="p">:</span>
                    <span class="n">actual_values</span> <span class="o">=</span> <span class="n">data_dist</span><span class="o">.</span><span class="n">hist</span><span class="p">[</span><span class="s1">&#39;total&#39;</span><span class="p">]</span>
                    <span class="n">expected_values</span> <span class="o">=</span> <span class="n">hypo_asimov_dist</span><span class="o">.</span><span class="n">hist</span><span class="p">[</span><span class="s1">&#39;total&#39;</span><span class="p">]</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;output_binning&#39;</span><span class="p">:</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">pipelines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">output_binning</span><span class="p">,</span>
                         <span class="s1">&#39;output_key&#39;</span><span class="p">:</span> <span class="s1">&#39;bin_unc2&#39;</span><span class="p">}</span>
                    <span class="n">bin_unc2</span> <span class="o">=</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">get_outputs</span><span class="p">(</span><span class="n">return_sum</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">hist</span><span class="p">[</span><span class="s1">&#39;total&#39;</span><span class="p">]</span>
                    <span class="n">metric_val</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weighted_chi2</span><span class="p">(</span><span class="n">actual_values</span><span class="p">,</span> <span class="n">expected_values</span><span class="p">,</span> <span class="n">bin_unc2</span><span class="p">))</span>
                            <span class="o">+</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">priors_penalty</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">metric_val</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">data_dist</span><span class="o">.</span><span class="n">metric_total</span><span class="p">(</span><span class="n">expected_values</span><span class="o">=</span><span class="n">hypo_asimov_dist</span><span class="p">,</span>
                                                   <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">metric_kwargs</span><span class="o">=</span><span class="n">metric_kwargs</span><span class="p">)</span>
                            <span class="o">+</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">priors_penalty</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">blindness</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Minimizer failed&#39;</span><span class="p">)</span>
            <span class="k">else</span> <span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="s1">&#39;Failed when computing metric with free params </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span>
                    <span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span>
                <span class="p">)</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
            <span class="k">raise</span>

        <span class="n">penalty</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">external_priors_penalty</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">penalty</span> <span class="o">=</span> <span class="n">external_priors_penalty</span><span class="p">(</span><span class="n">hypo_maker</span><span class="o">=</span><span class="n">hypo_maker</span><span class="p">,</span><span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">)</span>

        <span class="c1"># Report status of metric &amp; params (except if blinded)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">blindness</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;minimizer iteration: #</span><span class="si">%6d</span><span class="s1"> | function call: #</span><span class="si">%6d</span><span class="s1">&#39;</span>
                   <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nit</span><span class="p">,</span> <span class="n">counter</span><span class="o">.</span><span class="n">count</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#msg = &#39;%s=%.6e | %s&#39; %(metric, metric_val, hypo_maker.params.free)</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1"> | &#39;</span> <span class="o">%</span><span class="p">((</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1">&#39;</span><span class="o">%</span><span class="bp">self</span><span class="o">.</span><span class="n">_nit</span><span class="p">)</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span>
                                  <span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">counter</span><span class="o">.</span><span class="n">count</span><span class="p">)</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
                                  <span class="nb">format</span><span class="p">(</span><span class="n">metric_val</span><span class="p">,</span> <span class="s1">&#39;0.5e&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">12</span><span class="p">))</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([(</span><span class="s1">&#39;</span><span class="si">%0.5e</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">p</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">m</span><span class="p">)</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
                             <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">external_priors_penalty</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; | </span><span class="si">{</span><span class="n">penalty</span><span class="si">:</span><span class="s2">11.4e</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pprint</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">msg</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">blindness</span><span class="p">:</span>
            <span class="n">fit_history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[</span><span class="n">metric_val</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">m</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">external_priors_penalty</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">metric_val</span> <span class="o">+=</span> <span class="n">external_priors_penalty</span><span class="p">(</span><span class="n">hypo_maker</span><span class="o">=</span><span class="n">hypo_maker</span><span class="p">,</span><span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sign</span><span class="o">*</span><span class="n">metric_val</span>

    <span class="k">def</span> <span class="nf">_minimizer_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xk</span><span class="p">,</span> <span class="o">**</span><span class="n">unused_kwargs</span><span class="p">):</span> <span class="c1"># pylint: disable=unused-argument</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Passed as `callback` parameter to `optimize.minimize`, and is called</span>
<span class="sd">        after each iteration. Keeps track of number of iterations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xk : list</span>
<span class="sd">            Parameter vector</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nit</span> <span class="o">+=</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="Analysis">
<a class="viewcode-back" href="../../../pisa.analysis.html#pisa.analysis.analysis.Analysis">[docs]</a>
<span class="k">class</span> <span class="nc">Analysis</span><span class="p">(</span><span class="n">BasicAnalysis</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Analysis class for &quot;canonical&quot; IceCube/DeepCore/PINGU analyses.</span>

<span class="sd">    * &quot;Data&quot; distribution creation (via passed `data_maker` object)</span>
<span class="sd">    * &quot;Expected&quot; distribution creation (via passed `distribution_maker` object)</span>
<span class="sd">    * Minimizer Interface (via method `_minimizer_callable`)</span>
<span class="sd">        Interfaces to a minimizer for modifying the free parameters of the</span>
<span class="sd">        `distribution_maker` to fit its output (as closely as possible) to the</span>
<span class="sd">        data distribution is provided. See [minimizer_settings] for</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nit</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pprint</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blindness</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="Analysis.fit_hypo">
<a class="viewcode-back" href="../../../pisa.analysis.html#pisa.analysis.analysis.Analysis.fit_hypo">[docs]</a>
    <span class="k">def</span> <span class="nf">fit_hypo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dist</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">minimizer_settings</span><span class="p">,</span>
                 <span class="n">hypo_param_selections</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reset_free</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">check_octant</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fit_octants_separately</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">check_ordering</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">other_metrics</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">blind</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">pprint</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">external_priors_penalty</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fitter &quot;outer&quot; loop: If `check_octant` is True, run</span>
<span class="sd">        `fit_hypo_inner` starting in each octant of theta23 (assuming that</span>
<span class="sd">        is a param in the `hypo_maker`). Otherwise, just run the inner</span>
<span class="sd">        method once.</span>

<span class="sd">        Note that prior to running the fit, the `hypo_maker` has</span>
<span class="sd">        `hypo_param_selections` applied and its free parameters are reset to</span>
<span class="sd">        their nominal values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data_dist : MapSet or List of MapSets</span>
<span class="sd">            Data distribution(s). These are what the hypothesis is tasked to</span>
<span class="sd">            best describe during the optimization process.</span>

<span class="sd">        hypo_maker : Detectors, DistributionMaker or instantiable thereto</span>
<span class="sd">            Generates the expectation distribution under a particular</span>
<span class="sd">            hypothesis. This typically has (but is not required to have) some</span>
<span class="sd">            free parameters which can be modified by the minimizer to optimize</span>
<span class="sd">            the `metric`.</span>

<span class="sd">        hypo_param_selections : None, string, or sequence of strings</span>
<span class="sd">            A pipeline configuration can have param selectors that allow</span>
<span class="sd">            switching a parameter among two or more values by specifying the</span>
<span class="sd">            corresponding param selector(s) here. This also allows for a single</span>
<span class="sd">            instance of a DistributionMaker to generate distributions from</span>
<span class="sd">            different hypotheses.</span>

<span class="sd">        metric : string or iterable of strings</span>
<span class="sd">            The metric to use for optimization. Valid metrics are found in</span>
<span class="sd">            `VALID_METRICS`. Note that the optimized hypothesis also has this</span>
<span class="sd">            metric evaluated and reported for each of its output maps.</span>

<span class="sd">        minimizer_settings : string or dict</span>

<span class="sd">        check_octant : bool</span>
<span class="sd">            If theta23 is a parameter to be used in the optimization (i.e.,</span>
<span class="sd">            free), the fit will be re-run in the second (first) octant if</span>
<span class="sd">            theta23 is initialized in the first (second) octant.</span>

<span class="sd">        reset_free : bool</span>
<span class="sd">            Resets all free parameters to values defined in stages when starting a fit</span>

<span class="sd">        fit_octants_separately : bool</span>
<span class="sd">            If &#39;check_octant&#39; is set so that the two octants of theta23 are</span>
<span class="sd">            individually checked, this flag enforces that each theta23 can</span>
<span class="sd">            only vary within the octant currently being checked (e.g. the</span>
<span class="sd">            minimizer cannot swap octants). Deprecated.</span>

<span class="sd">        check_ordering : bool</span>
<span class="sd">            If the ordering is not in the hypotheses already being tested, the</span>
<span class="sd">            fit will be run in both orderings.</span>

<span class="sd">        other_metrics : None, string, or list of strings</span>
<span class="sd">            After finding the best fit, these other metrics will be evaluated</span>
<span class="sd">            for each output that contributes to the overall fit. All strings</span>
<span class="sd">            must be valid metrics, as per `VALID_METRICS`, or the</span>
<span class="sd">            special string &#39;all&#39; can be specified to evaluate all</span>
<span class="sd">            VALID_METRICS..</span>

<span class="sd">        pprint : bool</span>
<span class="sd">            Whether to show live-update of minimizer progress.</span>

<span class="sd">        blind : bool or int</span>
<span class="sd">            Whether to carry out a blind analysis. If True or 1, this hides actual</span>
<span class="sd">            parameter values from display and disallows these (as well as Jacobian,</span>
<span class="sd">            Hessian, etc.) from ending up in logfiles. If given an integer &gt; 1, the</span>
<span class="sd">            fitted parameters are also prevented from being stored in fit info</span>
<span class="sd">            dictionaries.</span>

<span class="sd">        external_priors_penalty : func</span>
<span class="sd">            User defined prior penalty function. Adds an extra penalty</span>
<span class="sd">            to the metric that is minimized, depending on the input function.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        best_fit_info : HypoFitResult (see fit_hypo_inner method for details of</span>
<span class="sd">            `fit_info` dict)</span>
<span class="sd">        alternate_fits : list of `fit_info` from other fits run</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">fit_octants_separately</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;fit_octants_separately is deprecated and will be ignored, &quot;</span>
                          <span class="s2">&quot;octants are always fit separately now.&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">blindness</span> <span class="o">=</span> <span class="n">blind</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pprint</span> <span class="o">=</span> <span class="n">pprint</span>

        <span class="k">if</span> <span class="n">hypo_param_selections</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hypo_param_selections</span> <span class="o">=</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">param_selections</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">metric</span> <span class="o">=</span> <span class="p">[</span><span class="n">metric</span><span class="p">]</span>
        <span class="c1"># Check number of used metrics</span>
        <span class="k">if</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;Detectors&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># One metric for all detectors</span>
                <span class="n">metric</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">hypo_maker</span><span class="o">.</span><span class="n">distribution_makers</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">hypo_maker</span><span class="o">.</span><span class="n">distribution_makers</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;Number of defined metrics does not match with number of detectors.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># DistributionMaker object</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">check_ordering</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;nh&#39;</span> <span class="ow">in</span> <span class="n">hypo_param_selections</span> <span class="ow">or</span> <span class="s1">&#39;ih&#39;</span> <span class="ow">in</span> <span class="n">hypo_param_selections</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;One of the orderings has already been &#39;</span>
                                 <span class="s1">&#39;specified as one of the hypotheses but the &#39;</span>
                                 <span class="s1">&#39;fit has been requested to check both. These &#39;</span>
                                 <span class="s1">&#39;are incompatible.&#39;</span><span class="p">)</span>

            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Performing fits in both orderings.&#39;</span><span class="p">)</span>
            <span class="n">extra_param_selections</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;nh&#39;</span><span class="p">,</span> <span class="s1">&#39;ih&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">extra_param_selections</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>

        <span class="n">alternate_fits</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># TODO: Pass alternative fits up the chain</span>
        <span class="k">for</span> <span class="n">extra_param_selection</span> <span class="ow">in</span> <span class="n">extra_param_selections</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">extra_param_selection</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">full_param_selections</span> <span class="o">=</span> <span class="n">hypo_param_selections</span>
                <span class="n">full_param_selections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">extra_param_selection</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">full_param_selections</span> <span class="o">=</span> <span class="n">hypo_param_selections</span>
            <span class="c1"># Select the version of the parameters used for this hypothesis</span>
            <span class="n">hypo_maker</span><span class="o">.</span><span class="n">select_params</span><span class="p">(</span><span class="n">full_param_selections</span><span class="p">)</span>

            <span class="c1"># Reset free parameters to nominal values</span>
            <span class="k">if</span> <span class="n">reset_free</span><span class="p">:</span>
                <span class="n">hypo_maker</span><span class="o">.</span><span class="n">reset_free</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">check_octant</span><span class="p">:</span>
                <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;octants&quot;</span>
                <span class="n">method_kwargs</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;angle&quot;</span><span class="p">:</span> <span class="s2">&quot;theta23&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;inflection_point&quot;</span><span class="p">:</span> <span class="mi">45</span> <span class="o">*</span> <span class="n">ureg</span><span class="o">.</span><span class="n">deg</span><span class="p">,</span>
                    <span class="s2">&quot;reset_free&quot;</span><span class="p">:</span> <span class="n">reset_free</span><span class="p">,</span>
                <span class="p">}</span>
                <span class="n">local_fit_kwargs</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;scipy&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;method_kwargs&quot;</span><span class="p">:</span> <span class="n">minimizer_settings</span><span class="p">,</span>
                    <span class="s2">&quot;local_fit_kwargs&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                <span class="p">}</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;scipy&quot;</span>
                <span class="n">method_kwargs</span> <span class="o">=</span> <span class="n">minimizer_settings</span>
                <span class="n">local_fit_kwargs</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># Perform the fit</span>
            <span class="n">best_fit_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_recursively</span><span class="p">(</span>
                <span class="n">data_dist</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">external_priors_penalty</span><span class="p">,</span>
                <span class="n">method</span><span class="p">,</span> <span class="n">method_kwargs</span><span class="p">,</span> <span class="n">local_fit_kwargs</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">best_fit_info</span><span class="p">,</span> <span class="n">alternate_fits</span></div>


<div class="viewcode-block" id="Analysis.nofit_hypo">
<a class="viewcode-back" href="../../../pisa.analysis.html#pisa.analysis.analysis.Analysis.nofit_hypo">[docs]</a>
    <span class="k">def</span> <span class="nf">nofit_hypo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dist</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">hypo_param_selections</span><span class="p">,</span>
                   <span class="n">hypo_asimov_dist</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">other_metrics</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">blind</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">external_priors_penalty</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fitting a hypo to a distribution generated by its own</span>
<span class="sd">        distribution maker is unnecessary. In such a case, use this method</span>
<span class="sd">        (instead of `fit_hypo`) to still retrieve meaningful information for</span>
<span class="sd">        e.g. the match metrics.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data_dist : MapSet or List of MapSets</span>
<span class="sd">        hypo_maker : Detectors or DistributionMaker</span>
<span class="sd">        hypo_param_selections : None, string, or sequence of strings</span>
<span class="sd">        hypo_asimov_dist : MapSet or List of MapSets</span>
<span class="sd">        metric : string or iterable of strings</span>
<span class="sd">        other_metrics : None, string, or sequence of strings</span>
<span class="sd">        blind : bool</span>
<span class="sd">        external_priors_penalty : func</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fit_info</span> <span class="o">=</span> <span class="n">HypoFitResult</span><span class="p">()</span>

        <span class="c1"># NOTE: Select params but *do not* reset to nominal values to record</span>
        <span class="c1"># the current (presumably already optimal) param values</span>
        <span class="n">hypo_maker</span><span class="o">.</span><span class="n">select_params</span><span class="p">(</span><span class="n">hypo_param_selections</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">metric</span> <span class="o">=</span> <span class="p">[</span><span class="n">metric</span><span class="p">]</span>
        <span class="c1"># Check number of used metrics</span>
        <span class="k">if</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;Detectors&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># One metric for all detectors</span>
                <span class="n">metric</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">hypo_maker</span><span class="o">.</span><span class="n">distribution_makers</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">hypo_maker</span><span class="o">.</span><span class="n">distribution_makers</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;Number of defined metrics does not match with number of detectors.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># DistributionMaker object</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">metric</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">fit_info</span><span class="o">.</span><span class="n">metric</span> <span class="o">=</span> <span class="n">metric</span>

        <span class="c1"># Assess the fit: whether the data came from the hypo_asimov_dist</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;Detectors&quot;</span><span class="p">:</span>
                <span class="n">metric_val</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hypo_maker</span><span class="o">.</span><span class="n">distribution_makers</span><span class="p">)):</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data_dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">metric_total</span><span class="p">(</span><span class="n">expected_values</span><span class="o">=</span><span class="n">hypo_asimov_dist</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">metric_val</span> <span class="o">+=</span> <span class="n">data</span>
                <span class="n">priors</span> <span class="o">=</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">priors_penalty</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># uses just the &quot;first&quot; metric for prior</span>
                <span class="n">metric_val</span> <span class="o">+=</span> <span class="n">priors</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># DistributionMaker object</span>

                <span class="k">if</span> <span class="s1">&#39;generalized_poisson_llh&#39;</span> <span class="o">==</span> <span class="n">metric</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>

                    <span class="n">hypo_asimov_dist</span> <span class="o">=</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">get_outputs</span><span class="p">(</span><span class="n">return_sum</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">output_mode</span><span class="o">=</span><span class="s1">&#39;binned&#39;</span><span class="p">,</span> <span class="n">force_standard_output</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">hypo_asimov_dist</span> <span class="o">=</span> <span class="n">merge_mapsets_together</span><span class="p">(</span><span class="n">mapset_list</span><span class="o">=</span><span class="n">hypo_asimov_dist</span><span class="p">)</span>
                    <span class="n">data_dist</span> <span class="o">=</span> <span class="n">data_dist</span><span class="o">.</span><span class="n">maps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># Extract the map from the MapSet</span>
                    <span class="n">metric_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;empty_bins&#39;</span><span class="p">:</span><span class="n">hypo_maker</span><span class="o">.</span><span class="n">empty_bin_indices</span><span class="p">}</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">hypo_asimov_dist</span> <span class="o">=</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">get_outputs</span><span class="p">(</span><span class="n">return_sum</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hypo_asimov_dist</span><span class="p">,</span> <span class="n">HypoFitResult</span><span class="p">):</span>
                        <span class="n">hypo_asimov_dist</span> <span class="o">=</span> <span class="n">hypo_asimov_dist</span><span class="p">[</span><span class="s1">&#39;weights&#39;</span><span class="p">]</span>
                    <span class="n">metric_kwargs</span> <span class="o">=</span> <span class="p">{}</span>

                <span class="n">metric_val</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">data_dist</span><span class="o">.</span><span class="n">metric_total</span><span class="p">(</span><span class="n">expected_values</span><span class="o">=</span><span class="n">hypo_asimov_dist</span><span class="p">,</span>
                                           <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">metric_kwargs</span><span class="o">=</span><span class="n">metric_kwargs</span><span class="p">)</span>
                    <span class="o">+</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">priors_penalty</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">external_priors_penalty</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">metric_val</span> <span class="o">+=</span> <span class="n">external_priors_penalty</span><span class="p">(</span><span class="n">hypo_maker</span><span class="o">=</span><span class="n">hypo_maker</span><span class="p">,</span><span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">blindness</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Minimizer failed&#39;</span><span class="p">)</span>
            <span class="k">else</span> <span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="s1">&#39;Failed when computing metric with free params </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span>
                    <span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span>
                <span class="p">)</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
            <span class="k">raise</span>

        <span class="n">fit_info</span><span class="o">.</span><span class="n">metric_val</span> <span class="o">=</span> <span class="n">metric_val</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">blindness</span><span class="p">:</span>
            <span class="c1"># Okay, if blind analysis is being performed, reset the values so</span>
            <span class="c1"># the user can&#39;t find them in the object</span>
            <span class="n">hypo_maker</span><span class="o">.</span><span class="n">reset_free</span><span class="p">()</span>
            <span class="n">fit_info</span><span class="o">.</span><span class="n">metric_val</span> <span class="o">=</span> <span class="n">ParamSet</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fit_info</span><span class="o">.</span><span class="n">metric_val</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;Detectors&quot;</span><span class="p">:</span>
            <span class="n">fit_info</span><span class="o">.</span><span class="n">detailed_metric_info</span> <span class="o">=</span> <span class="p">[</span><span class="n">fit_info</span><span class="o">.</span><span class="n">get_detailed_metric_info</span><span class="p">(</span>
                <span class="n">data_dist</span><span class="o">=</span><span class="n">data_dist</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">hypo_asimov_dist</span><span class="o">=</span><span class="n">hypo_asimov_dist</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">params</span><span class="o">=</span><span class="n">hypo_maker</span><span class="o">.</span><span class="n">distribution_makers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">other_metrics</span><span class="o">=</span><span class="n">other_metrics</span><span class="p">,</span> <span class="n">detector_name</span><span class="o">=</span><span class="n">hypo_maker</span><span class="o">.</span><span class="n">det_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_dist</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># DistributionMaker object</span>

            <span class="k">if</span> <span class="s1">&#39;generalized_poisson_llh&#39;</span> <span class="o">==</span> <span class="n">metric</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">generalized_poisson_dist</span> <span class="o">=</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">get_outputs</span><span class="p">(</span><span class="n">return_sum</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">force_standard_output</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">generalized_poisson_dist</span> <span class="o">=</span> <span class="n">merge_mapsets_together</span><span class="p">(</span><span class="n">mapset_list</span><span class="o">=</span><span class="n">generalized_poisson_dist</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">generalized_poisson_dist</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">fit_info</span><span class="o">.</span><span class="n">detailed_metric_info</span> <span class="o">=</span> <span class="n">fit_info</span><span class="o">.</span><span class="n">get_detailed_metric_info</span><span class="p">(</span>
                <span class="n">data_dist</span><span class="o">=</span><span class="n">data_dist</span><span class="p">,</span> <span class="n">hypo_asimov_dist</span><span class="o">=</span><span class="n">hypo_asimov_dist</span><span class="p">,</span> <span class="n">generalized_poisson_hypo</span><span class="o">=</span><span class="n">generalized_poisson_dist</span><span class="p">,</span>
                <span class="n">params</span><span class="o">=</span><span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">other_metrics</span><span class="o">=</span><span class="n">other_metrics</span><span class="p">,</span>
                <span class="n">detector_name</span><span class="o">=</span><span class="n">hypo_maker</span><span class="o">.</span><span class="n">detector_name</span>
            <span class="p">)</span>

        <span class="n">fit_info</span><span class="o">.</span><span class="n">minimizer_time</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">*</span> <span class="n">ureg</span><span class="o">.</span><span class="n">sec</span>
        <span class="n">fit_info</span><span class="o">.</span><span class="n">num_distributions_generated</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">fit_info</span><span class="o">.</span><span class="n">minimizer_metadata</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">fit_info</span><span class="o">.</span><span class="n">hypo_asimov_dist</span> <span class="o">=</span> <span class="n">hypo_asimov_dist</span>
        <span class="k">return</span> <span class="n">fit_info</span></div>




    <span class="c1"># TODO: move the complexity of defining a scan into a class with various</span>
    <span class="c1"># factory methods, and just pass that class to the scan method; we will</span>
    <span class="c1"># surely want to use scanning over parameters in more general ways, too:</span>
    <span class="c1"># * set (some) fixed params, then run (minimizer, scan, etc.) on free</span>
    <span class="c1">#   params</span>
    <span class="c1"># * set (some free or fixed) params, then check metric</span>
    <span class="c1"># where the setting of the params is done for some number of values.</span>
<div class="viewcode-block" id="Analysis.scan">
<a class="viewcode-back" href="../../../pisa.analysis.html#pisa.analysis.analysis.Analysis.scan">[docs]</a>
    <span class="k">def</span> <span class="nf">scan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dist</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">hypo_param_selections</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">param_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">only_points</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">outer</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">profile</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">minimizer_settings</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">outfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">debug_mode</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set hypo maker parameters named by `param_names` according to</span>
<span class="sd">        either values specified by `values` or number of steps specified by</span>
<span class="sd">        `steps`, and return the `metric` indicating how well the data</span>
<span class="sd">        distribution is described by each distribution.</span>

<span class="sd">        Some flexibility in how the user can specify `values` is allowed, based</span>
<span class="sd">        upon the shapes of `param_names` and `values` and how the `outer` flag</span>
<span class="sd">        is set.</span>

<span class="sd">        Either `values` or `steps` must be specified, but not both.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data_dist : Sequence of MapSets or MapSet</span>
<span class="sd">            Data distribution(s). These are what the hypothesis is tasked to</span>
<span class="sd">            best describe during the optimization/comparison process.</span>

<span class="sd">        hypo_maker : Detectors, DistributionMaker or instantiable thereto</span>
<span class="sd">            Generates the expectation distribution under a particular</span>
<span class="sd">            hypothesis. This typically has (but is not required to have) some</span>
<span class="sd">            free parameters which will be modified by the minimizer to optimize</span>
<span class="sd">            the `metric` in case `profile` is set to True.</span>

<span class="sd">        hypo_param_selections : None, string, or sequence of strings</span>
<span class="sd">            A pipeline configuration can have param selectors that allow</span>
<span class="sd">            switching a parameter among two or more values by specifying the</span>
<span class="sd">            corresponding param selector(s) here. This also allows for a single</span>
<span class="sd">            instance of a DistributionMaker to generate distributions from</span>
<span class="sd">            different hypotheses.</span>

<span class="sd">        metric : string or iterable of strings</span>
<span class="sd">            The metric to use for optimization/comparison. Note that the</span>
<span class="sd">            optimized hypothesis also has this metric evaluated and reported for</span>
<span class="sd">            each of its output maps. Confer `pisa.core.map` for valid metrics.</span>

<span class="sd">        param_names : None, string, or sequence of strings</span>
<span class="sd">            If None, assume all parameters are to be scanned; otherwise,</span>
<span class="sd">            specifies only the name or names of parameters to be scanned.</span>

<span class="sd">        steps : None, integer, or sequence of integers</span>
<span class="sd">            Number of steps to take within the allowed range of the parameter</span>
<span class="sd">            (or parameters). Value(s) specified for `steps` must be &gt;= 2. Note</span>
<span class="sd">            that the endpoints of the range are always included, and numbers of</span>
<span class="sd">            steps higher than 2 fill in between the endpoints.</span>

<span class="sd">            * If integer...</span>
<span class="sd">                  Take this many steps for each specified parameter.</span>
<span class="sd">            * If sequence of integers...</span>
<span class="sd">                  Take the coresponding number of steps within the allowed range</span>
<span class="sd">                  for each specified parameter.</span>

<span class="sd">        values : None, scalar, sequence of scalars, or sequence-of-sequences</span>
<span class="sd">          * If scalar...</span>
<span class="sd">                Set this value for the (one) param name in `param_names`.</span>
<span class="sd">          * If sequence of scalars...</span>
<span class="sd">              * if len(param_names) is 1, set its value to each number in the</span>
<span class="sd">                sequence.</span>
<span class="sd">              * otherwise, set each param in param_names to the corresponding</span>
<span class="sd">                value in `values`. There must be the same number of param names</span>
<span class="sd">                as values.</span>
<span class="sd">          * If sequence of (sequences or iterables)...</span>
<span class="sd">              * Each param name corresponds to one of the inner sequences, in</span>
<span class="sd">                the order that the param names are specified.</span>
<span class="sd">              * If `outer` is False, all inner sequences must have the same</span>
<span class="sd">                length, and there will be one distribution generated for</span>
<span class="sd">                each set of values across the inner sequences. In other words,</span>
<span class="sd">                there will be a total of len(inner sequence) distribution generated.</span>
<span class="sd">              * If `outer` is True, the lengths of inner sequences needn&#39;t be</span>
<span class="sd">                the same. This takes the outer product of the passed sequences</span>
<span class="sd">                to arrive at the permutations of the parameter values that will</span>
<span class="sd">                be used to produce the distributions (essentially nested</span>
<span class="sd">                loops over each parameter). E.g., if two params are scanned,</span>
<span class="sd">                for each value of the first param&#39;s inner sequence, a</span>
<span class="sd">                distribution is produced for every value of the second param&#39;s</span>
<span class="sd">                inner sequence. In total, there will be</span>
<span class="sd">                ``len(inner seq0) * len(inner seq1) * ...``</span>
<span class="sd">                distributions produced.</span>

<span class="sd">        only_points : None, integer, or even-length sequence of integers</span>
<span class="sd">            Only select subset of points to be analysed by specifying their</span>
<span class="sd">            range of positions within the whole set (0-indexed, incremental).</span>
<span class="sd">            For the lazy amongst us...</span>

<span class="sd">        outer : bool</span>
<span class="sd">            If set to True and a sequence of sequences is passed for `values`,</span>
<span class="sd">            the points scanned are the *outer product* of the inner sequences.</span>
<span class="sd">            See `values` for a more detailed explanation.</span>

<span class="sd">        profile : bool</span>
<span class="sd">            If set to True, minimizes specified metric over all free parameters</span>
<span class="sd">            at each scanned point. Otherwise keeps them at their nominal values</span>
<span class="sd">            and only performs grid scan of the parameters specified in</span>
<span class="sd">            `param_names`.</span>

<span class="sd">        minimizer_settings : dict</span>
<span class="sd">            Dictionary containing the settings for minimization, which are</span>
<span class="sd">            only needed if `profile` is set to True. Hint: it has proven useful</span>
<span class="sd">            to sprinkle with a healthy dose of scepticism.</span>

<span class="sd">        outfile : string</span>
<span class="sd">            Outfile to store results to. Will be updated at each scan step to</span>
<span class="sd">            write out intermediate results to prevent loss of data in case</span>
<span class="sd">            the apocalypse strikes after all.</span>

<span class="sd">        debug_mode : int, either one of [0, 1, 2]</span>
<span class="sd">            If set to 2, will add a wealth of minimisation history and physics</span>
<span class="sd">            information to the output file. Otherwise, the output will contain</span>
<span class="sd">            the essentials to perform an analysis (0), or will hopefully be</span>
<span class="sd">            detailed enough for some simple debugging (1). Any other value for</span>
<span class="sd">            `debug_mode` will be set to 2.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">debug_mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">debug_mode</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="c1"># Either `steps` or `values` must be specified, but not both (xor)</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">steps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param_names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">param_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">param_names</span><span class="p">]</span>

        <span class="n">nparams</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">param_names</span><span class="p">)</span>
        <span class="n">hypo_maker</span><span class="o">.</span><span class="n">select_params</span><span class="p">(</span><span class="n">hypo_param_selections</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">values</span><span class="p">])</span>
                <span class="k">assert</span> <span class="n">nparams</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
                    <span class="c1"># no scalar here, need a corresponding parameter name</span>
                    <span class="k">assert</span> <span class="n">nparams</span> <span class="o">&gt;=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># a scalar, can either have only one parameter or at least</span>
                    <span class="c1"># this many</span>
                    <span class="k">assert</span> <span class="n">nparams</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">nparams</span> <span class="o">&gt;=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
                    <span class="k">if</span> <span class="n">nparams</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">val</span><span class="p">])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">ranges</span> <span class="o">=</span> <span class="p">[</span><span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">pname</span><span class="p">]</span><span class="o">.</span><span class="n">range</span> <span class="k">for</span> <span class="n">pname</span> <span class="ow">in</span> <span class="n">param_names</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">steps</span><span class="p">),</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">assert</span> <span class="n">steps</span> <span class="o">&gt;=</span> <span class="mi">2</span>
                <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">steps</span><span class="p">)</span><span class="o">*</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">units</span>
                          <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">ranges</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span> <span class="o">==</span> <span class="n">nparams</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">steps</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">units</span>
                          <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ranges</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">nparams</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">steplist</span> <span class="o">=</span> <span class="p">[[(</span><span class="n">pname</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">values</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pname</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">param_names</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">steplist</span> <span class="o">=</span> <span class="p">[[(</span><span class="n">param_names</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>

        <span class="c1">#Number of steps must be &gt; 0</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">steplist</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="n">points_acc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">only_points</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">only_points</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">only_points</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">only_points</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">points_acc</span> <span class="o">=</span> <span class="n">only_points</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">only_points</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="n">points_acc</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">only_points</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">only_points</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
                <span class="p">)</span>

        <span class="c1"># Instead of introducing another multitude of tests above, check here</span>
        <span class="c1"># whether the lists of steps all have the same length in case `outer`</span>
        <span class="c1"># is set to False</span>
        <span class="k">if</span> <span class="n">nparams</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">outer</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">steplist</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">steps</span> <span class="ow">in</span> <span class="n">steplist</span><span class="p">)</span>
            <span class="n">loopfunc</span> <span class="o">=</span> <span class="nb">zip</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># With single parameter, can use either `zip` or `product`</span>
            <span class="n">loopfunc</span> <span class="o">=</span> <span class="n">product</span>

        <span class="n">params</span> <span class="o">=</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span>

        <span class="c1"># Fix the parameters to be scanned if `profile` is set to True</span>
        <span class="n">params</span><span class="o">.</span><span class="n">fix</span><span class="p">(</span><span class="n">param_names</span><span class="p">)</span>

        <span class="n">results</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;steps&#39;</span><span class="p">:</span> <span class="p">{},</span> <span class="s1">&#39;results&#39;</span><span class="p">:</span> <span class="p">[]}</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;steps&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">pname</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">pname</span> <span class="ow">in</span> <span class="n">param_names</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">loopfunc</span><span class="p">(</span><span class="o">*</span><span class="n">steplist</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">points_acc</span> <span class="ow">and</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">points_acc</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">pname</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="ow">in</span> <span class="n">pos</span><span class="p">:</span>
                <span class="n">params</span><span class="p">[</span><span class="n">pname</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">val</span>
                <span class="n">results</span><span class="p">[</span><span class="s1">&#39;steps&#39;</span><span class="p">][</span><span class="n">pname</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> = </span><span class="si">%.2f</span><span class="s1"> &#39;</span><span class="o">%</span><span class="p">(</span><span class="n">pname</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">ureg</span><span class="o">.</span><span class="n">Quantity</span><span class="p">):</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> = </span><span class="si">%.2f</span><span class="s1"> &#39;</span><span class="o">%</span><span class="p">(</span><span class="n">pname</span><span class="p">,</span> <span class="n">val</span><span class="o">.</span><span class="n">magnitude</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;val is of type </span><span class="si">%s</span><span class="s2"> which I don&#39;t know &quot;</span>
                                    <span class="s2">&quot;how to deal with in the output &quot;</span>
                                    <span class="s2">&quot;messages.&quot;</span><span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Working on point &#39;</span> <span class="o">+</span> <span class="n">msg</span><span class="p">)</span>
            <span class="n">hypo_maker</span><span class="o">.</span><span class="n">update_params</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>

            <span class="c1"># TODO: consistent treatment of hypo_param_selections and scanning</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">profile</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">hypo_maker</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Not optimizing since `profile` set to False or&#39;</span>
                             <span class="s1">&#39; no free parameters found...&#39;</span><span class="p">)</span>
                <span class="n">best_fit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nofit_hypo</span><span class="p">(</span>
                    <span class="n">data_dist</span><span class="o">=</span><span class="n">data_dist</span><span class="p">,</span>
                    <span class="n">hypo_maker</span><span class="o">=</span><span class="n">hypo_maker</span><span class="p">,</span>
                    <span class="n">hypo_param_selections</span><span class="o">=</span><span class="n">hypo_param_selections</span><span class="p">,</span>
                    <span class="n">hypo_asimov_dist</span><span class="o">=</span><span class="n">hypo_maker</span><span class="o">.</span><span class="n">get_outputs</span><span class="p">(</span><span class="n">return_sum</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                    <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span>
                    <span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;pprint&quot;</span><span class="p">,</span><span class="s2">&quot;reset_free&quot;</span><span class="p">,</span><span class="s2">&quot;check_octant&quot;</span><span class="p">]}</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Starting optimization since `profile` requested.&#39;</span><span class="p">)</span>
                <span class="n">best_fit</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_hypo</span><span class="p">(</span>
                    <span class="n">data_dist</span><span class="o">=</span><span class="n">data_dist</span><span class="p">,</span>
                    <span class="n">hypo_maker</span><span class="o">=</span><span class="n">hypo_maker</span><span class="p">,</span>
                    <span class="n">hypo_param_selections</span><span class="o">=</span><span class="n">hypo_param_selections</span><span class="p">,</span>
                    <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">,</span>
                    <span class="n">minimizer_settings</span><span class="o">=</span><span class="n">minimizer_settings</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span>
                <span class="p">)</span>
                <span class="c1"># TODO: serialisation!</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">best_fit</span><span class="o">.</span><span class="n">minimizer_metadata</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;hess&#39;</span><span class="p">,</span> <span class="s1">&#39;hess_inv&#39;</span><span class="p">]:</span>
                        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;deleting </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                        <span class="k">del</span> <span class="n">best_fit</span><span class="o">.</span><span class="n">minimizer_metadata</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

            <span class="n">best_fit</span><span class="o">.</span><span class="n">metric_val</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span>
                <span class="n">best_fit</span><span class="o">.</span><span class="n">metric_val</span><span class="o">.</span><span class="n">serializable_state</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">best_fit</span><span class="o">.</span><span class="n">hypo_asimov_dist</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
                <span class="n">best_fit</span><span class="o">.</span><span class="n">hypo_asimov_dist</span> <span class="o">=</span> <span class="p">[</span><span class="n">deepcopy</span><span class="p">(</span>
                    <span class="n">best_fit</span><span class="o">.</span><span class="n">hypo_asimov_dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">serializable_state</span>
                <span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">best_fit</span><span class="o">.</span><span class="n">hypo_asimov_dist</span><span class="p">))]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">best_fit</span><span class="o">.</span><span class="n">hypo_asimov_dist</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span>
                    <span class="n">best_fit</span><span class="o">.</span><span class="n">hypo_asimov_dist</span><span class="o">.</span><span class="n">serializable_state</span>
                <span class="p">)</span>

            <span class="c1"># decide which information to retain based on chosen debug mode</span>
            <span class="k">if</span> <span class="n">debug_mode</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">debug_mode</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">best_fit</span><span class="p">[</span><span class="s1">&#39;fit_history&#39;</span><span class="p">]</span>
                    <span class="k">del</span> <span class="n">best_fit</span><span class="o">.</span><span class="n">hypo_asimov_dist</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">pass</span>

            <span class="k">if</span> <span class="n">debug_mode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># torch the woods!</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">best_fit</span><span class="o">.</span><span class="n">minimizer_metadata</span>
                    <span class="k">del</span> <span class="n">best_fit</span><span class="o">.</span><span class="n">minimizer_time</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">pass</span>

            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;results&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">best_fit</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">outfile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># store intermediate results</span>
                <span class="n">to_file</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">outfile</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span></div>
</div>


<span class="k">def</span> <span class="nf">test_basic_analysis</span><span class="p">(</span><span class="n">pprint</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Test recursive fit strategies with BasicAnalysis.&quot;&quot;&quot;</span>


    <span class="kn">from</span> <span class="nn">pisa.core.distribution_maker</span> <span class="kn">import</span> <span class="n">DistributionMaker</span>
    <span class="kn">from</span> <span class="nn">pisa.utils.config_parser</span> <span class="kn">import</span> <span class="n">parse_pipeline_config</span>

    <span class="c1">###### Make Pipeline Configuration #########</span>
    <span class="c1">#  We make a configuration of two pipelines where some, but not all, parameters</span>
    <span class="c1">#  are shared between them. This checks for memory inconsistencies.</span>
    <span class="n">config</span> <span class="o">=</span> <span class="n">parse_pipeline_config</span><span class="p">(</span><span class="s1">&#39;settings/pipeline/fast_example.cfg&#39;</span><span class="p">)</span>
    <span class="n">config2</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
    <span class="c1"># Remove one stage to remove some parameters from only one pipeline</span>
    <span class="k">del</span> <span class="n">config2</span><span class="p">[(</span><span class="s2">&quot;aeff&quot;</span><span class="p">,</span> <span class="s2">&quot;aeff&quot;</span><span class="p">)]</span>

    <span class="n">dm</span> <span class="o">=</span> <span class="n">DistributionMaker</span><span class="p">([</span><span class="n">config</span><span class="p">,</span> <span class="n">config2</span><span class="p">])</span>
    <span class="n">dm</span><span class="o">.</span><span class="n">select_params</span><span class="p">(</span><span class="s1">&#39;nh&#39;</span><span class="p">)</span>

    <span class="n">dm</span><span class="o">.</span><span class="n">pipelines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;aeff_scale&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mf">1.5</span>
    <span class="c1"># make data distribution to fit against</span>
    <span class="n">data_dist</span> <span class="o">=</span> <span class="n">dm</span><span class="o">.</span><span class="n">get_outputs</span><span class="p">(</span><span class="n">return_sum</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">fluctuate</span><span class="p">(</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;poisson&quot;</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span>
    <span class="p">)</span>

    <span class="c1">#### Test subclassing</span>
    <span class="c1"># It should be trivial to add a fit method to the BasicAnalysis class and use</span>
    <span class="c1"># it by passing its name (without the &quot;_fit_&quot; prefix) to the dictionary.</span>
    <span class="k">class</span> <span class="nc">SubclassedAnalysis</span><span class="p">(</span><span class="n">BasicAnalysis</span><span class="p">):</span>

        <span class="k">def</span> <span class="nf">_fit_nonsense</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">data_dist</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span>
            <span class="n">external_priors_penalty</span><span class="p">,</span> <span class="n">method_kwargs</span><span class="p">,</span> <span class="n">local_fit_kwargs</span>
        <span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;A custom, nonsensical fit method.</span>

<span class="sd">            This method does nothing except to set theta23 to 42 deg for no reason.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Starting nonsense fit (setting theta23 to 42 deg)...&quot;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">pipeline</span> <span class="ow">in</span> <span class="n">hypo_maker</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;theta23&quot;</span> <span class="ow">in</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                    <span class="n">pipeline</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">theta23</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">42</span> <span class="o">*</span> <span class="n">ureg</span><span class="p">[</span><span class="s2">&quot;deg&quot;</span><span class="p">]</span>

            <span class="n">best_fit_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_recursively</span><span class="p">(</span>
                <span class="n">data_dist</span><span class="p">,</span> <span class="n">hypo_maker</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">external_priors_penalty</span><span class="p">,</span>
                <span class="n">local_fit_kwargs</span><span class="p">[</span><span class="s2">&quot;method&quot;</span><span class="p">],</span> <span class="n">local_fit_kwargs</span><span class="p">[</span><span class="s2">&quot;method_kwargs&quot;</span><span class="p">],</span>
                <span class="n">local_fit_kwargs</span><span class="p">[</span><span class="s2">&quot;local_fit_kwargs&quot;</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="k">return</span> <span class="n">best_fit_info</span>

    <span class="n">ana</span> <span class="o">=</span> <span class="n">SubclassedAnalysis</span><span class="p">()</span>

    <span class="n">ana</span><span class="o">.</span><span class="n">pprint</span> <span class="o">=</span> <span class="n">pprint</span>

    <span class="c1"># Test that global optimization with CRS2 is deterministic as long as a seed</span>
    <span class="c1"># is provided.</span>

    <span class="n">fit_nlopt_crs2</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nlopt&quot;</span><span class="p">,</span>
        <span class="n">method_kwargs</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;algorithm&quot;</span><span class="p">:</span> <span class="s2">&quot;NLOPT_GN_CRS2_LM&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ftol_rel&quot;</span><span class="p">:</span> <span class="mf">1e-1</span><span class="p">,</span>
            <span class="s2">&quot;ftol_abs&quot;</span><span class="p">:</span> <span class="mf">1e-1</span><span class="p">,</span>
            <span class="s2">&quot;population&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s2">&quot;maxeval&quot;</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
            <span class="s2">&quot;seed&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">local_fit_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">dm</span><span class="o">.</span><span class="n">reset_free</span><span class="p">()</span>
    <span class="n">best_fit_info_seed_0</span> <span class="o">=</span> <span class="n">ana</span><span class="o">.</span><span class="n">fit_recursively</span><span class="p">(</span>
        <span class="n">data_dist</span><span class="p">,</span>
        <span class="n">dm</span><span class="p">,</span>
        <span class="s2">&quot;chi2&quot;</span><span class="p">,</span>
        <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">fit_nlopt_crs2</span>
    <span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Best fit params with seed 0:&quot;</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">best_fit_info_seed_0</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="p">))</span>

    <span class="n">fit_nlopt_crs2</span><span class="p">[</span><span class="s2">&quot;method_kwargs&quot;</span><span class="p">][</span><span class="s2">&quot;seed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">dm</span><span class="o">.</span><span class="n">reset_free</span><span class="p">()</span>
    <span class="n">best_fit_info_seed_1</span> <span class="o">=</span> <span class="n">ana</span><span class="o">.</span><span class="n">fit_recursively</span><span class="p">(</span>
        <span class="n">data_dist</span><span class="p">,</span>
        <span class="n">dm</span><span class="p">,</span>
        <span class="s2">&quot;chi2&quot;</span><span class="p">,</span>
        <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">fit_nlopt_crs2</span>
    <span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Best fit params with seed 1:&quot;</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">best_fit_info_seed_1</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="p">))</span>

    <span class="n">fit_nlopt_crs2</span><span class="p">[</span><span class="s2">&quot;method_kwargs&quot;</span><span class="p">][</span><span class="s2">&quot;seed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">dm</span><span class="o">.</span><span class="n">reset_free</span><span class="p">()</span>
    <span class="n">best_fit_info_seed_0_reprod</span> <span class="o">=</span> <span class="n">ana</span><span class="o">.</span><span class="n">fit_recursively</span><span class="p">(</span>
        <span class="n">data_dist</span><span class="p">,</span>
        <span class="n">dm</span><span class="p">,</span>
        <span class="s2">&quot;chi2&quot;</span><span class="p">,</span>
        <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">fit_nlopt_crs2</span>
    <span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Best fit params with seed 0, reproduced:&quot;</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">best_fit_info_seed_0_reprod</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">free</span><span class="p">))</span>

    <span class="k">assert</span> <span class="n">best_fit_info_seed_0</span><span class="o">.</span><span class="n">params</span> <span class="o">==</span> <span class="n">best_fit_info_seed_0_reprod</span><span class="o">.</span><span class="n">params</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="n">best_fit_info_seed_0</span><span class="o">.</span><span class="n">params</span> <span class="o">==</span> <span class="n">best_fit_info_seed_1</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>

    <span class="n">scipy_settings</span> <span class="o">=</span> <span class="p">{</span>
      <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="s2">&quot;L-BFGS-B&quot;</span><span class="p">,</span>
        <span class="s2">&quot;desc&quot;</span><span class="p">:</span> <span class="s2">&quot;The string to pass to scipy.optimize.minimize so it knows what to use&quot;</span>
      <span class="p">},</span>
      <span class="s2">&quot;options&quot;</span><span class="p">:{</span>
        <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="p">{</span>
          <span class="s2">&quot;disp&quot;</span>   <span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
          <span class="s2">&quot;ftol&quot;</span>   <span class="p">:</span> <span class="mf">1.0e-1</span><span class="p">,</span>
          <span class="s2">&quot;eps&quot;</span>    <span class="p">:</span> <span class="mf">1.0e-6</span><span class="p">,</span>
          <span class="c1"># we set a very low number of iterations so that this test exits early</span>
          <span class="c1"># WILL CAUSE WARNINGS SAYING THAT THE OPTIMIZATION FAILED, BUT THAT IS OK!</span>
          <span class="c1">#&quot;maxiter&quot;: 2</span>
        <span class="p">},</span>
        <span class="s2">&quot;desc&quot;</span><span class="p">:</span> <span class="p">{</span>
          <span class="s2">&quot;disp&quot;</span>   <span class="p">:</span> <span class="s2">&quot;Set to True to print convergence messages&quot;</span><span class="p">,</span>
          <span class="s2">&quot;ftol&quot;</span>   <span class="p">:</span> <span class="s2">&quot;Precision goal for the value of f in the stopping criterion&quot;</span><span class="p">,</span>
          <span class="s2">&quot;eps&quot;</span>    <span class="p">:</span> <span class="s2">&quot;Step size used for numerical approximation of the jacobian.&quot;</span><span class="p">,</span>
          <span class="s2">&quot;maxiter&quot;</span><span class="p">:</span> <span class="s2">&quot;Maximum number of iteration&quot;</span>
        <span class="p">}</span>
      <span class="p">},</span>
    <span class="p">}</span>

    <span class="c1">###### Fit strategy to test ########</span>
    <span class="c1"># This is a ridiculously complex fit strategy for a simple std. osc. fit</span>
    <span class="c1"># that no one would use in real life, just to test the fit functions.</span>
    <span class="c1"># Staged fit in two stages:</span>
    <span class="c1"># 1. Best of:</span>
    <span class="c1">#     --&gt; local fit using Simplex from NLOPT on a 2x1 grid</span>
    <span class="c1">#     --&gt; local fit using Migrad from Minuit</span>
    <span class="c1"># 2.  --&gt; for each range in deltam31:</span>
    <span class="c1">#         |--&gt; starting from the best fit point found by local fit, shifted to range</span>
    <span class="c1">#             |--&gt; fit with octant reflection, where internal fit is scipy</span>

    <span class="n">local_simplex</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nlopt&quot;</span><span class="p">,</span>
        <span class="n">method_kwargs</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;algorithm&quot;</span><span class="p">:</span> <span class="s2">&quot;NLOPT_LN_NELDERMEAD&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ftol_rel&quot;</span><span class="p">:</span> <span class="mf">1e-1</span><span class="p">,</span>
            <span class="s2">&quot;ftol_abs&quot;</span><span class="p">:</span> <span class="mf">1e-1</span><span class="p">,</span>
            <span class="s2">&quot;maxeval&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
            <span class="s2">&quot;initial_step&quot;</span><span class="p">:</span> <span class="mf">0.2</span>  <span class="c1"># as a fraction of the total range</span>
        <span class="p">},</span>
        <span class="n">local_fit_kwargs</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">)</span>

    <span class="n">grid_scan</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;grid_scan&quot;</span><span class="p">,</span>
        <span class="n">method_kwargs</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;grid&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;deltam31&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">3e-3</span><span class="p">,</span> <span class="mf">5e-3</span><span class="p">])</span> <span class="o">*</span> <span class="n">ureg</span><span class="p">[</span><span class="s2">&quot;eV^2&quot;</span><span class="p">],</span>
                <span class="s2">&quot;theta23&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">30</span><span class="p">])</span> <span class="o">*</span> <span class="n">ureg</span><span class="p">[</span><span class="s2">&quot;deg&quot;</span><span class="p">]</span>
            <span class="p">},</span>
            <span class="s2">&quot;refined_fit&quot;</span><span class="p">:</span> <span class="n">local_simplex</span>
        <span class="p">},</span>
        <span class="n">local_fit_kwargs</span><span class="o">=</span><span class="n">local_simplex</span>
    <span class="p">)</span>

    <span class="n">local_minuit</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;iminuit&quot;</span><span class="p">,</span>
        <span class="n">method_kwargs</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;tol&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">local_fit_kwargs</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">)</span>

    <span class="n">local_nonsense_minuit</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nonsense&quot;</span><span class="p">,</span>
        <span class="n">method_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">local_fit_kwargs</span><span class="o">=</span><span class="n">local_minuit</span>
    <span class="p">)</span>

    <span class="n">best_of</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;best_of&quot;</span><span class="p">,</span>
        <span class="n">method_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">local_fit_kwargs</span><span class="o">=</span><span class="p">[</span>
            <span class="n">local_nonsense_minuit</span><span class="p">,</span>
            <span class="n">grid_scan</span>
        <span class="p">]</span>
    <span class="p">)</span>

    <span class="c1"># a standard analysis strategy with an octant flip at 45 deg in theta23</span>
    <span class="n">standard_analysis</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;fit_octants&quot;</span><span class="p">,</span>
        <span class="n">method_kwargs</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;angle&quot;</span><span class="p">:</span> <span class="s2">&quot;theta23&quot;</span><span class="p">,</span>
            <span class="s2">&quot;inflection_point&quot;</span><span class="p">:</span> <span class="mi">45</span> <span class="o">*</span> <span class="n">ureg</span><span class="o">.</span><span class="n">deg</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">local_fit_kwargs</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="s2">&quot;scipy&quot;</span><span class="p">,</span>
            <span class="s2">&quot;method_kwargs&quot;</span><span class="p">:</span> <span class="n">scipy_settings</span><span class="p">,</span>
            <span class="s2">&quot;local_fit_kwargs&quot;</span><span class="p">:</span> <span class="kc">None</span>
        <span class="p">}</span>
    <span class="p">)</span>

    <span class="c1"># fit different ranges in mass splitting, and to the octant fits in each range</span>
    <span class="n">fit_in_ranges</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;fit_ranges&quot;</span><span class="p">,</span>
        <span class="n">method_kwargs</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;param_name&quot;</span><span class="p">:</span> <span class="s2">&quot;deltam31&quot;</span><span class="p">,</span>
            <span class="s2">&quot;ranges&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.004</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.004</span><span class="p">,</span> <span class="mf">0.007</span><span class="p">]])</span> <span class="o">*</span> <span class="n">ureg</span><span class="p">[</span><span class="s2">&quot;eV^2&quot;</span><span class="p">],</span>
            <span class="s2">&quot;reset_free&quot;</span><span class="p">:</span> <span class="kc">True</span>
        <span class="p">},</span>
        <span class="n">local_fit_kwargs</span><span class="o">=</span><span class="n">standard_analysis</span>
    <span class="p">)</span>

    <span class="c1"># put together the full fit strategy</span>
    <span class="n">staged_fit</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;staged&quot;</span><span class="p">,</span>
        <span class="n">method_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">local_fit_kwargs</span><span class="o">=</span><span class="p">[</span>
            <span class="n">best_of</span><span class="p">,</span>
            <span class="n">fit_in_ranges</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="c1"># changing the parameter values in theta23 such that the fits starts offset from</span>
    <span class="c1"># the truth</span>
    <span class="c1"># use this opportunity to test the update_param_values function as well</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">dm</span><span class="o">.</span><span class="n">pipelines</span><span class="p">:</span>
        <span class="n">p</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">deltam31</span><span class="o">.</span><span class="n">is_fixed</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">mod_th23</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">dm</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">theta23</span><span class="p">)</span>
    <span class="n">mod_th23</span><span class="o">.</span><span class="n">range</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">*</span> <span class="n">ureg</span><span class="o">.</span><span class="n">deg</span><span class="p">,</span> <span class="mi">90</span> <span class="o">*</span><span class="n">ureg</span><span class="o">.</span><span class="n">deg</span><span class="p">)</span>
    <span class="n">mod_th23</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="mi">30</span> <span class="o">*</span> <span class="n">ureg</span><span class="o">.</span><span class="n">deg</span>
    <span class="n">mod_th23</span><span class="o">.</span><span class="n">nominal_value</span> <span class="o">=</span> <span class="mi">30</span> <span class="o">*</span> <span class="n">ureg</span><span class="o">.</span><span class="n">deg</span>

    <span class="n">update_param_values</span><span class="p">(</span><span class="n">dm</span><span class="p">,</span> <span class="n">mod_th23</span><span class="p">,</span> <span class="n">update_nominal_values</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">update_range</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># make sure that the parameter values inside the ParamSelector were changed and</span>
    <span class="c1"># will not be overwritten by a call to `select_params`</span>
    <span class="n">mod_params</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">dm</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
    <span class="n">dm</span><span class="o">.</span><span class="n">select_params</span><span class="p">(</span><span class="s1">&#39;nh&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">mod_params</span> <span class="o">==</span> <span class="n">dm</span><span class="o">.</span><span class="n">params</span>
    <span class="c1"># test alternative input to `update_param_values` where `hypo_maker` is just a</span>
    <span class="c1"># single Pipeline</span>
    <span class="k">for</span> <span class="n">pipeline</span> <span class="ow">in</span> <span class="n">dm</span><span class="p">:</span>
        <span class="n">update_param_values</span><span class="p">(</span><span class="n">pipeline</span><span class="p">,</span> <span class="n">mod_th23</span><span class="p">)</span>
    <span class="c1"># the call above should just have no effect at all since we set everything to the</span>
    <span class="c1"># same value</span>
    <span class="k">assert</span> <span class="n">mod_params</span> <span class="o">==</span> <span class="n">dm</span><span class="o">.</span><span class="n">params</span>

    <span class="c1"># resetting free parameters should now set theta23 to 30 degrees since that is</span>
    <span class="c1"># the new nominal value</span>
    <span class="n">dm</span><span class="o">.</span><span class="n">reset_free</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">dm</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">theta23</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">m_as</span><span class="p">(</span><span class="s2">&quot;deg&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">30</span>

    <span class="c1"># store all the original ranges and nominal values</span>
    <span class="c1"># --&gt; The fits should never return results where these have changed, even though</span>
    <span class="c1">#     they are sometimes changed within them.</span>
    <span class="n">original_ranges</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">range</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">dm</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
    <span class="n">original_nom_vals</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">nominal_value</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">dm</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>

    <span class="c1"># ACTUALLY RUN THE FIT</span>
    <span class="n">best_fit_info</span> <span class="o">=</span> <span class="n">ana</span><span class="o">.</span><span class="n">fit_recursively</span><span class="p">(</span>
        <span class="n">data_dist</span><span class="p">,</span>
        <span class="n">dm</span><span class="p">,</span>
        <span class="s2">&quot;chi2&quot;</span><span class="p">,</span>
        <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">staged_fit</span>
    <span class="p">)</span>

    <span class="k">assert</span> <span class="n">dm</span><span class="o">.</span><span class="n">params</span> <span class="o">==</span> <span class="n">best_fit_info</span><span class="o">.</span><span class="n">params</span>
    <span class="c1"># there had been problems in the past where the range of the parameter that is</span>
    <span class="c1"># changed by the octant flip was not reversed properly</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">dm</span><span class="o">.</span><span class="n">params</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;mismatch in param </span><span class="si">{</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">:</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;range is </span><span class="si">{</span><span class="n">p</span><span class="o">.</span><span class="n">range</span><span class="si">}</span><span class="s2">, should be </span><span class="si">{</span><span class="n">original_ranges</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;nom. value is </span><span class="si">{</span><span class="n">p</span><span class="o">.</span><span class="n">nominal_value</span><span class="si">}</span><span class="s2">, should be </span><span class="si">{</span><span class="n">original_nom_vals</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">p</span><span class="o">.</span><span class="n">range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">original_ranges</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">msg</span>
            <span class="k">assert</span> <span class="n">p</span><span class="o">.</span><span class="n">range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">original_ranges</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">msg</span>
        <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">nominal_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">p</span><span class="o">.</span><span class="n">nominal_value</span> <span class="o">==</span> <span class="n">original_nom_vals</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">],</span> <span class="n">msg</span>

    <span class="c1"># Here we make sure that making a param selection doesn&#39;t overwrite the fitted</span>
    <span class="c1"># parameters. The Analysis should have changed the parameters inside the</span>
    <span class="c1"># ParamSelector.</span>
    <span class="n">dm</span><span class="o">.</span><span class="n">select_params</span><span class="p">(</span><span class="s1">&#39;nh&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">dm</span><span class="o">.</span><span class="n">params</span> <span class="o">==</span> <span class="n">best_fit_info</span><span class="o">.</span><span class="n">params</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">dm</span><span class="o">.</span><span class="n">params</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;mismatch in param </span><span class="si">{</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">:</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;range is </span><span class="si">{</span><span class="n">p</span><span class="o">.</span><span class="n">range</span><span class="si">}</span><span class="s2">, should be </span><span class="si">{</span><span class="n">original_ranges</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;nom. value is </span><span class="si">{</span><span class="n">p</span><span class="o">.</span><span class="n">nominal_value</span><span class="si">}</span><span class="s2">, should be </span><span class="si">{</span><span class="n">original_nom_vals</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">p</span><span class="o">.</span><span class="n">range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">original_ranges</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">msg</span>
            <span class="k">assert</span> <span class="n">p</span><span class="o">.</span><span class="n">range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">original_ranges</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">msg</span>
        <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">nominal_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">p</span><span class="o">.</span><span class="n">nominal_value</span> <span class="o">==</span> <span class="n">original_nom_vals</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">],</span> <span class="n">msg</span>

    <span class="n">dm</span><span class="o">.</span><span class="n">select_params</span><span class="p">(</span><span class="s1">&#39;ih&#39;</span><span class="p">)</span>
    <span class="n">dm</span><span class="o">.</span><span class="n">select_params</span><span class="p">(</span><span class="s1">&#39;nh&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">dm</span><span class="o">.</span><span class="n">params</span> <span class="o">==</span> <span class="n">best_fit_info</span><span class="o">.</span><span class="n">params</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">dm</span><span class="o">.</span><span class="n">params</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;mismatch in param </span><span class="si">{</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">:</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;range is </span><span class="si">{</span><span class="n">p</span><span class="o">.</span><span class="n">range</span><span class="si">}</span><span class="s2">, should be </span><span class="si">{</span><span class="n">original_ranges</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;nom. value is </span><span class="si">{</span><span class="n">p</span><span class="o">.</span><span class="n">nominal_value</span><span class="si">}</span><span class="s2">, should be </span><span class="si">{</span><span class="n">original_nom_vals</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">p</span><span class="o">.</span><span class="n">range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">original_ranges</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">msg</span>
            <span class="k">assert</span> <span class="n">p</span><span class="o">.</span><span class="n">range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">original_ranges</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">msg</span>
        <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">nominal_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">p</span><span class="o">.</span><span class="n">nominal_value</span> <span class="o">==</span> <span class="n">original_nom_vals</span><span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">],</span> <span class="n">msg</span>

    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;&lt;&lt; PASS : test_basic_analysis &gt;&gt;&#39;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">set_verbosity</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">test_basic_analysis</span><span class="p">(</span><span class="n">pprint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, The IceCube/PINGU Collaboration.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>