<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pisa.core.binning &mdash; PISA 4.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=9f5556dd"></script>
        <script src="../../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            PISA
          </a>
              <div class="version">
                4.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">API reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">PISA</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">pisa.core.binning</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pisa.core.binning</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Class to define binning in one dimension (OneDimBinning) and then a container</span>
<span class="sd">class (MultiDimBinning) for arbitrarily many of dimensions (one or more). These</span>
<span class="sd">classes have many useful methods for working with binning.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># TODO: include Iterables where only Sequence is allowed now?</span>
<span class="c1"># TODO: iterbins, itercoords are _*slow*_. Figure out how to speed these up, if</span>
<span class="c1">#       that is possible in pure-Python loops... E.g.</span>
<span class="c1">#           `indices = [i for i in range(mdb.size)]`</span>
<span class="c1">#       takes 70 ms while</span>
<span class="c1">#           `coords = [c for c in mdb.itercoords()]`</span>
<span class="c1">#       takes 10 seconds.</span>
<span class="c1"># TODO: Create non-validated version of OneDimBinning.__init__ to make</span>
<span class="c1">#       iterbins() fast</span>
<span class="c1"># TODO: explicitly set is_bin_spacing_log_uniform and</span>
<span class="c1">#       is_bin_spacing_lin_uniform to FP32 precision (since binning can be</span>
<span class="c1">#       defined/saved in FP32 but want code able to run in FP64</span>


<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Sequence</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span><span class="p">,</span> <span class="n">namedtuple</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span><span class="p">,</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">reduce</span><span class="p">,</span> <span class="n">wraps</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span><span class="p">,</span> <span class="n">product</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">mul</span>
<span class="kn">import</span> <span class="nn">re</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">pisa</span> <span class="kn">import</span> <span class="n">FTYPE</span><span class="p">,</span> <span class="n">HASH_SIGFIGS</span><span class="p">,</span> <span class="n">ureg</span>
<span class="kn">from</span> <span class="nn">pisa.utils.comparisons</span> <span class="kn">import</span> <span class="n">interpret_quantity</span><span class="p">,</span> <span class="n">normQuant</span><span class="p">,</span> <span class="n">recursiveEquality</span>
<span class="kn">from</span> <span class="nn">pisa.utils.comparisons</span> <span class="kn">import</span> <span class="n">ALLCLOSE_KW</span>
<span class="kn">from</span> <span class="nn">pisa.utils.format</span> <span class="kn">import</span> <span class="p">(</span><span class="n">make_valid_python_name</span><span class="p">,</span> <span class="n">text2tex</span><span class="p">,</span>
                               <span class="n">strip_outer_dollars</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">pisa.utils.hash</span> <span class="kn">import</span> <span class="n">hash_obj</span>
<span class="kn">from</span> <span class="nn">pisa.utils</span> <span class="kn">import</span> <span class="n">jsons</span>
<span class="kn">from</span> <span class="nn">pisa.utils.log</span> <span class="kn">import</span> <span class="n">logging</span><span class="p">,</span> <span class="n">set_verbosity</span><span class="p">,</span> <span class="n">tprofile</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;NAME_FIXES&#39;</span><span class="p">,</span> <span class="s1">&#39;NAME_SEPCHARS&#39;</span><span class="p">,</span> <span class="s1">&#39;NAME_FIXES_REGEXES&#39;</span><span class="p">,</span>
           <span class="s1">&#39;basename&#39;</span><span class="p">,</span> <span class="s1">&#39;_new_obj&#39;</span><span class="p">,</span> <span class="s1">&#39;is_binning&#39;</span><span class="p">,</span>
           <span class="s1">&#39;OneDimBinning&#39;</span><span class="p">,</span> <span class="s1">&#39;MultiDimBinning&#39;</span><span class="p">,</span>
           <span class="s1">&#39;test_OneDimBinning&#39;</span><span class="p">,</span> <span class="s1">&#39;test_MultiDimBinning&#39;</span><span class="p">]</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s1">&#39;J.L. Lanfranchi&#39;</span>

<span class="n">__license__</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;Copyright (c) 2014-2017, The IceCube Collaboration</span>

<span class="s1"> Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s1"> you may not use this file except in compliance with the License.</span>
<span class="s1"> You may obtain a copy of the License at</span>

<span class="s1">   http://www.apache.org/licenses/LICENSE-2.0</span>

<span class="s1"> Unless required by applicable law or agreed to in writing, software</span>
<span class="s1"> distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s1"> WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s1"> See the License for the specific language governing permissions and</span>
<span class="s1"> limitations under the License.&#39;&#39;&#39;</span>


<span class="n">NAME_FIXES</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;tru(e|th)&#39;</span><span class="p">,</span> <span class="s1">&#39;reco(nstruct(ed)?)?&#39;</span><span class="p">)</span>
<span class="n">NAME_SEPCHARS</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;[_\s-]+&#39;</span>
<span class="n">NAME_FIXES_REGEXES</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
    <span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">NAME_SEPCHARS</span> <span class="o">+</span> <span class="n">p</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">NAME_FIXES</span><span class="p">]</span>
    <span class="o">+</span> <span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="n">NAME_SEPCHARS</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">NAME_FIXES</span><span class="p">]</span>
    <span class="o">+</span> <span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">IGNORECASE</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">NAME_FIXES</span><span class="p">]</span>
<span class="p">)</span>


<span class="c1"># TODO: move this to a centralized utils location</span>
<div class="viewcode-block" id="basename">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.basename">[docs]</a>
<span class="k">def</span> <span class="nf">basename</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Remove &quot;true&quot; or &quot;reco&quot; prefix(es) and/or suffix(es) from binning</span>
<span class="sd">    name `n` along with any number of possible separator characters.</span>

<span class="sd">    * Valid (pre/suf)fix(es): &quot;true&quot;, &quot;reco&quot;</span>
<span class="sd">    * Valid separator characters: &quot;&lt;whitespace&gt;&quot;, &quot;_&quot;, &quot;-&quot; (any number)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : string or OneDimBinning</span>
<span class="sd">        Name from which to have pre/suffixes stripped.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    basename : string</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; print(basename(&#39;true_energy&#39;))</span>
<span class="sd">    energy</span>
<span class="sd">    &gt;&gt;&gt; print(basename(&#39;Reconstructed coszen&#39;))</span>
<span class="sd">    coszen</span>
<span class="sd">    &gt;&gt;&gt; print(basename(&#39;coszen  reco&#39;))</span>
<span class="sd">    coszen</span>
<span class="sd">    &gt;&gt;&gt; print(basename(&#39;energy___truth&#39;))</span>
<span class="sd">    energy</span>
<span class="sd">    &gt;&gt;&gt; print(basename(&#39;trueenergy&#39;))</span>
<span class="sd">    energy</span>
<span class="sd">    &gt;&gt;&gt; print(basename(&#39;energytruth&#39;))</span>
<span class="sd">    energy</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Type checkingn and conversion</span>
    <span class="n">orig_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">OneDimBinning</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">name</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unhandled type </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="n">orig_type</span><span class="p">)</span>
    <span class="c1"># Remove all (pre/suf)fixes and any separator chars</span>
    <span class="k">for</span> <span class="n">regex</span> <span class="ow">in</span> <span class="n">NAME_FIXES_REGEXES</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">regex</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">n</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span></div>



<div class="viewcode-block" id="is_binning">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.is_binning">[docs]</a>
<span class="k">def</span> <span class="nf">is_binning</span><span class="p">(</span><span class="n">something</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return True if argument is a PISA binning (of any dimension), False</span>
<span class="sd">    otherwise&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">something</span><span class="p">,</span> <span class="p">(</span><span class="n">OneDimBinning</span><span class="p">,</span> <span class="n">MultiDimBinning</span><span class="p">))</span></div>



<span class="c1"># TODO: generalize to any object and move this to a centralized utils location</span>
<span class="k">def</span> <span class="nf">_new_obj</span><span class="p">(</span><span class="n">original_function</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Decorator to deepcopy unaltered states into new OneDimBinning object.&quot;&quot;&quot;</span>
    <span class="nd">@wraps</span><span class="p">(</span><span class="n">original_function</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">new_function</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;&lt;&lt; docstring will be inherited from wrapped function &gt;&gt;&quot;&quot;&quot;</span>
        <span class="n">new_state</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">state_updates</span> <span class="o">=</span> <span class="n">original_function</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_attrs_to_create_new</span><span class="p">:</span>  <span class="c1"># pylint: disable=protected-access</span>
            <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">state_updates</span><span class="p">:</span>
                <span class="n">new_state</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="n">state_updates</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_state</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">OneDimBinning</span><span class="p">(</span><span class="o">**</span><span class="n">new_state</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_function</span>


<div class="viewcode-block" id="OneDimBinning">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.OneDimBinning">[docs]</a>
<span class="k">class</span> <span class="nc">OneDimBinning</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="c1"># pylint: disable=line-too-long</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Histogram-oriented binning specialized to a single dimension.</span>

<span class="sd">    If neither `is_lin` nor `is_log` is specified, linear behavior</span>
<span class="sd">    is assumed (i.e., `is_lin` is set to True).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str, of length &gt; 0</span>
<span class="sd">        Name for this dimension. Must be valid Python name (since it will be</span>
<span class="sd">        accessed with the dot operator). If not, name will be converted to a</span>
<span class="sd">        valid Python name.</span>

<span class="sd">    tex : str or None</span>
<span class="sd">        TeX label for this dimension.</span>

<span class="sd">    bin_edges : sequence of scalars, or None</span>
<span class="sd">        Numerical values (optionally including Pint units) that represent the</span>
<span class="sd">        *edges* of the bins. `bin_edges` needn&#39;t be specified if `domain`,</span>
<span class="sd">        `num_bins`, and optionally `is_log` is specified. Pint units can be</span>
<span class="sd">        attached to `bin_edges`, but will be converted to `units` if this</span>
<span class="sd">        argument is specified.</span>

<span class="sd">    units : Pint unit or object convertible to Pint unit, or None</span>
<span class="sd">        If None, units will be read from either `bin_edges` or `domain`, and if</span>
<span class="sd">        none of these have units, the binning has unit &#39;dimensionless&#39;</span>
<span class="sd">        attached.</span>

<span class="sd">    is_lin : bool or None</span>
<span class="sd">        Binning behavior is linear for purposes of resampling, plotting, etc.</span>
<span class="sd">        Mutually exclusive with `is_log`. If neither `is_lin` or `is_log` is</span>
<span class="sd">        True (i.e., both are None), default behavior is linear (`is_lin` is set</span>
<span class="sd">        to True internally).</span>

<span class="sd">    is_log : bool or None</span>
<span class="sd">        Binning behavior is logarithmic for purposes of resampling, plotting,</span>
<span class="sd">        etc. Mutually exclusive with `is_lin`. If neither `is_lin` or `is_log`</span>
<span class="sd">        is True (i.e., both are None), default behavior is linear (`is_lin` is</span>
<span class="sd">        set to True internally).</span>

<span class="sd">    domain : length-2 sequence of scalars, or None</span>
<span class="sd">        Units may be specified. Required along with `num_bins` if `bin_edges`</span>
<span class="sd">        is not specified (optionally specify `is_log=True` to define the</span>
<span class="sd">        `bin_edges` to be log-uniform).</span>

<span class="sd">    num_bins : int or None</span>
<span class="sd">        Number of bins. Required along with `domain` if `bin_edges` is not</span>
<span class="sd">        specified (optionally specify `is_log=True` to define the `bin_edges`</span>
<span class="sd">        to be log-uniform).</span>

<span class="sd">    bin_names : sequence of nonzero-length strings, or None</span>
<span class="sd">        Strings by which each bin can be identified. This is expected to be</span>
<span class="sd">        useful when one needs to easily identify bins by name where the actual</span>
<span class="sd">        numerical values can be non-obvious e.g. the PID dimension.</span>
<span class="sd">        None is also acceptable if there is no reason to name the bins.</span>


<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Consistency is enforced for all redundant parameters passed to the</span>
<span class="sd">    constructor.</span>

<span class="sd">    You can avoid passing `bin_edges` if `num_bins` and `domain` are specified.</span>
<span class="sd">    Specify `is_lin=True` or `is_log=True` to define the binning to be linear</span>
<span class="sd">    or logarithmic (but note that if neither is specified as True, linear</span>
<span class="sd">    behavior is the default).</span>

<span class="sd">    Be careful, though, since bin edges will be defined slightly differently</span>
<span class="sd">    depending on the ``pisa.FTYPE`` defined (PISA_FTYPE environment variable).</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from pisa import ureg</span>
<span class="sd">    &gt;&gt;&gt; from pisa.core.binning import OneDimBinning</span>
<span class="sd">    &gt;&gt;&gt; ebins = OneDimBinning(name=&#39;energy&#39;, is_log=True,</span>
<span class="sd">    ...                       num_bins=40, domain=[1, 100]*ureg.GeV)</span>
<span class="sd">    &gt;&gt;&gt; print(ebins)</span>
<span class="sd">    OneDimBinning(&#39;energy&#39;, 40 logarithmically-regular bins spanning [1.0, 100.0] GeV (behavior is logarithmic))</span>
<span class="sd">    &gt;&gt;&gt; ebins2 = ebins.to(&#39;joule&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(ebins2)</span>
<span class="sd">    OneDimBinning(&#39;energy&#39;, 40 logarithmically-regular bins spanning [1.6021766339999998e-10, 1.602176634e-08] J (behavior is logarithmic))</span>
<span class="sd">    &gt;&gt;&gt; czbins = OneDimBinning(name=&#39;coszen&#39;,</span>
<span class="sd">    ...                        is_lin=True, num_bins=4, domain=[-1, 0])</span>
<span class="sd">    &gt;&gt;&gt; print(czbins)</span>
<span class="sd">    OneDimBinning(&#39;coszen&#39;, 4 linearly-regular bins spanning [-1.0, 0.0] (behavior is linear))</span>
<span class="sd">    &gt;&gt;&gt; czbins2 = OneDimBinning(name=&#39;coszen&#39;,</span>
<span class="sd">    ...                         bin_edges=[-1, -0.75, -0.5, -0.25, 0])</span>
<span class="sd">    &gt;&gt;&gt; czbins == czbins2</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># pylint: enable=line-too-long</span>

    <span class="c1"># NOTE: Only one of `is_log` or `is_lin` is technically required for state,</span>
    <span class="c1">#   since it&#39;s either one or the other, but these used to imply</span>
    <span class="c1">#   log-_uniform_ and linear-_uniform_ behavior. As nothing fundamnetally</span>
    <span class="c1">#   in the behavior is changed by assuming uniformity, and to keep</span>
    <span class="c1">#   backwards compatibility (including for state / hashes), both are kept</span>
    <span class="c1">#   (for now) as &quot;state&quot; variables. -JLL, April, 2020</span>

    <span class="n">_attrs_to_create_new</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;tex&#39;</span><span class="p">,</span> <span class="s1">&#39;bin_edges&#39;</span><span class="p">,</span> <span class="s1">&#39;is_log&#39;</span><span class="p">,</span> <span class="s1">&#39;is_lin&#39;</span><span class="p">,</span> <span class="s1">&#39;bin_names&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">tex</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bin_edges</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">num_bins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_lin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">is_log</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bin_names</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Basic validation and translation of args; note that iterables are</span>
        <span class="c1"># converted to sequences later on</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`name` must be a string; got &quot;</span><span class="si">%s</span><span class="s1">&quot;.&#39;</span> <span class="o">%</span><span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">domain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">ureg</span><span class="o">.</span><span class="n">Quantity</span><span class="p">)</span> <span class="ow">and</span> <span class="n">domain</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">bin_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bin_names</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">bin_names</span> <span class="o">=</span> <span class="p">(</span><span class="n">bin_names</span><span class="p">,)</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">bin_names</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span>
                    <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">n</span>
                            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">bin_names</span><span class="p">)):</span>
                <span class="n">bin_names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">bin_names</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;`bin_names` must either be None or an iterable of&#39;</span>
                    <span class="s1">&#39; nonzero-length strings.&#39;</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="n">bin_edges</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span>
                <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">ureg</span><span class="o">.</span><span class="n">Quantity</span><span class="p">)</span> <span class="ow">and</span> <span class="n">bin_edges</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">domain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Both `domain` and `bin_edges` are specified.&#39;</span>
                    <span class="p">)</span>
            
        <span class="c1"># Type checking</span>
        <span class="k">assert</span> <span class="n">is_lin</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">is_lin</span><span class="p">,</span> <span class="nb">bool</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">is_lin</span><span class="p">))</span>
        <span class="k">assert</span> <span class="n">is_log</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">is_log</span><span class="p">,</span> <span class="nb">bool</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">is_log</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">is_lin</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">is_log</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># neither specified: default to linear</span>
            <span class="n">is_lin</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">is_log</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">is_lin</span>

        <span class="k">elif</span> <span class="n">is_lin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># is_lin is specified but not is_log</span>
            <span class="n">is_log</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">is_lin</span>

        <span class="k">elif</span> <span class="n">is_log</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># is_log is specified but not is_lin</span>
            <span class="n">is_lin</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">is_log</span>

        <span class="k">else</span><span class="p">:</span>  <span class="c1"># both specified: check consistency</span>
            <span class="k">if</span> <span class="n">is_log</span> <span class="o">==</span> <span class="n">is_lin</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;`is_log=</span><span class="si">%s</span><span class="s1">` contradicts `is_lin=</span><span class="si">%s</span><span class="s1">`&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">is_log</span><span class="p">,</span> <span class="n">is_lin</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_values</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">make_valid_python_name</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">!=</span> <span class="n">name</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Converted `name` &quot;</span><span class="si">%s</span><span class="s1">&quot; to valid Python: &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span><span class="p">,</span>
                            <span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tex</span> <span class="o">=</span> <span class="n">tex</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_basename</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bin_names</span> <span class="o">=</span> <span class="n">bin_names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hashable_state</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_serializable_state</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_normalized_state</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_midpoints</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_weighted_centers</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edge_magnitudes</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bin_widths</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_weighted_bin_widths</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inbounds_criteria</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># TODO: define hash based upon conversion of things to base units (such</span>
        <span class="c1"># that a valid comparison can be made between indentical binnings but</span>
        <span class="c1"># that use different units). Be careful to round to just less than</span>
        <span class="c1"># double-precision limits after conversion so that hashes will work out</span>
        <span class="c1"># to be the same after conversion to the base units.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edges_hash</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Figure out the units (if any) for each quantity passed in. Precedence</span>
        <span class="c1"># for units is:</span>
        <span class="c1">#   1. `units`</span>
        <span class="c1">#   2. `bin_edges`</span>
        <span class="c1">#   3. `domain`</span>
        <span class="c1">#   4. default to units of `ureg.dimensionless`</span>

        <span class="k">if</span> <span class="n">units</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">units</span><span class="p">,</span> <span class="n">ureg</span><span class="o">.</span><span class="n">Quantity</span><span class="p">):</span>
                <span class="n">units</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">units</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">units</span><span class="p">,</span> <span class="n">ureg</span><span class="o">.</span><span class="n">Unit</span><span class="p">):</span>
                <span class="n">units</span> <span class="o">=</span> <span class="n">ureg</span><span class="o">.</span><span class="n">Unit</span><span class="p">(</span><span class="n">units</span><span class="p">)</span>
            <span class="n">units_dimensionality</span> <span class="o">=</span> <span class="n">units</span><span class="o">.</span><span class="n">dimensionality</span>

        <span class="n">dimensionless_bin_edges</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">bin_edges</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">ureg</span><span class="o">.</span><span class="n">Quantity</span><span class="p">):</span>
                <span class="n">be_units</span> <span class="o">=</span> <span class="n">bin_edges</span><span class="o">.</span><span class="n">units</span>
                <span class="k">if</span> <span class="n">units</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">units</span> <span class="o">=</span> <span class="n">be_units</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">be_units</span><span class="o">.</span><span class="n">dimensionality</span> <span class="o">!=</span> <span class="n">units_dimensionality</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s1">&#39;`bin_edges` units </span><span class="si">%s</span><span class="s1"> are incompatible with units&#39;</span>
                            <span class="s1">&#39; </span><span class="si">%s</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">be_units</span><span class="p">,</span> <span class="n">units</span><span class="p">)</span>
                        <span class="p">)</span>
                    <span class="k">if</span> <span class="n">be_units</span> <span class="o">!=</span> <span class="n">units</span><span class="p">:</span>
                        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                            <span class="s1">&#39;`bin_edges` are specified in units of </span><span class="si">%s</span><span class="s1">&#39;</span>
                            <span class="s1">&#39; but `units` is specified as </span><span class="si">%s</span><span class="s1">.&#39;</span>
                            <span class="s1">&#39; Converting `bin_edges` to the latter.&#39;</span><span class="p">,</span>
                            <span class="n">be_units</span><span class="p">,</span> <span class="n">units</span>
                        <span class="p">)</span>
                        <span class="n">bin_edges</span><span class="o">.</span><span class="n">ito</span><span class="p">(</span><span class="n">units</span><span class="p">)</span>
                <span class="n">dimensionless_bin_edges</span> <span class="o">=</span> <span class="n">bin_edges</span><span class="o">.</span><span class="n">magnitude</span>

            <span class="k">elif</span> <span class="n">bin_edges</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dimensionless_bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">FTYPE</span><span class="p">)</span>
                <span class="n">bin_edges</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">dimensionless_domain</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">domain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">ureg</span><span class="o">.</span><span class="n">Quantity</span><span class="p">):</span>
                <span class="n">domain_units</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">units</span>
                <span class="k">if</span> <span class="n">units</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">units</span> <span class="o">=</span> <span class="n">domain_units</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">domain_units</span><span class="o">.</span><span class="n">dimensionality</span> <span class="o">!=</span> <span class="n">units_dimensionality</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s1">&#39;`domain` units </span><span class="si">%s</span><span class="s1"> are incmompatible with units&#39;</span>
                            <span class="s1">&#39; </span><span class="si">%s</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">domain_units</span><span class="p">,</span> <span class="n">units</span><span class="p">)</span>
                        <span class="p">)</span>
                    <span class="k">if</span> <span class="n">domain_units</span> <span class="o">!=</span> <span class="n">units</span><span class="p">:</span>
                        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                            <span class="s1">&#39;`domain` units </span><span class="si">%s</span><span class="s1"> will be converted to&#39;</span> <span class="s1">&#39; </span><span class="si">%s</span><span class="s1">.&#39;</span><span class="p">,</span>
                            <span class="n">domain_units</span><span class="p">,</span>
                            <span class="n">units</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">domain</span><span class="o">.</span><span class="n">ito</span><span class="p">(</span><span class="n">units</span><span class="p">)</span>
                <span class="n">dimensionless_domain</span> <span class="o">=</span> <span class="n">domain</span><span class="o">.</span><span class="n">magnitude</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">domain_lower_is_quant</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ureg</span><span class="o">.</span><span class="n">Quantity</span><span class="p">)</span>
                <span class="n">domain_upper_is_quant</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ureg</span><span class="o">.</span><span class="n">Quantity</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">domain_lower_is_quant</span> <span class="o">==</span> <span class="n">domain_upper_is_quant</span>
                <span class="k">if</span> <span class="n">domain_lower_is_quant</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dimensionality</span> <span class="o">==</span> <span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">dimensionality</span>
                    <span class="k">if</span> <span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">units</span> <span class="o">!=</span> <span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">units</span><span class="p">:</span>
                        <span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>
                    <span class="n">dimensionless_domain</span> <span class="o">=</span> <span class="p">(</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">magnitude</span><span class="p">,</span>
                                            <span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">magnitude</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dimensionless_domain</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">domain</span><span class="p">)</span>
                    <span class="n">domain</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># If no units have been discovered from the input args, assign default</span>
        <span class="c1"># units</span>
        <span class="k">if</span> <span class="n">units</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">units</span> <span class="o">=</span> <span class="n">ureg</span><span class="o">.</span><span class="n">dimensionless</span>

        <span class="k">if</span> <span class="n">dimensionless_bin_edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">num_bins</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">dimensionless_domain</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;If not specifying bin edges explicitly, `domain` and&#39;</span>
                    <span class="s1">&#39; `num_bins` must be specified (and optionally set&#39;</span>
                    <span class="s1">&#39; `is_log=True`).&#39;</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">is_log</span><span class="p">:</span>
                <span class="n">dimensionless_bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">dimensionless_domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">dimensionless_domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                    <span class="n">num_bins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">FTYPE</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># is_lin</span>
                <span class="n">dimensionless_bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
                    <span class="n">dimensionless_domain</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">dimensionless_domain</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">num_bins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">FTYPE</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="n">dimensionless_domain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">dimensionless_domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">dimensionless_bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">assert</span> <span class="n">dimensionless_domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">dimensionless_bin_edges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># TODO: should we warn a user if logarithmically- or linearly-uniform</span>
        <span class="c1"># bin_edges are passed while is_log, is_lin, or the default (is_lin)</span>
        <span class="c1"># &quot;contradict&quot; this?</span>

        <span class="c1"># if not (is_lin or is_log):  # infer is_log/is_lin from spacing if not set</span>
        <span class="c1">#     is_lin = self.is_bin_spacing_lin_uniform(dimensionless_bin_edges)</span>
        <span class="c1">#     try:</span>
        <span class="c1">#         is_log = self.is_bin_spacing_log_uniform(dimensionless_bin_edges)</span>
        <span class="c1">#     except ValueError:</span>
        <span class="c1">#         is_log = False</span>

        <span class="k">if</span> <span class="n">dimensionless_domain</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dimensionless_domain</span> <span class="o">=</span> <span class="p">(</span><span class="n">dimensionless_bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                    <span class="n">dimensionless_bin_edges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">bin_edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bin_edges</span> <span class="o">=</span> <span class="n">dimensionless_bin_edges</span> <span class="o">*</span> <span class="n">units</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bin_edges</span> <span class="o">=</span> <span class="n">bin_edges</span>

        <span class="k">if</span> <span class="n">domain</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_domain</span> <span class="o">=</span> <span class="n">dimensionless_domain</span> <span class="o">*</span> <span class="n">units</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_domain</span> <span class="o">=</span> <span class="n">domain</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_units</span> <span class="o">=</span> <span class="n">units</span>

        <span class="c1"># Derive rest of unspecified parameters from bin_edges or enforce</span>
        <span class="c1"># them if they were specified as arguments to init</span>
        <span class="k">if</span> <span class="n">num_bins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_bins</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">num_bins</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> \
                    <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">num_bins</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_bins</span> <span class="o">=</span> <span class="n">num_bins</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bin_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bin_names</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_bins</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;There are </span><span class="si">%d</span><span class="s1"> bins, so there must be </span><span class="si">%d</span><span class="s1"> `bin_names` (or None)&#39;</span>
                <span class="s1">&#39; provided; got </span><span class="si">%d</span><span class="s1"> bin name instead: </span><span class="si">%s</span><span class="s1">.&#39;</span>
                <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_bins</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_bins</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bin_names</span><span class="p">),</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">_bin_names</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_is_log</span> <span class="o">=</span> <span class="n">is_log</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_lin</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_log</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_irregular</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">previous_precision</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">get_printoptions</span><span class="p">()[</span><span class="s1">&#39;precision&#39;</span><span class="p">]</span>
        <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">argstrs</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">=</span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">serializable_state</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
            <span class="n">r</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">    &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">argstrs</span><span class="p">))</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="n">previous_precision</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">r</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">lin_reg</span> <span class="o">=</span> <span class="s2">&quot;linearly-regular &quot;</span>
        <span class="n">log_reg</span> <span class="o">=</span> <span class="s2">&quot;logarithmically-regular &quot;</span>

        <span class="n">regularity</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_irregular</span><span class="p">:</span>
            <span class="c1"># Test for regularity in the other domain</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_lin</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_bin_spacing_log_uniform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">):</span>
                <span class="n">regularity</span> <span class="o">=</span> <span class="n">log_reg</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_log</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_bin_spacing_lin_uniform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">):</span>
                <span class="n">regularity</span> <span class="o">=</span> <span class="n">lin_reg</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">regularity</span> <span class="o">=</span> <span class="n">log_reg</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_log</span> <span class="k">else</span> <span class="n">lin_reg</span>

        <span class="k">if</span> <span class="n">regularity</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_bins</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="s1">&#39;with edges at [</span><span class="si">{}</span><span class="s1">]</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="o">.</span><span class="n">m</span><span class="p">),</span>
                <span class="nb">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="s1">&#39;~&#39;</span><span class="p">),</span>
            <span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="n">regularity</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="s1">&#39;spanning [</span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">] </span><span class="si">{:s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">magnitude</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">magnitude</span><span class="p">,</span>
                <span class="nb">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">,</span> <span class="s1">&#39;~&#39;</span><span class="p">),</span>
            <span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

        <span class="n">plural</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_bins</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="s1">&#39;s&#39;</span>
        <span class="n">linlog</span> <span class="o">=</span> <span class="s1">&#39;logarithmic&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_log</span> <span class="k">else</span> <span class="s1">&#39;linear&#39;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bnames</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bnames</span> <span class="o">=</span> <span class="s1">&#39;, bin_names=[</span><span class="si">{}</span><span class="s1">]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">n</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2">&#39;&quot;</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_names</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">descr</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_bins</span><span class="si">:</span><span class="s1">d</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">regularity</span><span class="si">:</span><span class="s1">s</span><span class="si">}</span><span class="s1">bin</span><span class="si">{</span><span class="n">plural</span><span class="si">:</span><span class="s1">s</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">edges</span><span class="si">:</span><span class="s1">s</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="sa">f</span><span class="s1">&#39; (behavior is </span><span class="si">{</span><span class="n">linlog</span><span class="si">:</span><span class="s1">s</span><span class="si">}</span><span class="s1">)</span><span class="si">{</span><span class="n">bnames</span><span class="si">:</span><span class="s1">s</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2">(&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2">&#39;, </span><span class="si">{</span><span class="n">descr</span><span class="si">:</span><span class="s2">s</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="k">def</span> <span class="nf">__pretty__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">cycle</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Method used by the `pretty` library for formatting&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cycle</span><span class="p">:</span>
            <span class="n">p</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">(...)&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p</span><span class="o">.</span><span class="n">begin_group</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
            <span class="n">p</span><span class="o">.</span><span class="n">end_group</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;)&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_repr_pretty_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">cycle</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Method used by e.g. ipython/Jupyter for formatting&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__pretty__</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cycle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Method invoked during pickling&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">serializable_state</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Method invoked during unpickling&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">state</span><span class="p">)</span>

<div class="viewcode-block" id="OneDimBinning.to_json">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.OneDimBinning.to_json">[docs]</a>
    <span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Serialize the state to a JSON file that can be instantiated as a new</span>
<span class="sd">        object later.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">            Filename; must be either a relative or absolute path (*not</span>
<span class="sd">            interpreted as a PISA resource specification*)</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Further keyword args are sent to `pisa.utils.jsons.to_json()`</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        from_json : Instantiate new OneDimBinning object from the file written</span>
<span class="sd">            by this method</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">jsons</span><span class="o">.</span><span class="n">to_json</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">serializable_state</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="OneDimBinning.from_json">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.OneDimBinning.from_json">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_json</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">resource</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instantiate a new object from the contents of a JSON file as</span>
<span class="sd">        formatted by the `to_json` method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        resource : str</span>
<span class="sd">            A PISA resource specification (see pisa.utils.resources)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        to_json</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">jsons</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">resource</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">state</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

<div class="viewcode-block" id="OneDimBinning.index">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.OneDimBinning.index">[docs]</a>
    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return integer index of bin identified by `x`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : int, string</span>
<span class="sd">            If int, ensure it is a valid index and return; if string, look for</span>
<span class="sd">            bin with corresponding name.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        idx: int</span>
<span class="sd">            index of bin corresponding to `x`</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError if `x` cannot identify a valid bin</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">x</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`x` must be either int or string; got </span><span class="si">%s</span><span class="s1"> instead.&#39;</span>
                            <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">AssertionError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
            <span class="n">valid_range</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">valid_names</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">valid_names</span> <span class="o">=</span> <span class="s1">&#39; or a valid bin name in </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_names</span><span class="p">,)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Bin corresponding to &quot;</span><span class="si">%s</span><span class="s1">&quot; could not be located.&#39;</span>
                             <span class="s1">&#39; Specify an int in </span><span class="si">%s%s</span><span class="s1">.&#39;</span>
                             <span class="o">%</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">valid_range</span><span class="p">,</span> <span class="n">valid_names</span><span class="p">))</span></div>


<div class="viewcode-block" id="OneDimBinning.iterbins">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.OneDimBinning.iterbins">[docs]</a>
    <span class="k">def</span> <span class="nf">iterbins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return an iterator over each bin. The elments returned by the</span>
<span class="sd">        iterator are each a OneDimBinning object, just containing a single bin.</span>

<span class="sd">        Note that for one test, `iterbins` is about 500x slower than</span>
<span class="sd">        `iteredgetuples`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bin_iterator</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        iteredgetuples</span>
<span class="sd">            Faster but only returns edges of bins, not OneDimBinning objects.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span></div>


<div class="viewcode-block" id="OneDimBinning.iteredgetuples">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.OneDimBinning.iteredgetuples">[docs]</a>
    <span class="k">def</span> <span class="nf">iteredgetuples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return an iterator over each bin&#39;s edges. The elments returned by</span>
<span class="sd">        the iterator are each a tuple, containing the edges of the bin. Units</span>
<span class="sd">        are stripped prior to iteration for purposes of speed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        edges_iterator</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        iterbins</span>
<span class="sd">            Similar, but returns a OneDimBinning object for each bin; slower</span>
<span class="sd">            than this method (by as much as 500x in one test) but easier to</span>
<span class="sd">            work with.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_magnitudes</span>
        <span class="k">return</span> <span class="p">((</span><span class="n">e0</span><span class="p">,</span> <span class="n">e1</span><span class="p">)</span> <span class="k">for</span> <span class="n">e0</span><span class="p">,</span> <span class="n">e1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mags</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">mags</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">serializable_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;OrderedDict containing savable state attributes&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_serializable_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="n">state</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
            <span class="n">state</span><span class="p">[</span><span class="s1">&#39;bin_edges&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_magnitudes</span>
            <span class="n">state</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>
            <span class="n">state</span><span class="p">[</span><span class="s1">&#39;is_log&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_log</span>
            <span class="n">state</span><span class="p">[</span><span class="s1">&#39;is_lin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_lin</span>
            <span class="n">state</span><span class="p">[</span><span class="s1">&#39;bin_names&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_names</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_serializable_state</span> <span class="o">=</span> <span class="n">state</span>
        <span class="c1"># Since the tex property can be modified, must set every time this</span>
        <span class="c1"># property is called</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_serializable_state</span><span class="p">[</span><span class="s1">&#39;tex&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tex</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_serializable_state</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">hashable_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;OrderedDict containing simplified state attributes (i.e. some state</span>
<span class="sd">        attributes are represented by their hashes) used for testing equality</span>
<span class="sd">        between two objects.</span>

<span class="sd">        Use `hashable_state` for faster equality checks and `normalized_state`</span>
<span class="sd">        for inspecting the contents of each state attribute pre-hashing</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hashable_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="n">state</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
            <span class="n">state</span><span class="p">[</span><span class="s1">&#39;edges_hash&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges_hash</span>
            <span class="n">state</span><span class="p">[</span><span class="s1">&#39;is_log&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_log</span>
            <span class="n">state</span><span class="p">[</span><span class="s1">&#39;is_lin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_lin</span>
            <span class="n">state</span><span class="p">[</span><span class="s1">&#39;bin_names&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_names</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hashable_state</span> <span class="o">=</span> <span class="n">state</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hashable_state</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">normalized_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;OrderedDict containing normalized (base units, and rounded to</span>
<span class="sd">        appropriate precision) state attributes used for testing equality</span>
<span class="sd">        between two objects.</span>

<span class="sd">        Use `hashable_state` for faster equality checks and `normalized_state`</span>
<span class="sd">        for inspecting the contents of each state attribute pre-hashing</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalized_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="n">state</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
            <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">normQuant</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">sigfigs</span><span class="o">=</span><span class="n">HASH_SIGFIGS</span><span class="p">)</span>
            <span class="n">state</span><span class="p">[</span><span class="s1">&#39;bin_edges&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bin_edges</span>
            <span class="n">state</span><span class="p">[</span><span class="s1">&#39;is_log&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_log</span>
            <span class="n">state</span><span class="p">[</span><span class="s1">&#39;is_lin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_lin</span>
            <span class="n">state</span><span class="p">[</span><span class="s1">&#39;bin_names&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_names</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normalized_state</span> <span class="o">=</span> <span class="n">state</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalized_state</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">edge_magnitudes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Bin edges&#39; magnitudes&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_magnitudes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_edge_magnitudes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="o">.</span><span class="n">magnitude</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edge_magnitudes</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Name of the dimension&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">basename</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Basename of the dimension, stripping &quot;true&quot;, &quot;reco&quot;, underscores,</span>
<span class="sd">        whitespace, etc. from the `name` attribute.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_basename</span> <span class="o">=</span> <span class="n">basename</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basename</span>

    <span class="c1"># TODO: reimplement just the translate-on-input (or not?), but is this a</span>
    <span class="c1"># performance hit for e.g. iterbins()? That could argue for</span>
    <span class="c1"># translate-on-output...</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;string : TeX label&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">text2tex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tex</span>

    <span class="nd">@tex</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">tex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;None or TeX string for dimension; surrounding dollars-signs ($) are</span>
<span class="sd">        stripped off (and must be added prior to e.g. plotting)&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">strip_outer_dollars</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tex</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;TeX-formatted axis label, including units (if not dimensionless)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name_tex</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;{\rm </span><span class="si">%s</span><span class="s1">}&#39;</span> <span class="o">%</span> <span class="n">text2tex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name_tex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tex</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">==</span> <span class="n">ureg</span><span class="o">.</span><span class="n">dimensionless</span><span class="p">:</span>
            <span class="n">units_tex</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">units_tex</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39; \; \left( {:~L} \right)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">name_tex</span> <span class="o">+</span> <span class="n">units_tex</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;tuple : shape of binning, akin to `nump.ndarray.shape`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_bins</span><span class="p">,)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;int : total number of bins&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_bins</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bin_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;array : Edges of the bins.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bin_edges</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bin_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;list of strings or None : Bin names&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bin_names</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">domain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;array : domain of the binning, (min, max) bin edges&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_domain</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bin_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_magnitudes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_domain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">),</span>
                                     <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">)])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_domain</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">range</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;float : range of the binning, (max-min) bin edges&quot;&quot;&quot;</span>
        <span class="n">domain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span>
        <span class="k">return</span> <span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;pint.Unit : units of the bins&#39; edges&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_units</span>

    <span class="nd">@units</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;str or pint.Unit : units of the bins&#39; edges&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ito</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_bins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;int : Number of bins&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_bins</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_lin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;bool : Whether binning is to be treated in a linear space&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_lin</span>

    <span class="nd">@is_lin</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">is_lin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;bool&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">b</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_lin</span><span class="p">:</span>
            <span class="c1"># NOTE: use tuple unpacking to help ensure state is consistent</span>
            <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_lin</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_log</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_irregular</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_weighted_centers</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_weighted_bin_widths</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="ow">not</span> <span class="n">b</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_log</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;bool : Whether binning is to be treated in a log space&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_log</span>

    <span class="nd">@is_log</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">is_log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;bool&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">b</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_log</span><span class="p">:</span>
            <span class="c1"># NOTE: use tuple unpacking to help ensure state is consistent</span>
            <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_log</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_lin</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_irregular</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_weighted_centers</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_weighted_bin_widths</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="ow">not</span> <span class="n">b</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_irregular</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;bool : True if bin spacing is not unform in the space defined (i.e.,</span>
<span class="sd">        NOT linearly-uniform if `is_lin` or NOT logarithmically-uniform if</span>
<span class="sd">        `is_log`).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_irregular</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_bins</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_irregular</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_log</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_irregular</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_bin_spacing_log_uniform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># self.is_lin</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_is_irregular</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_bin_spacing_lin_uniform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_irregular</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">midpoints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;array : Midpoints of the bins: linear average of each bin&#39;s</span>
<span class="sd">        edges.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_midpoints</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_midpoints</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span><span class="o">/</span><span class="mf">2.0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_midpoints</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">weighted_centers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;array : Centers of the bins taking e.g. logarithmic behavior</span>
<span class="sd">        into account. I.e., if binning is logarithmic, this is **not**</span>
<span class="sd">        the same `midpoints`, whereas in all other cases, it is identical.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weighted_centers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_log</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_weighted_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span>
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_weighted_centers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">midpoints</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weighted_centers</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">hash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;int : Hash value based upon less-than-double-precision-rounded</span>
<span class="sd">        numerical values and any other state (includes name, tex, is_log, and</span>
<span class="sd">        is_lin attributes). Rounding is done to `HASH_SIGFIGS` significant</span>
<span class="sd">        figures.</span>

<span class="sd">        Set this class attribute to None to keep full numerical precision in</span>
<span class="sd">        the values hashed (but be aware that this can cause equal things</span>
<span class="sd">        defined using different unit orders-of-magnitude to hash differently).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hashable_state</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">=</span> <span class="n">hash_obj</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span>

<div class="viewcode-block" id="OneDimBinning.rehash">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.OneDimBinning.rehash">[docs]</a>
    <span class="k">def</span> <span class="nf">rehash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Force `hash` and `edges_hash` attributes to be recomputed&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edges_hash</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges_hash</span></div>


    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">normalize_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;bool : Whether to normalize quantities&#39; units prior to hashing&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_values</span>

    <span class="nd">@normalize_values</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">normalize_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_values</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="c1"># Invalidate the hash, since the hashing behavior has changed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_edges_hash</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_values</span> <span class="o">=</span> <span class="n">b</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">edges_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Hash value based *solely* upon bin edges&#39; values.</span>

<span class="sd">        The hash value is obtained on the edges after &quot;normalizing&quot; their</span>
<span class="sd">        values if `self.normalize_values` is True; see</span>
<span class="sd">        `pisa.utils.comparsions.normQuant` for details of the normalization</span>
<span class="sd">        process.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges_hash</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalize_values</span><span class="p">:</span>
                <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">normQuant</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">sigfigs</span><span class="o">=</span><span class="n">HASH_SIGFIGS</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bin_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_edges_hash</span> <span class="o">=</span> <span class="n">hash_obj</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_edges_hash</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bin_widths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Absolute widths of bins.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bin_widths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bin_widths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="o">.</span><span class="n">m</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bin_widths</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">weighted_bin_widths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Absolute widths of bins.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weighted_bin_widths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_log</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_weighted_bin_widths</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_magnitudes</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_magnitudes</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="p">)</span> <span class="o">*</span> <span class="n">ureg</span><span class="o">.</span><span class="n">dimensionless</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_weighted_bin_widths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_widths</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weighted_bin_widths</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inbounds_criteria</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return string boolean criteria indicating e.g. an event falls within</span>
<span class="sd">        the limits of the defined binning.</span>

<span class="sd">        This can be used for e.g. applying cuts to events.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pisa.core.events.keepInbounds</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inbounds_criteria</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">be</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_magnitudes</span>
            <span class="n">crit</span> <span class="o">=</span> <span class="s1">&#39;(</span><span class="si">%s</span><span class="s1"> &gt;= </span><span class="si">%.15e</span><span class="s1">) &amp; (</span><span class="si">%s</span><span class="s1"> &lt;= </span><span class="si">%.15e</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">be</span><span class="p">),</span>
                                                      <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">be</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inbounds_criteria</span> <span class="o">=</span> <span class="n">crit</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inbounds_criteria</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of bins (*not* number of bin edges).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_bins</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">OneDimBinning</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">MultiDimBinning</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">MultiDimBinning</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">MultiDimBinning</span><span class="p">(</span><span class="n">chain</span><span class="p">([</span><span class="bp">self</span><span class="p">],</span> <span class="n">other</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">OneDimBinning</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">tex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tex</span><span class="p">,</span>
                             <span class="n">bin_edges</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span> <span class="o">*</span> <span class="n">other</span><span class="p">)</span>

    <span class="c1"># TODO: if same or contained dimension, modify the current binning OR</span>
    <span class="c1"># create a smarter MultiDimBinning object that allows for multiple</span>
    <span class="c1"># disconnected binning regions with arbitrary binning within each</span>
    <span class="c1"># region</span>
    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">OneDimBinning</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">MultiDimBinning</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">MultiDimBinning</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">MultiDimBinning</span><span class="p">(</span><span class="n">chain</span><span class="p">([</span><span class="bp">self</span><span class="p">],</span> <span class="n">other</span><span class="p">))</span>

        <span class="n">other</span> <span class="o">=</span> <span class="n">interpret_quantity</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">expect_sequence</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">new_bin_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span> <span class="o">+</span> <span class="n">other</span>

        <span class="k">return</span> <span class="n">OneDimBinning</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">tex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tex</span><span class="p">,</span> <span class="n">bin_edges</span><span class="o">=</span><span class="n">new_bin_edges</span><span class="p">)</span>

    <span class="nd">@_new_obj</span>
    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Explicit deepcopy constructor&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{}</span>

<div class="viewcode-block" id="OneDimBinning.is_bin_spacing_log_uniform">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.OneDimBinning.is_bin_spacing_log_uniform">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">is_bin_spacing_log_uniform</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if `bin_edges` define a logarithmically-uniform bin spacing.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bin_edges : sequence</span>
<span class="sd">            Fewer than 2 `bin_edges` - raises ValueError</span>
<span class="sd">            Two `bin_edges` - returns False as a reasonable guess (spacing is</span>
<span class="sd">                assumed to be linear)</span>
<span class="sd">            More than two `bin_edges` - whether spacing is linear is computed</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">,</span> <span class="s1">&#39;magnitude&#39;</span><span class="p">):</span>
            <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">bin_edges</span><span class="o">.</span><span class="n">magnitude</span>
        <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1"> bin edge(s) passed; require at least 3 to&#39;</span>
                             <span class="s1">&#39; determine nature of bin spacing.&#39;</span>
                             <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">))</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">,</span> <span class="n">over</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">,</span> <span class="n">under</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">,</span>
                         <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">log_spacing</span> <span class="o">=</span> <span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">/</span> <span class="n">bin_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">AssertionError</span><span class="p">,</span> <span class="ne">FloatingPointError</span><span class="p">,</span> <span class="ne">ZeroDivisionError</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">log_spacing</span><span class="p">,</span> <span class="n">log_spacing</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">ALLCLOSE_KW</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="OneDimBinning.is_bin_spacing_lin_uniform">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.OneDimBinning.is_bin_spacing_lin_uniform">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">is_bin_spacing_lin_uniform</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if `bin_edges` define a linearly-uniform bin spacing.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bin_edges : sequence</span>
<span class="sd">            Fewer than 2 `bin_edges` - raises ValueError</span>
<span class="sd">            Two `bin_edges` - returns True as a reasonable guess</span>
<span class="sd">            More than two `bin_edges` - whether spacing is linear is computed</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError if fewer than 2 `bin_edges` are specified.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">,</span> <span class="s1">&#39;magnitude&#39;</span><span class="p">):</span>
            <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">bin_edges</span><span class="o">.</span><span class="n">magnitude</span>
        <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Single bin edge passed; require at least 2 to&#39;</span>
                             <span class="s1">&#39; determine nature of bin spacing.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># Default is to assume linear behavior if only two bin edges are given</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="n">lin_spacing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">lin_spacing</span><span class="p">,</span> <span class="n">lin_spacing</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">ALLCLOSE_KW</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="OneDimBinning.is_binning_ok">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.OneDimBinning.is_binning_ok">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">is_binning_ok</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check that there are 2 or more bin edges, and that they are</span>
<span class="sd">        monotonically increasing.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bin_edges : sequence</span>
<span class="sd">            Bin edges to check the validity of</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool, True if binning is OK, False if not</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Must be at least two edges to define a single bin</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1"># Bin edges must be monotonic and strictly increasing</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>


    <span class="c1"># TODO: as of now, only downsampling is allowed. Is this reasonable?</span>
<div class="viewcode-block" id="OneDimBinning.is_compat">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.OneDimBinning.is_compat">[docs]</a>
    <span class="k">def</span> <span class="nf">is_compat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compatibility -- for now -- is defined by all of self&#39;s bin</span>
<span class="sd">        edges form a subset of other&#39;s bin edges (i.e. you can downsample to</span>
<span class="sd">        get from the other binning to this binning), and the units must be</span>
<span class="sd">        compatible.</span>

<span class="sd">        Note that this might bear revisiting, or redefining just for special</span>
<span class="sd">        circumstances.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : OneDimBinning</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Dimension names do not match&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">dimensionality</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">dimensionality</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Incompatible units&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># TODO: should we force normalization?</span>
        <span class="c1"># TODO: Should we use FTYPE_SIGFIGS or # HASH_SIGFIGS?</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalize_values</span><span class="p">:</span>
            <span class="n">my_normed_bin_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
                <span class="n">normQuant</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">sigfigs</span><span class="o">=</span><span class="n">HASH_SIGFIGS</span><span class="p">)</span><span class="o">.</span><span class="n">magnitude</span>
            <span class="p">)</span>
            <span class="n">other_normed_bin_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
                <span class="n">normQuant</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">sigfigs</span><span class="o">=</span><span class="n">HASH_SIGFIGS</span><span class="p">)</span><span class="o">.</span><span class="n">magnitude</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">my_normed_bin_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="o">.</span><span class="n">magnitude</span><span class="p">)</span>
            <span class="n">other_normed_bin_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">bin_edges</span><span class="o">.</span><span class="n">magnitude</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">my_normed_bin_edges</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">other_normed_bin_edges</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;self.bin_edges not a subset of other.bin_edges&#39;</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;Bins in this map not found in other = </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span>
                      <span class="n">my_normed_bin_edges</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">other_normed_bin_edges</span><span class="p">))</span>

        <span class="k">return</span> <span class="kc">False</span></div>

    
<div class="viewcode-block" id="OneDimBinning.assert_compat">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.OneDimBinning.assert_compat">[docs]</a>
    <span class="k">def</span> <span class="nf">assert_compat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Assert that this binning is compatible with `other`.&quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_compat</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;incompatible </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> binning&quot;</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="nd">@_new_obj</span>
    <span class="k">def</span> <span class="nf">basename_binning</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Identical binning but named as the basename of this binning. Note</span>
<span class="sd">        that the `tex` property is not carried over into the new binning.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">basename</span><span class="p">,</span> <span class="s1">&#39;tex&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span>

    <span class="nd">@property</span>
    <span class="nd">@_new_obj</span>
    <span class="k">def</span> <span class="nf">finite_binning</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Identical binning but with infinities in bin edges replaced by</span>
<span class="sd">        largest/smallest floating-point numbers representable with the current</span>
<span class="sd">        pisa.FTYPE.&quot;&quot;&quot;</span>
        <span class="n">float_info</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">FTYPE</span><span class="p">)</span>
        <span class="n">finite_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edge_magnitudes</span><span class="p">,</span> <span class="n">a_min</span><span class="o">=</span><span class="n">float_info</span><span class="o">.</span><span class="n">min</span><span class="p">,</span>
                               <span class="n">a_max</span><span class="o">=</span><span class="n">float_info</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;bin_edges&#39;</span><span class="p">:</span> <span class="n">finite_edges</span><span class="p">}</span>

<div class="viewcode-block" id="OneDimBinning.oversample">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.OneDimBinning.oversample">[docs]</a>
    <span class="nd">@_new_obj</span>
    <span class="k">def</span> <span class="nf">oversample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factor</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a OneDimBinning object oversampled relative to this object&#39;s</span>
<span class="sd">        binning.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        factor : integer</span>
<span class="sd">            Factor by which to oversample the binning, with `factor`-times</span>
<span class="sd">            as many bins (*not* bin edges) as this object has.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_binning : OneDimBinning</span>
<span class="sd">            New binning, oversampled from the current binning.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError if illegal value is specified for `factor`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Bin names are _not_ preserved for any `factor` except 1 since it is</span>
<span class="sd">        ambiguous how names should be propagated. If you wish to have bin</span>
<span class="sd">        names after oversampling, assign them afterwards.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">factor</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">factor</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">factor</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`factor` must be integer &gt;= 1; got </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="n">factor</span><span class="p">)</span>

        <span class="n">factor</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">factor</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_log</span><span class="p">:</span>
            <span class="n">spacing_func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">geomspace</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># is_lin</span>
            <span class="n">spacing_func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span>

        <span class="n">old_bin_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_magnitudes</span>
        <span class="n">new_bin_edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">old_lower</span><span class="p">,</span> <span class="n">old_upper</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">old_bin_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">old_bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">thisbin_new_edges</span> <span class="o">=</span> <span class="n">spacing_func</span><span class="p">(</span><span class="n">old_lower</span><span class="p">,</span> <span class="n">old_upper</span><span class="p">,</span> <span class="n">factor</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Use the original lower bin edge to avoid precision issues with</span>
            <span class="c1"># its version created by `spacing_func`</span>
            <span class="n">new_bin_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">old_lower</span><span class="p">)</span>

            <span class="c1"># Add the new bin edges we created in between lower and upper; we</span>
            <span class="c1"># omit the upper bin edge because it is the first bin edge of the</span>
            <span class="c1"># next bin</span>
            <span class="n">new_bin_edges</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">thisbin_new_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Include the uppermost bin edge from original binning</span>
        <span class="n">new_bin_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">old_upper</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;bin_edges&#39;</span><span class="p">:</span> <span class="n">new_bin_edges</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">,</span> <span class="s1">&#39;bin_names&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span></div>


    <span class="c1"># TODO: do something cute with bin names, if they exist?</span>
<div class="viewcode-block" id="OneDimBinning.downsample">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.OneDimBinning.downsample">[docs]</a>
    <span class="nd">@_new_obj</span>
    <span class="k">def</span> <span class="nf">downsample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factor</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Downsample the binning by an integer factor that evenly divides the</span>
<span class="sd">        current number of bins.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        factor : int &gt;= 1</span>
<span class="sd">            Downsampling factor that evenly divides the current number of</span>
<span class="sd">            bins. E.g., if the current number of bins is 4, `factor` can be</span>
<span class="sd">            one of 1, 2, or 4. Note that floats are converted into integers</span>
<span class="sd">            if `float(factor) == int(factor)`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_binning : OneDimBinning</span>
<span class="sd">            New binning, downsampled from the current binning.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError if illegal value is specified for `factor`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Bin names are _not_ preserved for any `factor` except 1 since it is</span>
<span class="sd">        ambiguous how names should be propagated. If you wish to have bin</span>
<span class="sd">        names after downsampling, assign them afterwards.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">float</span><span class="p">(</span><span class="n">factor</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Floating point `factor` is non-integral.&#39;</span><span class="p">)</span>
        <span class="n">factor</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">factor</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">factor</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="n">factor</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">factor</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_bins</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;`factor` </span><span class="si">%d</span><span class="s1"> is out of range; must be &gt;= 1 and &lt;= number of&#39;</span>
                <span class="s1">&#39; bins (</span><span class="si">%d</span><span class="s1">).&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_bins</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_bins</span> <span class="o">%</span> <span class="n">factor</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;`factor` </span><span class="si">%d</span><span class="s1"> does not evenly divide number of bins (</span><span class="si">%d</span><span class="s1">).&#39;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">factor</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_bins</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;bin_edges&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">[::</span><span class="n">factor</span><span class="p">],</span>
                <span class="s1">&#39;bin_names&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">}</span></div>


<div class="viewcode-block" id="OneDimBinning.ito">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.OneDimBinning.ito">[docs]</a>
    <span class="k">def</span> <span class="nf">ito</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">units</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert units in-place. Cf. Pint&#39;s `ito` method.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">units</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

        <span class="n">units</span> <span class="o">=</span> <span class="n">ureg</span><span class="o">.</span><span class="n">Unit</span><span class="p">(</span><span class="n">units</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">units</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_units</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_units</span> <span class="o">=</span> <span class="n">units</span>

        <span class="c1"># Invalidate (expensive) derived properties that rely on units</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;_inbounds_criteria&#39;</span><span class="p">]:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Convert already-defined quantities</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s1">&#39;_bin_edges&#39;</span><span class="p">,</span>
            <span class="s1">&#39;_domain&#39;</span><span class="p">,</span>
            <span class="s1">&#39;_midpoints&#39;</span><span class="p">,</span>
            <span class="s1">&#39;_weighted_centers&#39;</span><span class="p">,</span>
            <span class="s1">&#39;_bin_widths&#39;</span><span class="p">,</span>
            <span class="s1">&#39;_edge_magnitudes&#39;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">val</span><span class="o">.</span><span class="n">ito</span><span class="p">(</span><span class="n">units</span><span class="p">)</span></div>


<div class="viewcode-block" id="OneDimBinning.to">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.OneDimBinning.to">[docs]</a>
    <span class="nd">@_new_obj</span>
    <span class="k">def</span> <span class="nf">to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">units</span><span class="p">):</span> <span class="c1"># pylint: disable=invalid-name</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert bin edges&#39; units to `units`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        units : None, string, or pint.Unit</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_binning : OneDimBinning</span>
<span class="sd">            New binning object whose edges have units `units`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">units</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">units</span> <span class="o">=</span> <span class="s1">&#39;dimensionless&#39;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;bin_edges&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_edges</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">ureg</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">units</span><span class="p">)))}</span></div>


    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

    <span class="c1"># TODO: make this actually grab the bins specified (and be able to grab</span>
    <span class="c1"># disparate bins, whether or not they are adjacent)... i.e., fill in all</span>
    <span class="c1"># upper bin edges, and handle the case that it goes from linear or log</span>
    <span class="c1"># to uneven (or if it stays lin or log, keep that attribute for the</span>
    <span class="c1"># subselection). Granted, a OneDimBinning object right now requires</span>
    <span class="c1"># monotonically-increasing and adjacent bins.</span>

    <span class="c1"># TODO: make indexing allow for sequence containing a single ellipsis</span>
    <span class="c1"># TODO: for some reason, this is crazy, crazy slow when indexing with</span>
    <span class="c1">#       ellipsis... why?</span>
    <span class="c1"># NOTE: mabye we don&#39;t care, since using ellipsis (or even an isolated,</span>
    <span class="c1">#       single colon) in a one-dimensional object is a &quot;violation of the</span>
    <span class="c1">#       contract&quot;: http://stackoverflow.com/a/118508</span>
    <span class="nd">@_new_obj</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new OneDimBinning, sub-selected by `index`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int, slice, ellipsis, str, or length-one Sequence</span>
<span class="sd">            The *bin indices* (not bin-edge indices) to return. Generated</span>
<span class="sd">            OneDimBinning object must obey the usual rules (monotonic, etc.).</span>
<span class="sd">            If a str is supplied it must match a name in bin_names</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A new OneDimBinning but only with bins selected by `index`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ellipsis: binninng[...] returns everything</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span>

        <span class="n">magnitude</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_magnitudes</span>
        <span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span>
        <span class="n">orig_index</span> <span class="o">=</span> <span class="n">index</span>
        <span class="n">mylen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">magnitude</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">bin_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_names</span>

        <span class="c1"># Deal with indexing by name first so as to not break anything else</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">bin_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">bin_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="c1"># Simple to get all but final bin edge</span>
        <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">magnitude</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">):</span>
            <span class="n">bin_edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">bin_edges</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bin_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">)</span>

        <span class="c1"># Convert index/indices to positive-number sequence</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">index</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">mylen</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">index</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
                <span class="n">index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">bin_index</span> <span class="ow">in</span> <span class="n">index</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bin_index</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Slicing by seq of names currently not&#39;</span>
                                     <span class="s1">&#39; supported&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">index</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`index` &quot;</span><span class="si">%s</span><span class="s1">&quot; results in no bins being&#39;</span>
                                 <span class="s1">&#39; specified.&#39;</span> <span class="o">%</span><span class="n">orig_index</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Bin indices must be monotonically&#39;</span>
                                 <span class="s1">&#39; increasing and adjacent.&#39;</span><span class="p">)</span>
            <span class="n">new_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="n">new_names</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">bin_index</span> <span class="ow">in</span> <span class="n">index</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">bin_index</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">mylen</span> <span class="ow">or</span> <span class="n">bin_index</span> <span class="o">&gt;=</span> <span class="n">mylen</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Dimension &#39;</span><span class="si">%s</span><span class="s2">&#39;: bin index </span><span class="si">%s</span><span class="s2"> is invalid. Bin index&quot;</span>
                        <span class="s2">&quot; must be &gt;= </span><span class="si">%+d</span><span class="s2"> and &lt;= </span><span class="si">%+d</span><span class="s2">&quot;</span>
                        <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">bin_index</span><span class="p">,</span> <span class="o">-</span><span class="n">mylen</span><span class="p">,</span> <span class="n">mylen</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="n">edge_ind0</span> <span class="o">=</span> <span class="n">bin_index</span> <span class="o">%</span> <span class="n">mylen</span>
                <span class="n">edge_ind1</span> <span class="o">=</span> <span class="n">edge_ind0</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">bin_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">new_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bin_names</span><span class="p">[</span><span class="n">edge_ind0</span><span class="p">])</span>
                <span class="n">mag0</span> <span class="o">=</span> <span class="n">magnitude</span><span class="p">[</span><span class="n">edge_ind0</span><span class="p">]</span>
                <span class="n">mag1</span> <span class="o">=</span> <span class="n">magnitude</span><span class="p">[</span><span class="n">edge_ind1</span><span class="p">]</span>
                <span class="n">new_edges</span> <span class="o">=</span> <span class="n">new_edges</span><span class="o">.</span><span class="n">union</span><span class="p">((</span><span class="n">mag0</span><span class="p">,</span> <span class="n">mag1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unhandled index type </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="nb">type</span><span class="p">(</span><span class="n">orig_index</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">new_names</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="n">new_names</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Retrieve current state; only bin_edges and bin_names need to be</span>
        <span class="c1"># updated</span>
        <span class="n">new_edges</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">new_edges</span><span class="p">)</span>
        <span class="n">new_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_edges</span><span class="p">)</span>
        <span class="n">new_edges</span> <span class="o">=</span> <span class="n">new_edges</span> <span class="o">*</span> <span class="n">units</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;bin_edges&#39;</span><span class="p">:</span> <span class="n">new_edges</span><span class="p">,</span> <span class="s1">&#39;bin_names&#39;</span><span class="p">:</span> <span class="n">new_names</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterbins</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">OneDimBinning</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">recursiveEquality</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hashable_state</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">hashable_state</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></div>



<div class="viewcode-block" id="MultiDimBinning">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.MultiDimBinning">[docs]</a>
<span class="k">class</span> <span class="nc">MultiDimBinning</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="c1"># pylint: disable=line-too-long</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multi-dimensional binning object. This can contain one or more</span>
<span class="sd">    OneDimBinning objects, and all subsequent operations (e.g. slicing) will</span>
<span class="sd">    act on these in the order they are supplied.</span>

<span class="sd">    Note that it is convenient to construct MultiDimBinning objects via the *</span>
<span class="sd">    operator (which implementes the outer product) from multiple OneDimBinning</span>
<span class="sd">    objects. See Examples below for details.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dimensions : OneDimBinning or sequence convertible thereto</span>
<span class="sd">        Dimensions for the binning object. Indexing into the MultiDimBinning</span>
<span class="sd">        object follows the order in which dimensions are provided.</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    OneDimBinning : each item that is not a OneDimBinning object is passed to</span>
<span class="sd">        this class to be instantiated as such.</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from pisa import ureg</span>
<span class="sd">    &gt;&gt;&gt; from pisa.core.binning import MultiDimBinning, OneDimBinning</span>
<span class="sd">    &gt;&gt;&gt; ebins = OneDimBinning(name=&#39;energy&#39;, is_log=True,</span>
<span class="sd">    ...                       num_bins=40, domain=[1, 100]*ureg.GeV)</span>
<span class="sd">    &gt;&gt;&gt; czbins = OneDimBinning(name=&#39;coszen&#39;,</span>
<span class="sd">    ...                        is_lin=True, num_bins=4, domain=[-1, 0])</span>
<span class="sd">    &gt;&gt;&gt; mdb = ebins * czbins</span>
<span class="sd">    &gt;&gt;&gt; print(mdb)</span>
<span class="sd">    MultiDimBinning(</span>
<span class="sd">        OneDimBinning(&#39;energy&#39;, 40 logarithmically-regular bins spanning [1.0, 100.0] GeV (behavior is logarithmic)),</span>
<span class="sd">        OneDimBinning(&#39;coszen&#39;, 4 linearly-regular bins spanning [-1.0, 0.0] (behavior is linear))</span>
<span class="sd">    )</span>

<span class="sd">    &gt;&gt;&gt; print(mdb.energy)</span>
<span class="sd">    OneDimBinning(&#39;energy&#39;, 40 logarithmically-regular bins spanning [1.0, 100.0] GeV (behavior is logarithmic))</span>
<span class="sd">    &gt;&gt;&gt; print(mdb[0, 0])</span>
<span class="sd">    MultiDimBinning(</span>
<span class="sd">        OneDimBinning(&#39;energy&#39;, 1 logarithmically-regular bin with edges at [1.0, 1.1220184543019633]GeV (behavior is logarithmic)),</span>
<span class="sd">        OneDimBinning(&#39;coszen&#39;, 1 linearly-regular bin with edges at [-1.0, -0.75] (behavior is linear))</span>
<span class="sd">    )</span>
<span class="sd">    &gt;&gt;&gt; print(mdb.slice(energy=2))</span>
<span class="sd">    MultiDimBinning(</span>
<span class="sd">        OneDimBinning(&#39;energy&#39;, 1 logarithmically-regular bin with edges at [1.2589254117941673, 1.4125375446227544]GeV (behavior is logarithmic)),</span>
<span class="sd">        OneDimBinning(&#39;coszen&#39;, 4 linearly-regular bins spanning [-1.0, 0.0] (behavior is linear))</span>
<span class="sd">    )</span>
<span class="sd">    &gt;&gt;&gt; smaller_binning = mdb[0:2, 0:3]</span>
<span class="sd">    &gt;&gt;&gt; map = smaller_binning.ones(name=&#39;my_map&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(map)</span>
<span class="sd">    Map(name=&#39;my_map&#39;,</span>
<span class="sd">        tex=&#39;{\\rm my\\_map}&#39;,</span>
<span class="sd">        full_comparison=False,</span>
<span class="sd">        hash=None,</span>
<span class="sd">        parent_indexer=None,</span>
<span class="sd">        binning=MultiDimBinning(</span>
<span class="sd">        OneDimBinning(&#39;energy&#39;, 2 logarithmically-regular bins spanning [1.0, 1.2589254117941673] GeV (behavior is logarithmic)),</span>
<span class="sd">        OneDimBinning(&#39;coszen&#39;, 3 linearly-regular bins spanning [-1.0, -0.25] (behavior is linear))</span>
<span class="sd">    ),</span>
<span class="sd">        hist=array([[1., 1., 1.],</span>
<span class="sd">           [1., 1., 1.]]))</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># pylint: enable=line-too-long</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__map_class</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">OneDimBinning</span><span class="p">):</span>
            <span class="n">dimensions</span> <span class="o">=</span> <span class="p">[</span><span class="n">dimensions</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">dimensions</span><span class="p">,</span> <span class="s1">&#39;dimensions&#39;</span><span class="p">):</span>
                    <span class="n">dimensions</span> <span class="o">=</span> <span class="n">dimensions</span><span class="p">[</span><span class="s1">&#39;dimensions&#39;</span><span class="p">]</span>
                <span class="n">dimensions</span> <span class="o">=</span> <span class="p">[</span><span class="n">dimensions</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dimensions</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`dimensions` unhandled type: </span><span class="si">%s</span><span class="s1">&#39;</span>
                                <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">dimensions</span><span class="p">))</span>
        <span class="n">tmp_dimensions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">obj_num</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dimensions</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">OneDimBinning</span><span class="p">):</span>
                <span class="n">one_dim_binning</span> <span class="o">=</span> <span class="n">obj</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
                <span class="n">one_dim_binning</span> <span class="o">=</span> <span class="n">OneDimBinning</span><span class="p">(</span><span class="o">**</span><span class="n">obj</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Argument/object #</span><span class="si">%d</span><span class="s1"> unhandled type: </span><span class="si">%s</span><span class="s1">&#39;</span>
                                <span class="o">%</span><span class="p">(</span><span class="n">obj_num</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)))</span>
            <span class="n">tmp_dimensions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">one_dim_binning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dimensions</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">tmp_dimensions</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_names</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_basenames</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_dims</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hashable_state</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mask_hash</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coord</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_name</span> <span class="o">=</span> <span class="n">name</span>

        <span class="c1"># Handle masking</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> 


    <span class="k">def</span> <span class="nf">_init_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span> <span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Initialize the bin mask. This can either be specified as:</span>
<span class="sd">          (1) an array matching the bin dimensions with values True/False (e.g. a `mask`), where False means &quot;masked off&quot;</span>
<span class="sd">          (2) A list of bin indices to mask off</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1">#TODO helper functions: get coords of masked bins, etc</span>

        <span class="c1"># Bail out if no mask provided</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span>

        <span class="c1"># Check format of input `mask` arg</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">mask</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">)</span> <span class="p">:</span> <span class="c1"># Is it a boolean array (e.g. a mask)?</span>

            <span class="c1">#</span>
            <span class="c1"># &quot;Mask&quot; case</span>
            <span class="c1">#</span>

            <span class="c1"># Just use the mask as provided</span>
            <span class="c1"># Do some checks first</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span>


        <span class="k">else</span> <span class="p">:</span>

            <span class="c1">#</span>
            <span class="c1"># &quot;List of indices&quot; case</span>
            <span class="c1">#</span>

            <span class="c1"># Get the indices</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">mask</span>

            <span class="c1"># Init a mask with all True</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

            <span class="c1"># Loop over indices and set those mask elements to False</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">indices</span> <span class="p">:</span>
                <span class="k">try</span><span class="p">:</span> <span class="c1"># Handle index formatting and checks</span>
                    <span class="n">mask</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Bin mask index </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2"> not valid for binning shape </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Done, store the mask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">mask</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Name of the dimension&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>


    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">previous_precision</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">get_printoptions</span><span class="p">()[</span><span class="s1">&#39;precision&#39;</span><span class="p">]</span>
        <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">argstrs</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">=</span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">serializable_state</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
            <span class="n">r</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">    &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">argstrs</span><span class="p">))</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="n">previous_precision</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">r</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">b</span> <span class="o">=</span> <span class="s1">&#39; x &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;</span><span class="si">%i</span><span class="s1"> (</span><span class="si">%s</span><span class="s1">)&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">dim</span><span class="o">.</span><span class="n">num_bins</span><span class="p">,</span> <span class="n">dim</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimensions</span><span class="p">])</span>
        <span class="k">return</span> <span class="s1">&#39;&quot;</span><span class="si">%s</span><span class="s1">&quot;:</span><span class="se">\n</span><span class="si">%s</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__pretty__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">cycle</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Method used by the `pretty` library for formatting&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cycle</span><span class="p">:</span>
            <span class="n">p</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">(...)&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p</span><span class="o">.</span><span class="n">begin_group</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">([&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="n">p</span><span class="o">.</span><span class="n">breakable</span><span class="p">()</span>
                <span class="n">p</span><span class="o">.</span><span class="n">pretty</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
            <span class="n">p</span><span class="o">.</span><span class="n">end_group</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;])&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_repr_pretty_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">cycle</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Method used by e.g. ipython/Jupyter for formatting&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__pretty__</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cycle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Method invoked during pickling&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">serializable_state</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Method invoked during unpickling&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">state</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_map_class</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__map_class</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">pisa.core.map</span> <span class="kn">import</span> <span class="n">Map</span>  <span class="c1"># pylint: disable=wrong-import-position</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__map_class</span> <span class="o">=</span> <span class="n">Map</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__map_class</span>

<div class="viewcode-block" id="MultiDimBinning.to_json">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.MultiDimBinning.to_json">[docs]</a>
    <span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Serialize the state to a JSON file that can be instantiated as a new</span>
<span class="sd">        object later.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">            Filename; must be either a relative or absolute path (*not</span>
<span class="sd">            interpreted as a PISA resource specification*)</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Further keyword args are sent to `pisa.utils.jsons.to_json()`</span>


<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        from_json</span>
<span class="sd">            Instantiate new object from the file written by this method</span>
<span class="sd">        pisa.utils.jsons.to_json</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">jsons</span><span class="o">.</span><span class="n">to_json</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">serializable_state</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="MultiDimBinning.from_json">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.MultiDimBinning.from_json">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_json</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">resource</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instantiate a new MultiDimBinning object from a JSON file.</span>

<span class="sd">        The format of the JSON is generated by the `MultiDimBinning.to_json`</span>
<span class="sd">        method, which converts a MultiDimBinning object to basic types and</span>
<span class="sd">        numpy arrays are converted in a call to `pisa.utils.jsons.to_json`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        resource : str</span>
<span class="sd">            A PISA resource specification (see pisa.utils.resources)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        to_json</span>
<span class="sd">        pisa.utils.jsons.to_json</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">jsons</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">resource</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">state</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;list of strings : names of each dimension contained&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">dim</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_names</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">basenames</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;List of binning names with prefixes and/or suffixes along with any</span>
<span class="sd">        number of possible separator characters removed. See function</span>
<span class="sd">        `basename` for detailed specifications.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basenames</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_basenames</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="o">.</span><span class="n">basename</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basenames</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">basename_binning</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Identical binning but with dimensions named by their basenames.</span>
<span class="sd">        Note that the `tex` properties for the dimensions are not carried over</span>
<span class="sd">        into the new binning.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">MultiDimBinning</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">basename_binning</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">finite_binning</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Identical binning but with infinities in bin edges replaced by</span>
<span class="sd">        largest/smallest floating-point numbers representable with the current</span>
<span class="sd">        pisa.FTYPE.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">MultiDimBinning</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">finite_binning</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;tuple of OneDimBinning : each dimension&#39;s binning in a list&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimensions</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dims</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;tuple of OneDimBinning : shortcut for `dimensions`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimensions</span>

<div class="viewcode-block" id="MultiDimBinning.iterdims">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.MultiDimBinning.iterdims">[docs]</a>
    <span class="k">def</span> <span class="nf">iterdims</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterator over contained `dimensions`, each a OneDimBinning&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dimensions</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;int : number of dimensions&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_dims</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_num_dims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dimensions</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_dims</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;array : return the bin mask&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;tuple : shape of binning, akin to `nump.ndarray.shape`&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">num_bins</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimensions</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;int : total number of bins&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">coord</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;namedtuple : coordinate for indexing into binning by dim names&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_coord</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;coord&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coord</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">normalize_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;bool : Normalize quantities&#39; units prior to hashing&quot;&quot;&quot;</span>
        <span class="n">nv</span> <span class="o">=</span> <span class="p">[</span><span class="n">dim</span><span class="o">.</span><span class="n">normalize_values</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">nv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nv</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Contained dimensions have `normalize_values` both True and&#39;</span>
                <span class="s1">&#39; False. Set `normalize_values` to either True or False on&#39;</span>
                <span class="s1">&#39; this MultiDimBinning object to force consistency among&#39;</span>
                <span class="s1">&#39; contained OneDimBinning objects.&#39;</span>
            <span class="p">)</span>

    <span class="nd">@normalize_values</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">normalize_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">dim</span><span class="o">.</span><span class="n">normalize_values</span> <span class="o">=</span> <span class="n">b</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mask_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Hash value based *solely* upon the mask.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask_hash</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mask_hash</span> <span class="o">=</span> <span class="n">hash_obj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask_hash</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">serializable_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attributes of the object that are stored to disk. Note that</span>
<span class="sd">        attributes may be returned as references to other objects, so to</span>
<span class="sd">        prevent external modification of those objects, the user must call</span>
<span class="sd">        deepcopy() separately on the returned OrderedDict.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        state dict : OrderedDict</span>
<span class="sd">            can be passed to instantiate a new MultiDimBinning via</span>
<span class="sd">            `MultiDimBinning(**state)`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">({</span><span class="s1">&#39;dimensions&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">serializable_state</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]})</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">hashable_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Everything necessary to fully describe this object&#39;s state. Note</span>
<span class="sd">        that objects may be returned by reference, so to prevent external</span>
<span class="sd">        modification, the user must call deepcopy() separately on the returned</span>
<span class="sd">        OrderedDict.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        state : OrderedDict that can be passed to instantiate a new</span>
<span class="sd">            MultiDimBinning via MultiDimBinning(**state)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hashable_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">state</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
            <span class="c1"># TODO: Shouldn&#39;t order matter?</span>
            <span class="c1">#state[&#39;dimensions&#39;] = [self[name]._hashable_state</span>
            <span class="c1">#                       for name in sorted(self.names)]</span>
            <span class="n">state</span><span class="p">[</span><span class="s1">&#39;dimensions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">hashable_state</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
            <span class="n">state</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

            <span class="n">mask_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_hash</span>
            <span class="k">if</span> <span class="n">mask_hash</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="p">:</span>
                <span class="n">state</span><span class="p">[</span><span class="s1">&#39;mask_hash&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask_hash</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_hashable_state</span> <span class="o">=</span> <span class="n">state</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hashable_state</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">normalized_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;OrderedDict containing normalized (base units, and rounded to</span>
<span class="sd">        appropriate precision) state attributes used for testing equality</span>
<span class="sd">        between two objects.</span>

<span class="sd">        Use `hashable_state` for faster equality checks and `normalized_state`</span>
<span class="sd">        for inspecting the contents of each state attribute pre-hashing</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;dimensions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">normalized_state</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span>
        <span class="k">return</span> <span class="n">state</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">hash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Unique hash value for this object&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">=</span> <span class="n">hash_obj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hashable_state</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">edges_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;int : hash on the list of hashes for each dimension&#39;s edge values&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">hash_obj</span><span class="p">([</span><span class="n">d</span><span class="o">.</span><span class="n">edges_hash</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bin_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a list of the contained dimensions&#39; bin_edges that is</span>
<span class="sd">        compatible with the numpy.histogramdd `hist` argument.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">bin_edges</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_irregular</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns `True` if any of the 1D binnings is irregular.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="n">d</span><span class="o">.</span><span class="n">is_irregular</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_lin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns `True` iff all dimensions are linear.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="n">d</span><span class="o">.</span><span class="n">is_lin</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_log</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns `True` iff all dimensions are log.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="n">d</span><span class="o">.</span><span class="n">is_log</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">domains</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a list of the contained dimensions&#39; domains&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">domain</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">midpoints</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a list of the contained dimensions&#39; midpoints&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">midpoints</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">weighted_centers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a list of the contained dimensions&#39; weighted_centers (e.g.</span>
<span class="sd">        equidistant from bin edges on logarithmic scale, if the binning is</span>
<span class="sd">        logarithmic; otherwise linear). Access `midpoints` attribute for</span>
<span class="sd">        always-linear alternative.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">weighted_centers</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_bins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of the contained dimensions&#39; num_bins.</span>
<span class="sd">        Note that this does not accpunt for any bin mask (since it is computed per dimension)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">num_bins</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tot_num_bins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return total number of bins.</span>
<span class="sd">        If a bin mask is used, this will only count bins that are not masked off</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span> <span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;list : Return a list of the contained dimensions&#39; units&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">d</span><span class="o">.</span><span class="n">units</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>

    <span class="nd">@units</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;sequence or *args containing units for each contained dim&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ito</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inbounds_criteria</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return string boolean criteria indicating e.g. an event falls within</span>
<span class="sd">        the limits of the defined binning.</span>

<span class="sd">        This can be used for e.g. applying cuts to events.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pisa.core.events.keepEventsInBins</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">crit</span> <span class="o">=</span> <span class="s1">&#39;(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span><span class="p">(</span><span class="s1">&#39; &amp; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dim</span><span class="o">.</span><span class="n">inbounds_criteria</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">crit</span>

<div class="viewcode-block" id="MultiDimBinning.index">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.MultiDimBinning.index">[docs]</a>
    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">use_basenames</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find dimension implied by `dim` and return its integer index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : int, string, OneDimBinning</span>
<span class="sd">            An integer index, dimesion name, or identical OneDimBinning object</span>
<span class="sd">            to locate within the contained dimensions</span>

<span class="sd">        use_basenames : bool</span>
<span class="sd">            Dimension names are only compared after pre/suffixes are stripped,</span>
<span class="sd">            allowing for e.g. `dim`=&#39;true_energy&#39; to find &#39;reco_energy&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        idx : integer</span>
<span class="sd">            index of the dimension corresponding to `dim`</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError if `dim` cannot be found</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">basenames</span> <span class="k">if</span> <span class="n">use_basenames</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">OneDimBinning</span><span class="p">):</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">dim</span><span class="o">.</span><span class="n">basename</span> <span class="k">if</span> <span class="n">use_basenames</span> <span class="k">else</span> <span class="n">dim</span><span class="o">.</span><span class="n">name</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">what</span> <span class="o">=</span> <span class="s1">&#39;index&#39;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Dimension </span><span class="si">%s</span><span class="s1"> not present. Valid dimensions are in range </span><span class="si">%s</span><span class="s1">&#39;</span>
                    <span class="o">%</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">basename</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="k">if</span> <span class="n">use_basenames</span> <span class="k">else</span> <span class="n">dim</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">what</span> <span class="o">=</span> <span class="s1">&#39;basename&#39;</span> <span class="k">if</span> <span class="n">use_basenames</span> <span class="k">else</span> <span class="s1">&#39;name&#39;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Dimension </span><span class="si">%s</span><span class="s2"> &#39;</span><span class="si">%s</span><span class="s2">&#39; not present. Valid dimension </span><span class="si">%s</span><span class="s2">s are </span><span class="si">%s</span><span class="s2">&quot;</span>
                    <span class="o">%</span><span class="p">(</span><span class="n">what</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">what</span><span class="p">,</span> <span class="n">names</span><span class="p">)</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">dim</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Dimension </span><span class="si">%d</span><span class="s1"> does not exist. Valid dimensions indices&#39;</span>
                    <span class="s1">&#39; are in the range </span><span class="si">%s</span><span class="s1">.&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">dim</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unhandled type for `dim`: &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span><span class="nb">type</span><span class="p">(</span><span class="n">dim</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">idx</span></div>


<div class="viewcode-block" id="MultiDimBinning.remove">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.MultiDimBinning.remove">[docs]</a>
    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dims</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove dimensions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dims : str, int, or sequence thereof</span>
<span class="sd">            Dimensions to be removed</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        binning : MultiDimBinning</span>
<span class="sd">            Identical binning as this but with `dims` removed.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">dims</span><span class="p">]</span>

        <span class="n">keep_idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
            <span class="n">keep_idx</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

        <span class="n">keep_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">keep_idx</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">MultiDimBinning</span><span class="p">(</span><span class="n">keep_dims</span><span class="p">)</span></div>


    <span class="c1"># TODO: add *args to handle positional indexing (?) (also would need to</span>
    <span class="c1"># add this to `slice` method if implemented.</span>
<div class="viewcode-block" id="MultiDimBinning.indexer">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.MultiDimBinning.indexer">[docs]</a>
    <span class="k">def</span> <span class="nf">indexer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Any dimension index/slice not specified by name in kwargs will</span>
<span class="sd">        default to &quot;:&quot; (all elements).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ---------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            kwargs are names of dimension(s) and assigned to these are either</span>
<span class="sd">            an integer index into that dimension or a Python `slice` object for</span>
<span class="sd">            that dimension. See examples below for details.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        indexer : tuple</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        broadcast</span>
<span class="sd">            Assignment of a one-dimensional array to a higher-dimensional array</span>
<span class="sd">            is simplified greatly by using `broadcast` in conjunction with</span>
<span class="sd">            `indexer` or `pisa.core.map.Map.slice`. See examples in</span>
<span class="sd">            docs for `broadcast`.</span>
<span class="sd">        broadcaster</span>
<span class="sd">            Similar to `broadcast`, but returns a tuple that can be applied to</span>
<span class="sd">            broadcast any one-dimensional array.</span>
<span class="sd">        slice</span>
<span class="sd">            Apply the `indexer` returned by this method to this MultiDimBinning</span>
<span class="sd">            object, returning a new MultiDimBinning object.</span>
<span class="sd">        pisa.core.map.Map.slice</span>
<span class="sd">            Same operation, but slices a Map object by dimension-name</span>
<span class="sd">            (internally, calls `indexer`).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pisa import ureg</span>
<span class="sd">        &gt;&gt;&gt; from pisa.core.binning import MultiDimBinning, OneDimBinning</span>
<span class="sd">        &gt;&gt;&gt; ebins = OneDimBinning(name=&#39;energy&#39;, is_log=True,</span>
<span class="sd">        ...                       num_bins=40, domain=[1, 80]*ureg.GeV)</span>
<span class="sd">        &gt;&gt;&gt; czbins = OneDimBinning(name=&#39;coszen&#39;,</span>
<span class="sd">        ...                        is_lin=True, num_bins=4, domain=[-1, 0])</span>
<span class="sd">        &gt;&gt;&gt; mdb = ebins * czbins</span>
<span class="sd">        &gt;&gt;&gt; print(mdb.indexer(energy=0))</span>
<span class="sd">        (0, slice(None, None, None))</span>

<span class="sd">        Omitting a dimension (coszen in the above) is equivalent to slicing</span>
<span class="sd">        with a colon (i.e., `(0, slice(None))`):</span>

<span class="sd">        &gt;&gt;&gt; print(mdb.indexer(energy=0, coszen=slice(None)))</span>
<span class="sd">        (0, slice(None, None, None))</span>

<span class="sd">        &gt;&gt;&gt; print(mdb.indexer(energy=slice(None), coszen=1))</span>
<span class="sd">        (slice(None, None, None), 1)</span>

<span class="sd">        Now create an indexer to use on a Numpy array:</span>

<span class="sd">        &gt;&gt;&gt; x = np.random.RandomState(0).uniform(size=mdb.shape)</span>
<span class="sd">        &gt;&gt;&gt; indexer = mdb.indexer(energy=slice(0, 5), coszen=1)</span>
<span class="sd">        &gt;&gt;&gt; print(x[indexer])</span>
<span class="sd">        [0.71518937 0.64589411 0.38344152 0.92559664 0.83261985]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indexer</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dim</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">dim</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="n">dim</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="n">indexer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">indexer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">indexer</span><span class="p">)</span></div>


<div class="viewcode-block" id="MultiDimBinning.slice">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.MultiDimBinning.slice">[docs]</a>
    <span class="k">def</span> <span class="nf">slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Slice the binning by dimension name. Any dimension/index not</span>
<span class="sd">        specified by name in kwargs will default to &quot;:&quot; (all bins).</span>

<span class="sd">        Uses `indexer` internally to define the indexing tuple.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sliced_binning : MultiDimBinning</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">indexer</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)]</span></div>


<div class="viewcode-block" id="MultiDimBinning.broadcast">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.MultiDimBinning.broadcast">[docs]</a>
    <span class="k">def</span> <span class="nf">broadcast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">from_dim</span><span class="p">,</span> <span class="n">to_dims</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Take a one-dimensional array representing one input dimension and</span>
<span class="sd">        broadcast it across some number of output dimensions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a : 1D array</span>
<span class="sd">            Data from the `from_dim` dimension. `a` must have same length as</span>
<span class="sd">            the dimension it comes from (or Numpy must be able to automatically</span>
<span class="sd">            cast it into this dimension).</span>

<span class="sd">        from_dim : string</span>
<span class="sd">            Name of dimension that the data in `a` comes from.</span>

<span class="sd">        to_dims : string or iterable of strings</span>
<span class="sd">            Dimension(s) to cast `a` into.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        a_broadcast : array</span>
<span class="sd">            Broadcast version of `a`</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        broadcaster</span>
<span class="sd">            The method used internally to derive the tuple used to broadcast</span>
<span class="sd">            the array. This can be used directly to return the broadcaster for</span>
<span class="sd">            use on other Maps or Numpy arrays.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="n">a_shape</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">a_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">broadcaster</span><span class="p">(</span><span class="n">from_dim</span><span class="o">=</span><span class="n">from_dim</span><span class="p">,</span> <span class="n">to_dims</span><span class="o">=</span><span class="n">to_dims</span><span class="p">)]</span></div>


<div class="viewcode-block" id="MultiDimBinning.broadcaster">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.MultiDimBinning.broadcaster">[docs]</a>
    <span class="k">def</span> <span class="nf">broadcaster</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_dim</span><span class="p">,</span> <span class="n">to_dims</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate an indexder that, if applied to a one-dimensional array</span>
<span class="sd">        representing data from one dimension, broadcasts that array into some</span>
<span class="sd">        number of other dimensions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        from_dim : string</span>
<span class="sd">            Name of dimension that the data in comes from.</span>

<span class="sd">        to_dims : string or iterable of strings</span>
<span class="sd">            Dimension(s) to cast into.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bcast : tuple</span>
<span class="sd">            Tuple that can be applied to a Numpy array for purposes of</span>
<span class="sd">            broadcasting it. E.g. use as `np.array([0,1,2])[bcast]`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">to_dims</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">to_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">to_dims</span><span class="p">]</span>

        <span class="n">bcast</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="n">from_dim</span><span class="p">:</span>
                <span class="n">bcast</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">to_dims</span><span class="p">:</span>
                <span class="n">bcast</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">bcast</span><span class="p">)</span></div>


<div class="viewcode-block" id="MultiDimBinning.iterbins">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.MultiDimBinning.iterbins">[docs]</a>
    <span class="k">def</span> <span class="nf">iterbins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return an iterator over each N-dimensional bin. The elments returned</span>
<span class="sd">        by the iterator are each a MultiDimBinning, just containing a single</span>
<span class="sd">        bin.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bin_iterator</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        index2coord</span>
<span class="sd">            convert the (flat) index to multi-dimensional coordinate, which is</span>
<span class="sd">            useful when using e.g. `enumerate(iterbins)`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">MultiDimBinning</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="k">for</span> <span class="n">dims</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">))</span></div>


<div class="viewcode-block" id="MultiDimBinning.iteredgetuples">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.MultiDimBinning.iteredgetuples">[docs]</a>
    <span class="k">def</span> <span class="nf">iteredgetuples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return an iterator over each bin&#39;s edges. The elments returned by</span>
<span class="sd">        the iterator are a tuple of tuples, where the innermost tuples</span>
<span class="sd">        correspond to each dimension (in the order they&#39;re defined here).</span>

<span class="sd">        Units are stripped prior to iteration for purposes of speed.</span>

<span class="sd">        Note that this method is, according to one simple test, about 5000x</span>
<span class="sd">        faster than `iterbins`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        edges_iterator</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        iterbins</span>
<span class="sd">            Similar, but returns a OneDimBinning object for each bin. This is</span>
<span class="sd">            slower that `iteredgetuples` but easier to work with.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">dim</span><span class="o">.</span><span class="n">iteredgetuples</span><span class="p">()</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span><span class="p">))</span></div>


<div class="viewcode-block" id="MultiDimBinning.itercoords">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.MultiDimBinning.itercoords">[docs]</a>
    <span class="k">def</span> <span class="nf">itercoords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return an iterator over each N-dimensional coordinate into the</span>
<span class="sd">        binning. The elments returned by the iterator are each a namedtuple,</span>
<span class="sd">        which can be used to directly index into the binning.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        coord_iterator</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        iterbins</span>
<span class="sd">            Iterator over each bin</span>
<span class="sd">        index2coord</span>
<span class="sd">            convert the (flat) index to multi-dimensional coordinate, which is</span>
<span class="sd">            useful when using e.g. `enumerate(iterbins)`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">index2coord</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">))</span></div>


<div class="viewcode-block" id="MultiDimBinning.index2coord">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.MultiDimBinning.index2coord">[docs]</a>
    <span class="k">def</span> <span class="nf">index2coord</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert a flat index into an N-dimensional bin coordinate.</span>

<span class="sd">        Useful in conjunction with `enumerate(iterbins)`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : integer</span>
<span class="sd">            The flat index</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        coord : self.coord namedtuple</span>
<span class="sd">            Coordinates are in the same order as the binning is here defined</span>
<span class="sd">            and each coordinate is named by its corresponding dimension.</span>
<span class="sd">            Therefore integer indexing into `coord` as well as named indexing</span>
<span class="sd">            are possible.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coord</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">quot</span> <span class="o">=</span> <span class="n">index</span>
        <span class="k">for</span> <span class="n">dim_length</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">quot</span><span class="p">,</span> <span class="n">rem</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">quot</span><span class="p">,</span> <span class="n">dim_length</span><span class="p">)</span>
            <span class="n">coord</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rem</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coord</span><span class="p">(</span><span class="o">*</span><span class="n">coord</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># pylint: disable=not-callable</span></div>


    <span class="c1"># TODO: examples!</span>
<div class="viewcode-block" id="MultiDimBinning.reorder_dimensions">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.MultiDimBinning.reorder_dimensions">[docs]</a>
    <span class="k">def</span> <span class="nf">reorder_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">use_deepcopy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="n">use_basenames</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new MultiDimBinning object with dimensions ordered</span>
<span class="sd">        according to `order`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        order : MultiDimBinning or sequence of string, int, or OneDimBinning</span>
<span class="sd">            Order of dimensions to use. Strings are interpreted as dimension</span>
<span class="sd">            basenames, integers are interpreted as dimension indices, and</span>
<span class="sd">            OneDimBinning objects are interpreted by their `basename`</span>
<span class="sd">            attributes (so e.g. the exact binnings in `order` do not have to</span>
<span class="sd">            match this object&#39;s exact binnings; only their basenames). Note</span>
<span class="sd">            that a MultiDimBinning object is a valid sequence type to use for</span>
<span class="sd">            `order`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Dimensions specified in `order` that are not in this object are</span>
<span class="sd">        ignored, but dimensions in this object that are missing in `order`</span>
<span class="sd">        result in an error.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MultiDimBinning object with reordred dimensions.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError if dimensions present in this object are missing from</span>
<span class="sd">        `order`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; b0 = MultiDimBinning(...)</span>
<span class="sd">        &gt;&gt;&gt; b1 = MultiDimBinning(...)</span>
<span class="sd">        &gt;&gt;&gt; b2 = b0.reorder_dimensions(b1)</span>
<span class="sd">        &gt;&gt;&gt; print(b2.binning.names)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="s1">&#39;binning&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">order</span><span class="o">.</span><span class="n">binning</span><span class="p">,</span>
                                                    <span class="n">MultiDimBinning</span><span class="p">):</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">dims</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="n">MultiDimBinning</span><span class="p">):</span>
            <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="o">.</span><span class="n">dims</span>

        <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">order</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">use_basenames</span><span class="o">=</span><span class="n">use_basenames</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Invalid `order`: Only a subset of the dimensions present&#39;</span>
                <span class="s1">&#39; were specified. `order`=</span><span class="si">%s</span><span class="s1">, but dimensions=</span><span class="si">%s</span><span class="s1">&#39;</span>
                <span class="o">%</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">use_deepcopy</span><span class="p">:</span>
            <span class="n">new_dimensions</span> <span class="o">=</span> <span class="p">[</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dimensions</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_dimensions</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_dimensions</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]</span>
        <span class="n">new_binning</span> <span class="o">=</span> <span class="n">MultiDimBinning</span><span class="p">(</span><span class="n">new_dimensions</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_binning</span></div>


<div class="viewcode-block" id="MultiDimBinning.is_compat">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.MultiDimBinning.is_compat">[docs]</a>
    <span class="k">def</span> <span class="nf">is_compat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if another binning is compatible with this binning.</span>

<span class="sd">        Note that for now, only downsampling is allowed from other to this, and</span>
<span class="sd">        not vice versa.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : MultiDimBinning</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        is_compat : bool</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">names</span><span class="p">):</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s1">&#39;dimension names do not match&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">is_compat</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="n">name</span><span class="p">]):</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="MultiDimBinning.oversample">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.MultiDimBinning.oversample">[docs]</a>
    <span class="k">def</span> <span class="nf">oversample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a MultiDimBinning object oversampled relative to this one.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *args : each factor an int</span>
<span class="sd">            Factors by which to oversample the binnings. There must either be</span>
<span class="sd">            one factor (one arg)--which will be broadcast to all dimensions--or</span>
<span class="sd">            there must be as many factors (args) as there are dimensions.</span>
<span class="sd">            If positional args are specified (i.e., non-kwargs), then kwargs</span>
<span class="sd">            are forbidden. For more detailed control, use keyword arguments to</span>
<span class="sd">            specify the dimension(s) to be oversampled and their factors.</span>

<span class="sd">        **kwargs : name=factor pairs</span>
<span class="sd">            Dimensions not specified default to oversample factor of 1 (i.e.,</span>
<span class="sd">            no oversampling)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_binning : MultiDimBinning</span>
<span class="sd">            New binning, oversampled from the current binning.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        You can either specify oversmapling by passing in args (ordered values,</span>
<span class="sd">        no keywords) or kwargs (order doesn&#39;t matter, but uses keywords), but</span>
<span class="sd">        not both.</span>

<span class="sd">        Specifying simple args (no keywords) requires either a single scalar</span>
<span class="sd">        (in which case all dimensions will be oversampled by the same factor)</span>
<span class="sd">        or one scalar per dimension (which oversamples the dimensions in the</span>
<span class="sd">        order specified).</span>

<span class="sd">        Specifying keyword args is far more explicit (and general), where each</span>
<span class="sd">        dimension&#39;s oversampling can be specified by name=factor pairs, but not</span>
<span class="sd">        every dimension must be specified (where no oversampling is applied to</span>
<span class="sd">        unspecified dimensions).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        downsample</span>
<span class="sd">            Similar to this, but downsample the MultiDimBinning</span>

<span class="sd">        OneDimBinning.oversample</span>
<span class="sd">            Oversample a OneDimBinning object; this method is called to</span>
<span class="sd">            actually perform the oversampling for each dimension within this</span>
<span class="sd">            MultiDimBinning object</span>

<span class="sd">        OneDimBinning.downsample</span>
<span class="sd">            Same but downsample for OneDimBinning</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = OneDimBinning(&#39;x&#39;, bin_edges=[0, 1, 2])</span>
<span class="sd">        &gt;&gt;&gt; y = OneDimBinning(&#39;y&#39;, bin_edges=[0, 20])</span>
<span class="sd">        &gt;&gt;&gt; mdb = x * y</span>

<span class="sd">        The following are all equivalent:</span>

<span class="sd">        &gt;&gt;&gt; print(mdb.oversample(2))</span>
<span class="sd">        MultiDimBinning(</span>
<span class="sd">            OneDimBinning(&#39;x&#39;, 4 linearly-regular bins spanning [0.0, 2.0] (behavior is linear)),</span>
<span class="sd">            OneDimBinning(&#39;y&#39;, 2 linearly-regular bins spanning [0.0, 20.0] (behavior is linear))</span>
<span class="sd">        )</span>
<span class="sd">        &gt;&gt;&gt; print(mdb.oversample(2, 2))</span>
<span class="sd">        MultiDimBinning(</span>
<span class="sd">            OneDimBinning(&#39;x&#39;, 4 linearly-regular bins spanning [0.0, 2.0] (behavior is linear)),</span>
<span class="sd">            OneDimBinning(&#39;y&#39;, 2 linearly-regular bins spanning [0.0, 20.0] (behavior is linear))</span>
<span class="sd">        )</span>
<span class="sd">        &gt;&gt;&gt; print(mdb.oversample(x=2, y=2))</span>
<span class="sd">        MultiDimBinning(</span>
<span class="sd">            OneDimBinning(&#39;x&#39;, 4 linearly-regular bins spanning [0.0, 2.0] (behavior is linear)),</span>
<span class="sd">            OneDimBinning(&#39;y&#39;, 2 linearly-regular bins spanning [0.0, 20.0] (behavior is linear))</span>
<span class="sd">        )</span>

<span class="sd">        But with kwargs, you can specify only the dimensions you want to</span>
<span class="sd">        oversample, and the other dimension(s) remain unchanged:</span>

<span class="sd">        &gt;&gt;&gt; print(mdb.oversample(y=5))</span>
<span class="sd">        MultiDimBinning(</span>
<span class="sd">            OneDimBinning(&#39;x&#39;, 2 linearly-regular bins spanning [0.0, 2.0] (behavior is linear)),</span>
<span class="sd">            OneDimBinning(&#39;y&#39;, 5 linearly-regular bins spanning [0.0, 20.0] (behavior is linear))</span>
<span class="sd">        )</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;`oversample` function does not currenty support bin masking&quot;</span>

        <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">factors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_args_kwargs_to_list</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">new_binning</span> <span class="o">=</span> <span class="p">[</span><span class="n">dim</span><span class="o">.</span><span class="n">oversample</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dimensions</span><span class="p">,</span> <span class="n">factors</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">MultiDimBinning</span><span class="p">(</span><span class="n">new_binning</span><span class="p">)</span></div>


<div class="viewcode-block" id="MultiDimBinning.downsample">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.MultiDimBinning.downsample">[docs]</a>
    <span class="k">def</span> <span class="nf">downsample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a Binning object downsampled relative to this binning.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *args : each factor an int</span>
<span class="sd">            Factors by which to downsample the binnings. There must either be</span>
<span class="sd">            one factor (one arg)--which will be broadcast to all dimensions--or</span>
<span class="sd">            there must be as many factors (args) as there are dimensions.</span>
<span class="sd">            If positional args are specified (i.e., non-kwargs), then kwargs</span>
<span class="sd">            are forbidden.</span>

<span class="sd">        **kwargs : name=factor pairs</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_binning : MultiDimBinning</span>
<span class="sd">            New binning, downsampled from the current binning.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Can either specify downsampling by passing in args (ordered values, no</span>
<span class="sd">        keywords) or kwargs (order doesn&#39;t matter, but uses keywords), but not</span>
<span class="sd">        both.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        oversample</span>
<span class="sd">            Oversample (upsample) a the MultiDimBinning</span>

<span class="sd">        OneDimBinning.downsample</span>
<span class="sd">            The method actually called to perform the downsampling for each</span>
<span class="sd">            OneDimBinning within this MultiDimBinning object.</span>

<span class="sd">        OneDimBinning.oversample</span>
<span class="sd">            Same, but oversample (upsample) a OneDimBinning object</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;`downsample` function does not currenty support bin masking&quot;</span>

        <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">factors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_args_kwargs_to_list</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">new_binning</span> <span class="o">=</span> <span class="p">[</span><span class="n">dim</span><span class="o">.</span><span class="n">downsample</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dimensions</span><span class="p">,</span> <span class="n">factors</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">MultiDimBinning</span><span class="p">(</span><span class="n">new_binning</span><span class="p">)</span></div>


<div class="viewcode-block" id="MultiDimBinning.assert_array_fits">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.MultiDimBinning.assert_array_fits">[docs]</a>
    <span class="k">def</span> <span class="nf">assert_array_fits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if a 2D array of values fits into the defined bins (i.e., has</span>
<span class="sd">        the exact shape defined by this binning).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        array : 2D array (or sequence-of-sequences)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fits : bool, True if array fits or False otherwise</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError if array shape does not match the binning shape</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Array shape </span><span class="si">%s</span><span class="s1"> does not match binning shape </span><span class="si">%s</span><span class="s1">&#39;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="MultiDimBinning.assert_compat">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.MultiDimBinning.assert_compat">[docs]</a>
    <span class="k">def</span> <span class="nf">assert_compat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if a (possibly different) binning can map onto the defined</span>
<span class="sd">        binning. Allows for simple re-binning schemes (but no interpolation).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Binning or container with attribute &quot;binning&quot;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        compat : bool</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">MultiDimBinning</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">MultiDimBinning</span><span class="p">):</span>
                    <span class="n">other</span> <span class="o">=</span> <span class="n">val</span>
                    <span class="k">break</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">MultiDimBinning</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">other</span> <span class="o">==</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">my_dim</span><span class="p">,</span> <span class="n">other_dim</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">my_dim</span><span class="o">.</span><span class="n">assert_compat</span><span class="p">(</span><span class="n">other_dim</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="MultiDimBinning.squeeze">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.MultiDimBinning.squeeze">[docs]</a>
    <span class="k">def</span> <span class="nf">squeeze</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove any singleton dimensions (i.e. that have only a single bin).</span>
<span class="sd">        Analagous to `numpy.squeeze`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MultiDimBinning with only non-singleton dimensions</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;`squeeze` function does not currenty support bin masking&quot;</span>

        <span class="k">return</span> <span class="n">MultiDimBinning</span><span class="p">(</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_args_kwargs_to_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Take either args or kwargs (but not both) and convert into a simple</span>
<span class="sd">        sequence of values. Broadcasts a single arg to all dimensions.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Either args (values specified by order and not&#39;</span>
                             <span class="s1">&#39; specified by name) or kwargs (values specified&#39;</span>
                             <span class="s1">&#39; by name=value pairs) can be used, but not&#39;</span>
                             <span class="s1">&#39; both.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dims</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dims</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Specified </span><span class="si">%s</span><span class="s1"> args, but binning is&#39;</span>
                                 <span class="s1">&#39; </span><span class="si">%s</span><span class="s1">-dim.&#39;</span> <span class="o">%</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dims</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">args</span>

        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Specified dimensions &quot;</span><span class="si">%s</span><span class="s1">&quot; but this has&#39;</span>
                             <span class="s1">&#39; dimensions &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">kwargs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">]</span>

<div class="viewcode-block" id="MultiDimBinning.ito">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.MultiDimBinning.ito">[docs]</a>
    <span class="k">def</span> <span class="nf">ito</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert units in-place. Cf. Pint&#39;s `ito` method.&quot;&quot;&quot;</span>
        <span class="n">units_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_args_kwargs_to_list</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">units</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iterdims</span><span class="p">(),</span> <span class="n">units_list</span><span class="p">):</span>
            <span class="n">dim</span><span class="o">.</span><span class="n">ito</span><span class="p">(</span><span class="n">units</span><span class="p">)</span></div>


<div class="viewcode-block" id="MultiDimBinning.to">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.MultiDimBinning.to">[docs]</a>
    <span class="k">def</span> <span class="nf">to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> <span class="c1"># pylint: disable=invalid-name</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert the contained dimensions to the passed units. Unspecified</span>
<span class="sd">        dimensions will be omitted.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">units_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_args_kwargs_to_list</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">new_binnings</span> <span class="o">=</span> <span class="p">[</span><span class="n">dim</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">units</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">units</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iterdims</span><span class="p">(),</span> <span class="n">units_list</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">MultiDimBinning</span><span class="p">(</span><span class="n">new_binnings</span><span class="p">)</span></div>


<div class="viewcode-block" id="MultiDimBinning.meshgrid">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.MultiDimBinning.meshgrid">[docs]</a>
    <span class="k">def</span> <span class="nf">meshgrid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">entity</span><span class="p">,</span> <span class="n">attach_units</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply NumPy&#39;s meshgrid method on various entities of interest.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        entity : string</span>
<span class="sd">            Can be any attribute of OneDimBinning that returns a 1D array with</span>
<span class="sd">            units. E.g., one of &#39;midpoints&#39;, &#39;weighted_centers&#39;, &#39;bin_edges&#39;,</span>
<span class="sd">            &#39;bin_widths&#39;, or &#39;weighted_bin_widths&#39;</span>

<span class="sd">        attach_units : bool</span>
<span class="sd">            Whether to attach units to the result (can save computation time by</span>
<span class="sd">            not doing so).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        [X1, X2,..., XN] : list of numpy ndarray or Pint quantities of the same</span>
<span class="sd">            One ndarray or quantity is returned per dimension; see docs for</span>
<span class="sd">            `numpy.meshgrid` for details</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.meshgrid</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">entity</span> <span class="o">=</span> <span class="n">entity</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

        <span class="n">arrays</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">units</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterdims</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">quantity_array</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">entity</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="s2">&quot;Dimension </span><span class="si">%s</span><span class="s2"> does not contain entity &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span><span class="p">,</span> <span class="n">dim</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">entity</span>
                <span class="p">)</span>
                <span class="k">raise</span>
            <span class="k">if</span> <span class="n">attach_units</span><span class="p">:</span>
                <span class="n">units</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">quantity_array</span><span class="o">.</span><span class="n">units</span><span class="p">)</span>
            <span class="n">arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">quantity_array</span><span class="o">.</span><span class="n">magnitude</span><span class="p">)</span>

        <span class="c1"># NOTE: numpy versions prior to 1.13.0, meshgrid returned float64 even</span>
        <span class="c1"># if inputs are float32 to mesghrid. Use `astype` as a fix. Note that</span>
        <span class="c1"># since `astype` already creates a copy of the array even if dtype of</span>
        <span class="c1"># input is the same, setting `copy` to False is ok in the argument to</span>
        <span class="c1"># meshgrid; i.e., if a user modifies an element of the returned array,</span>
        <span class="c1"># it should not affect the original `entity` from which the meshgrid</span>
        <span class="c1"># was generated.</span>
        <span class="n">mg</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">FTYPE</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">attach_units</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">m</span><span class="o">*</span><span class="n">u</span> <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mg</span><span class="p">,</span> <span class="n">units</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">mg</span></div>


    <span class="c1"># TODO: modify technique depending upon grid size for memory concerns, or</span>
    <span class="c1"># even take a `method` argument to force method manually.</span>
<div class="viewcode-block" id="MultiDimBinning.bin_volumes">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.MultiDimBinning.bin_volumes">[docs]</a>
    <span class="k">def</span> <span class="nf">bin_volumes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attach_units</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Bin &quot;volumes&quot; defined in `num_dims`-dimensions</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        attach_units : bool</span>
<span class="sd">            Whether to attach pint units to the resulting array</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        volumes : array</span>
<span class="sd">            Bin volumes</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">meshgrid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">entity</span><span class="o">=</span><span class="s1">&#39;bin_widths&#39;</span><span class="p">,</span> <span class="n">attach_units</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">volumes</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="n">meshgrid</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">attach_units</span><span class="p">:</span>
            <span class="n">volumes</span> <span class="o">*=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="p">(</span><span class="n">ureg</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">units</span><span class="p">))</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterdims</span><span class="p">()))</span>
        <span class="k">return</span> <span class="n">volumes</span></div>


<div class="viewcode-block" id="MultiDimBinning.weighted_bin_volumes">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.MultiDimBinning.weighted_bin_volumes">[docs]</a>
    <span class="k">def</span> <span class="nf">weighted_bin_volumes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attach_units</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Bin &quot;volumes&quot; defined in `num_dims`-dimensions, but unlike</span>
<span class="sd">        `bin_volumes`, the volume is evaluated in the space of the binning.</span>
<span class="sd">        E.g., logarithmic bins have `weighted_bin_volumes` of equal size in</span>
<span class="sd">        log-space.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        attach_units : bool</span>
<span class="sd">            Whether to attach pint units to the resulting array</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        volumes : array</span>
<span class="sd">            Bin volumes</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">meshgrid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">entity</span><span class="o">=</span><span class="s1">&#39;weighted_bin_widths&#39;</span><span class="p">,</span> <span class="n">attach_units</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">volumes</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="n">meshgrid</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">attach_units</span><span class="p">:</span>
            <span class="c1"># NOTE we use the units from `weighted_bin_widths` because these</span>
            <span class="c1"># can be different from those of the dimension</span>
            <span class="n">volumes</span> <span class="o">*=</span> <span class="n">reduce</span><span class="p">(</span>
                <span class="n">mul</span><span class="p">,</span>
                <span class="p">(</span><span class="n">ureg</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">weighted_bin_widths</span><span class="o">.</span><span class="n">units</span><span class="p">))</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterdims</span><span class="p">()),</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">volumes</span></div>


<div class="viewcode-block" id="MultiDimBinning.empty">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.MultiDimBinning.empty">[docs]</a>
    <span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">map_kw</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a Map whose hist is an &quot;empty&quot; numpy ndarray with same</span>
<span class="sd">        dimensions as this binning.</span>

<span class="sd">        The contents are not _actually_ empty, just undefined. Therefore be</span>
<span class="sd">        careful to populate the array prior to using its contents.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : string</span>
<span class="sd">            Name of the Map</span>

<span class="sd">        map_kw : None or dict</span>
<span class="sd">            keyword arguments sent to instantiate the new Map (except `name`</span>
<span class="sd">            which is specified above)</span>

<span class="sd">        **kwargs</span>
<span class="sd">            keyword arguments passed on to numpy.empty() (except `shape` which</span>
<span class="sd">            must be omitted)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        map : Map</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="s1">&#39;shape&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span>
        <span class="k">if</span> <span class="n">map_kw</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">map_kw</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="s1">&#39;dtype&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">FTYPE</span>
        <span class="n">hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_map_class</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">hist</span><span class="o">=</span><span class="n">hist</span><span class="p">,</span> <span class="n">binning</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">map_kw</span><span class="p">)</span> <span class="c1"># pylint: disable=not-callable</span></div>


<div class="viewcode-block" id="MultiDimBinning.zeros">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.MultiDimBinning.zeros">[docs]</a>
    <span class="k">def</span> <span class="nf">zeros</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">map_kw</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a numpy ndarray filled with 0&#39;s with same dimensions as this</span>
<span class="sd">        binning.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : string</span>
<span class="sd">            Name of the map</span>

<span class="sd">        map_kw : None or dict</span>
<span class="sd">            keyword arguments sent to instantiate the new Map (except `name`</span>
<span class="sd">            which is specified above)</span>

<span class="sd">        **kwargs</span>
<span class="sd">            keyword arguments passed on to numpy.zeros() (except `shape` which</span>
<span class="sd">            must be omitted)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        map : Map</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="s1">&#39;shape&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span>
        <span class="k">if</span> <span class="n">map_kw</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">map_kw</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="s1">&#39;dtype&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">FTYPE</span>
        <span class="n">hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_map_class</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">hist</span><span class="o">=</span><span class="n">hist</span><span class="p">,</span> <span class="n">binning</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">map_kw</span><span class="p">)</span> <span class="c1"># pylint: disable=not-callable</span></div>


<div class="viewcode-block" id="MultiDimBinning.ones">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.MultiDimBinning.ones">[docs]</a>
    <span class="k">def</span> <span class="nf">ones</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">map_kw</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a numpy ndarray filled with 1&#39;s with same dimensions as this</span>
<span class="sd">        binning.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : string</span>
<span class="sd">            Name of the map</span>

<span class="sd">        map_kw : None or dict</span>
<span class="sd">            keyword arguments sent to instantiate the new Map (except `name`</span>
<span class="sd">            which is specified above)</span>

<span class="sd">        **kwargs</span>
<span class="sd">            keyword arguments passed on to numpy.ones() (except `shape` which</span>
<span class="sd">            must be omitted)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        map : Map</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="s1">&#39;shape&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span>
        <span class="k">if</span> <span class="n">map_kw</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">map_kw</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="s1">&#39;dtype&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">FTYPE</span>
        <span class="n">hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_map_class</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">hist</span><span class="o">=</span><span class="n">hist</span><span class="p">,</span> <span class="n">binning</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">map_kw</span><span class="p">)</span> <span class="c1"># pylint: disable=not-callable</span></div>


<div class="viewcode-block" id="MultiDimBinning.full">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.MultiDimBinning.full">[docs]</a>
    <span class="k">def</span> <span class="nf">full</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">map_kw</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a map whose `hist` is filled with `fill_value` of same</span>
<span class="sd">        dimensions as this binning.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fill_value</span>
<span class="sd">            Value with which to fill the map</span>

<span class="sd">        name : string</span>
<span class="sd">            Name of the map</span>

<span class="sd">        map_kw : None or dict</span>
<span class="sd">            keyword arguments sent to instantiate the new Map (except `name`</span>
<span class="sd">            which is specified above)</span>

<span class="sd">        **kwargs</span>
<span class="sd">            keyword arguments passed on to numpy.fill_value() (except `shape`,</span>
<span class="sd">            which must be omitted)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        map : Map</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="s1">&#39;shape&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span>
        <span class="k">if</span> <span class="n">map_kw</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">map_kw</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="s1">&#39;dtype&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">FTYPE</span>
        <span class="n">hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_map_class</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">hist</span><span class="o">=</span><span class="n">hist</span><span class="p">,</span> <span class="n">binning</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">map_kw</span><span class="p">)</span> <span class="c1"># pylint: disable=not-callable</span></div>


    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">OneDimBinning</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dims</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">MultiDimBinning</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">recursiveEquality</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hashable_state</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">hashable_state</span><span class="p">)</span>

    <span class="c1"># TODO: remove this method, as it should just be considered an outer</span>
    <span class="c1"># product to increase dimensionality (i.e. the &quot;*&quot; operator, or __mul__</span>
    <span class="c1"># makes more sense than &quot;+&quot; or __add__)?</span>
    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">MultiDimBinning</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">MultiDimBinning</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">Mapping</span><span class="p">,</span> <span class="n">OneDimBinning</span><span class="p">)):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="p">[</span><span class="n">other</span><span class="p">]</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">MultiDimBinning</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">MultiDimBinning</span><span class="p">(</span><span class="n">chain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>

    <span class="c1"># TODO: should __getattr__ raise its own exception if the attr is not found</span>
    <span class="c1"># as a dimension rather than call parent&#39;s __getattribute__ method, since</span>
    <span class="c1"># presumably that already failed?</span>
    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="c1"># If youve gotten here, __getattribute__ has failed. Try to get the</span>
        <span class="c1"># attr as a contained dimension:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
            <span class="c1"># If that failed, re-run parent&#39;s __getattribute__ which will raise</span>
            <span class="c1"># an appropriate exception</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

    <span class="c1"># TODO: refine handling of ellipsis such that the following work as in</span>
    <span class="c1"># Numpy:</span>
    <span class="c1">#       * [&#39;dim0&#39;, &#39;dim3&#39;, ...]</span>
    <span class="c1">#       * [&#39;dim0&#39;, 3, ...]</span>
    <span class="c1">#       * [...]</span>
    <span class="c1">#       * [0, ...]</span>
    <span class="c1">#       * [..., 2]</span>
    <span class="c1">#       * [..., 2, 1, 4]</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Interpret indices as indexing bins and *not* bin edges.</span>
<span class="sd">        Indices refer to dimensions in same order they were specified at</span>
<span class="sd">        instantiation, and all dimensions must be present.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : str, int, len-N-sequence of ints, or len-N-sequence of slices</span>
<span class="sd">            If str is passed: Return the binning corresponding to the named</span>
<span class="sd">            dimension</span>

<span class="sd">            If an integer is passed:</span>
<span class="sd">              * If num_dims is 4, `index` indexes into the bins of the sole</span>
<span class="sd">                OneDimBinning. The bin is returned.</span>
<span class="sd">              * If num_dims &gt; 1, `index` indexes which contained OneDimBinning</span>
<span class="sd">                object to return.</span>
<span class="sd">            If a len-N-sequence of integers or slices is passed, dimensions are</span>
<span class="sd">            indexed by these in the order in which dimensions are stored</span>
<span class="sd">            internally.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A MultiDimBinning object new Binning object but with the bins specified</span>
<span class="sd">        by `index`. Whether or not behavior is logarithmic is unchanged.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If ellipsis, return everything</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="c1"># If arg is a string, it should specify a dimension</span>
        <span class="c1"># Check if it doesn, and if so return that OneDimBinning for that dimension</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>

            <span class="c1"># Check there is no mask defined (a mask does not make sense on a per dimension basis, </span>
            <span class="c1"># so cannot apply this operation when masking is involved)</span>
            <span class="c1">#TODO Removed for now as causes issues, need to come back to think about this...</span>
            <span class="c1"># if self.mask is not None :</span>
            <span class="c1">#     raise ValueError(&quot;Cannot extract a single binning dimension when a mask is used&quot;) #TODO This gets called duign deepcopy with index==__deppcopy__??!?!? If I assert instead of using ValueError theneverything fails. Not sure what is going on here...</span>

            <span class="c1"># Find the dimension</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterdims</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">index</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">d</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;index &#39;</span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s2">&#39; not in </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># TODO: implement a &quot;linearization&quot; like np.flatten() to iterate</span>
        <span class="c1"># through each bin individually without hassle for the user...</span>
        <span class="c1">#if self.num_dims == 1 and np.isscalar(index):</span>
        <span class="c1">#    return self._dimensions[0]</span>

        <span class="c1"># If here, the index is a numerical, numpy-comaptible index</span>
        <span class="c1"># Do some pre-processing on it to get it in the right format...</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="n">index</span><span class="p">]</span>

        <span class="c1"># Turn any inetger indices into an equivalent single element slice</span>
        <span class="c1"># This ensures the array dimensionality is maintained</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">:</span> <span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>  <span class="nb">slice</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">:</span> <span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>  <span class="nb">slice</span><span class="p">(</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span> <span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
            <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Binning idx is </span><span class="si">%s</span><span class="s1">, int or slice is needed&#39;</span><span class="o">%</span><span class="n">idx</span><span class="p">)</span>

        <span class="c1"># Get the new binning, based on the index</span>
        <span class="n">input_dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">input_dim</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dims</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Binning is </span><span class="si">%d</span><span class="s1">D, but </span><span class="si">%d</span><span class="s1">D indexing was passed&#39;</span>
                             <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_dims</span><span class="p">,</span> <span class="n">input_dim</span><span class="p">))</span>

        <span class="n">new_binning</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;dimensions&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">dim</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">dim</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span>
                                      <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iterdims</span><span class="p">(),</span> <span class="n">index</span><span class="p">)]}</span>

        <span class="c1"># Also update mask, if there is one</span>
        <span class="n">new_mask</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">MultiDimBinning</span><span class="p">(</span><span class="o">**</span><span class="n">new_binning</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">new_mask</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterate over dimensions. Use `iterbins` to iterate over bins.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dimensions</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_dims</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></div>



<div class="viewcode-block" id="test_OneDimBinning">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.test_OneDimBinning">[docs]</a>
<span class="k">def</span> <span class="nf">test_OneDimBinning</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Unit tests for OneDimBinning class&quot;&quot;&quot;</span>
    <span class="c1"># pylint: disable=line-too-long, wrong-import-position</span>
    <span class="kn">import</span> <span class="nn">pickle</span>
    <span class="kn">import</span> <span class="nn">os</span>
    <span class="kn">import</span> <span class="nn">shutil</span>
    <span class="kn">import</span> <span class="nn">tempfile</span>
    <span class="c1"># needed so that eval(repr(b)) works</span>
    <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">array</span><span class="p">,</span> <span class="n">float32</span><span class="p">,</span> <span class="n">float64</span> <span class="c1"># pylint: disable=unused-variable</span>

    <span class="n">b1</span> <span class="o">=</span> <span class="n">OneDimBinning</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;true_energy&#39;</span><span class="p">,</span> <span class="n">num_bins</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">is_log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                       <span class="n">domain</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">80</span><span class="p">]</span><span class="o">*</span><span class="n">ureg</span><span class="o">.</span><span class="n">GeV</span><span class="p">,</span> <span class="n">tex</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;E_{\rm true}&#39;</span><span class="p">,</span>
                       <span class="n">bin_names</span><span class="o">=</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">40</span><span class="p">)])</span>
    <span class="n">b2</span> <span class="o">=</span> <span class="n">OneDimBinning</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;coszen&#39;</span><span class="p">,</span> <span class="n">num_bins</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">is_lin</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                       <span class="n">domain</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">bin_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">tex</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;\cos\theta&#39;</span><span class="p">)</span>
    <span class="n">b3</span> <span class="o">=</span> <span class="n">OneDimBinning</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;reco_energy&#39;</span><span class="p">,</span> <span class="n">num_bins</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">is_log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                       <span class="n">domain</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">80</span><span class="p">]</span><span class="o">*</span><span class="n">ureg</span><span class="o">.</span><span class="n">GeV</span><span class="p">,</span> <span class="n">tex</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;E_{\rm reco}&#39;</span><span class="p">,</span>
                       <span class="n">bin_names</span><span class="o">=</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">40</span><span class="p">)])</span>

    <span class="c1"># Test label</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">b1</span><span class="o">.</span><span class="n">label</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">b1</span><span class="o">.</span><span class="n">label</span>

    <span class="k">assert</span> <span class="n">b1</span><span class="o">.</span><span class="n">basename_binning</span> <span class="o">==</span> <span class="n">b1</span><span class="o">.</span><span class="n">basename_binning</span>
    <span class="k">assert</span> <span class="n">b1</span><span class="o">.</span><span class="n">basename_binning</span> <span class="o">==</span> <span class="n">b3</span><span class="o">.</span><span class="n">basename_binning</span>
    <span class="k">assert</span> <span class="n">b1</span><span class="o">.</span><span class="n">basename_binning</span> <span class="o">!=</span> <span class="n">b2</span><span class="o">.</span><span class="n">basename_binning</span>
    
    <span class="c1"># Oversampling/downsampling</span>
    <span class="n">b1_over</span> <span class="o">=</span> <span class="n">b1</span><span class="o">.</span><span class="n">oversample</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">b1_over</span><span class="o">.</span><span class="n">is_bin_spacing_log_uniform</span><span class="p">(</span><span class="n">b1_over</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">)</span>
    <span class="n">b1_down</span> <span class="o">=</span> <span class="n">b1</span><span class="o">.</span><span class="n">downsample</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">b1_down</span><span class="o">.</span><span class="n">is_bin_spacing_log_uniform</span><span class="p">(</span><span class="n">b1_down</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">b1_down</span><span class="o">.</span><span class="n">is_compat</span><span class="p">(</span><span class="n">b1</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">b1</span><span class="o">.</span><span class="n">is_compat</span><span class="p">(</span><span class="n">b1_over</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">b1_down</span><span class="o">.</span><span class="n">is_compat</span><span class="p">(</span><span class="n">b1_over</span><span class="p">)</span>
    
    <span class="c1"># Bin width consistency</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">b1_over</span><span class="o">.</span><span class="n">bin_widths</span><span class="o">.</span><span class="n">m</span><span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">b1</span><span class="o">.</span><span class="n">bin_widths</span><span class="o">.</span><span class="n">m</span><span class="p">),</span>
        <span class="o">**</span><span class="n">ALLCLOSE_KW</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">b1_down</span><span class="o">.</span><span class="n">bin_widths</span><span class="o">.</span><span class="n">m</span><span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">b1</span><span class="o">.</span><span class="n">bin_widths</span><span class="o">.</span><span class="n">m</span><span class="p">),</span>
        <span class="o">**</span><span class="n">ALLCLOSE_KW</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">b1_over</span><span class="o">.</span><span class="n">bin_widths</span><span class="o">.</span><span class="n">m</span><span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">b1_down</span><span class="o">.</span><span class="n">bin_widths</span><span class="o">.</span><span class="n">m</span><span class="p">),</span>
        <span class="o">**</span><span class="n">ALLCLOSE_KW</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="c1"># Weighted bin widths must also sum up to the same total width</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">b1_over</span><span class="o">.</span><span class="n">weighted_bin_widths</span><span class="o">.</span><span class="n">m</span><span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">b1</span><span class="o">.</span><span class="n">weighted_bin_widths</span><span class="o">.</span><span class="n">m</span><span class="p">),</span>
        <span class="o">**</span><span class="n">ALLCLOSE_KW</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">b1_down</span><span class="o">.</span><span class="n">weighted_bin_widths</span><span class="o">.</span><span class="n">m</span><span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">b1</span><span class="o">.</span><span class="n">weighted_bin_widths</span><span class="o">.</span><span class="n">m</span><span class="p">),</span>
        <span class="o">**</span><span class="n">ALLCLOSE_KW</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">b1_over</span><span class="o">.</span><span class="n">weighted_bin_widths</span><span class="o">.</span><span class="n">m</span><span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">b1_down</span><span class="o">.</span><span class="n">weighted_bin_widths</span><span class="o">.</span><span class="n">m</span><span class="p">),</span>
        <span class="o">**</span><span class="n">ALLCLOSE_KW</span><span class="p">,</span>
    <span class="p">)</span>
    
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;len(b1): </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">b1</span><span class="p">))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;b1: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">b1</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;b2: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">b2</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;b1.oversample(10): </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">b1</span><span class="o">.</span><span class="n">oversample</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;b1.oversample(1): </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">b1</span><span class="o">.</span><span class="n">oversample</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
    <span class="c1"># Slicing</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;b1[1:5]: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">b1</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">5</span><span class="p">])</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;b1[:]: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">b1</span><span class="p">[:])</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;b1[-1]: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">b1</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;b1[:-1]: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">b1</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;copy(b1): </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="p">(</span><span class="n">b1</span><span class="p">))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;deepcopy(b1): </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">b1</span><span class="p">))</span>
    <span class="c1"># Indexing by Ellipsis</span>
    <span class="k">assert</span> <span class="n">b1</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">==</span> <span class="n">b1</span>
    <span class="c1"># Pickling</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span>
    <span class="n">b1_loaded</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">b1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span>
    <span class="n">b1_loaded</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">b1_loaded</span> <span class="o">==</span> <span class="n">b1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">b1</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="kc">False</span>

    <span class="n">b3</span> <span class="o">=</span> <span class="n">OneDimBinning</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;distance&#39;</span><span class="p">,</span> <span class="n">num_bins</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">is_log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                       <span class="n">domain</span><span class="o">=</span><span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span><span class="o">*</span><span class="n">ureg</span><span class="o">.</span><span class="n">m</span><span class="p">)</span>
    <span class="n">b4</span> <span class="o">=</span> <span class="n">OneDimBinning</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;distance&#39;</span><span class="p">,</span> <span class="n">num_bins</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">is_log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                       <span class="n">domain</span><span class="o">=</span><span class="p">[</span><span class="mf">1e5</span><span class="p">,</span> <span class="mf">1e7</span><span class="p">]</span><span class="o">*</span><span class="n">ureg</span><span class="o">.</span><span class="n">um</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">hash_obj</span><span class="p">(</span><span class="n">b3</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">b3</span><span class="o">.</span><span class="n">hash</span>
    <span class="n">_</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="n">b3</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">hash_obj</span><span class="p">(</span><span class="n">b3</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">b3</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">hash</span> <span class="c1"># pylint: disable=no-member</span>
    <span class="n">_</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="n">b3</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">b3</span><span class="o">.</span><span class="n">normalize_values</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">b4</span><span class="o">.</span><span class="n">normalize_values</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">_</span> <span class="o">=</span> <span class="n">hash_obj</span><span class="p">(</span><span class="n">b3</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">b3</span><span class="o">.</span><span class="n">hash</span>
    <span class="n">_</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="n">b3</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">hash_obj</span><span class="p">(</span><span class="n">b3</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">b3</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">hash</span> <span class="c1"># pylint: disable=no-member</span>
    <span class="n">_</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="n">b3</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Without rounding, converting bin edges to base units yields different</span>
    <span class="c1"># results due to finite precision effects</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">normQuant</span><span class="p">(</span><span class="n">b3</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">sigfigs</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                  <span class="o">!=</span> <span class="n">normQuant</span><span class="p">(</span><span class="n">b4</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">sigfigs</span><span class="o">=</span><span class="kc">None</span><span class="p">))</span>

    <span class="c1"># Normalize function should take care of this</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">normQuant</span><span class="p">(</span><span class="n">b3</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">sigfigs</span><span class="o">=</span><span class="n">HASH_SIGFIGS</span><span class="p">,</span> <span class="n">full_norm</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                  <span class="o">==</span> <span class="n">normQuant</span><span class="p">(</span><span class="n">b4</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">sigfigs</span><span class="o">=</span><span class="n">HASH_SIGFIGS</span><span class="p">,</span> <span class="n">full_norm</span><span class="o">=</span><span class="kc">True</span><span class="p">)),</span> \
            <span class="s1">&#39;normQuant(b3.bin_edges)=</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="s1">normQuant(b4.bin_edges)=</span><span class="se">\n</span><span class="si">%s</span><span class="s1">&#39;</span> \
            <span class="o">%</span><span class="p">(</span><span class="n">normQuant</span><span class="p">(</span><span class="n">b3</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">sigfigs</span><span class="o">=</span><span class="n">HASH_SIGFIGS</span><span class="p">,</span> <span class="n">full_norm</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
              <span class="n">normQuant</span><span class="p">(</span><span class="n">b4</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">sigfigs</span><span class="o">=</span><span class="n">HASH_SIGFIGS</span><span class="p">,</span> <span class="n">full_norm</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

    <span class="c1"># And the hashes should be equal, reflecting the latter result</span>
    <span class="k">assert</span> <span class="n">b3</span><span class="o">.</span><span class="n">hash</span> <span class="o">==</span> <span class="n">b4</span><span class="o">.</span><span class="n">hash</span><span class="p">,</span> \
            <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">b3=</span><span class="si">%s</span><span class="se">\n</span><span class="s1">b4=</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">b3</span><span class="o">.</span><span class="n">hashable_state</span><span class="p">,</span> <span class="n">b4</span><span class="o">.</span><span class="n">hashable_state</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">b3</span><span class="o">.</span><span class="n">hash</span> <span class="o">==</span> <span class="n">b4</span><span class="o">.</span><span class="n">hash</span><span class="p">,</span> <span class="s1">&#39;b3.hash=</span><span class="si">%s</span><span class="s1">; b4.hash=</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">b3</span><span class="o">.</span><span class="n">hash</span><span class="p">,</span> <span class="n">b4</span><span class="o">.</span><span class="n">hash</span><span class="p">)</span>

    <span class="n">s</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">b3</span><span class="p">,</span> <span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span>
    <span class="n">b3_loaded</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">b3_loaded</span> <span class="o">==</span> <span class="n">b3</span>

    <span class="n">testdir</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkdtemp</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="p">[</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">b3</span><span class="p">,</span> <span class="n">b4</span><span class="p">]:</span>
            <span class="k">assert</span> <span class="nb">eval</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> <span class="o">==</span> <span class="n">b</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="c1"># pylint: disable=eval-used</span>
            <span class="n">b_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">testdir</span><span class="p">,</span> <span class="s1">&#39;one_dim_binning.json&#39;</span><span class="p">)</span>
            <span class="n">b</span><span class="o">.</span><span class="n">to_json</span><span class="p">(</span><span class="n">b_file</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">b_</span> <span class="o">=</span> <span class="n">OneDimBinning</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">b_file</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">b_</span> <span class="o">==</span> <span class="n">b</span><span class="p">,</span> <span class="s1">&#39;b=</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="s1">b_=</span><span class="se">\n</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">b_</span><span class="p">)</span>
            <span class="n">jsons</span><span class="o">.</span><span class="n">to_json</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">b_file</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">b_</span> <span class="o">=</span> <span class="n">OneDimBinning</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">b_file</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">b_</span> <span class="o">==</span> <span class="n">b</span><span class="p">,</span> <span class="s1">&#39;b=</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="s1">b_=</span><span class="se">\n</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">b_</span><span class="p">)</span>

            <span class="c1"># Had bug where datastruct containing MultiDimBinning failed to be</span>
            <span class="c1"># saved. # Test tuple containing list containing OrderedDict</span>
            <span class="c1"># containing OneDimBinning here.</span>
            <span class="n">struct</span> <span class="o">=</span> <span class="p">([</span><span class="n">OrderedDict</span><span class="p">(</span><span class="n">odb</span><span class="o">=</span><span class="n">b</span><span class="p">)],)</span>
            <span class="n">jsons</span><span class="o">.</span><span class="n">to_json</span><span class="p">(</span><span class="n">struct</span><span class="p">,</span> <span class="n">b_file</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">loaded</span> <span class="o">=</span> <span class="n">jsons</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">b_file</span><span class="p">)</span>
            <span class="n">b_</span> <span class="o">=</span> <span class="n">OneDimBinning</span><span class="p">(</span><span class="o">**</span><span class="n">loaded</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;odb&#39;</span><span class="p">])</span>
            <span class="k">assert</span> <span class="n">b_</span> <span class="o">==</span> <span class="n">b</span>

            <span class="c1"># Now try with pickle</span>
            <span class="n">b_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">testdir</span><span class="p">,</span> <span class="s1">&#39;one_dim_binning.pkl&#39;</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">b_file</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fobj</span><span class="p">:</span>
                <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">struct</span><span class="p">,</span> <span class="n">fobj</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">b_file</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fobj</span><span class="p">:</span>
                <span class="n">loaded</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fobj</span><span class="p">)</span>
            <span class="n">b_</span> <span class="o">=</span> <span class="n">loaded</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;odb&#39;</span><span class="p">]</span>
            <span class="k">assert</span> <span class="n">b_</span> <span class="o">==</span> <span class="n">b</span>

    <span class="k">except</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;b that failed: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">raise</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">testdir</span><span class="p">,</span> <span class="n">ignore_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;&lt;&lt; PASS : test_OneDimBinning &gt;&gt;&#39;</span><span class="p">)</span></div>



<div class="viewcode-block" id="test_MultiDimBinning">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.binning.test_MultiDimBinning">[docs]</a>
<span class="k">def</span> <span class="nf">test_MultiDimBinning</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Unit tests for MultiDimBinning class&quot;&quot;&quot;</span>
    <span class="c1"># pylint: disable=wrong-import-position</span>
    <span class="kn">import</span> <span class="nn">pickle</span>
    <span class="kn">import</span> <span class="nn">os</span>
    <span class="kn">import</span> <span class="nn">shutil</span>
    <span class="kn">import</span> <span class="nn">tempfile</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="kn">import</span> <span class="nn">pytest</span>
    <span class="c1"># needed so that eval(repr(mdb)) works</span>
    <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">array</span><span class="p">,</span> <span class="n">float32</span><span class="p">,</span> <span class="n">float64</span> <span class="c1"># pylint: disable=unused-variable</span>

    <span class="n">b1</span> <span class="o">=</span> <span class="n">OneDimBinning</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;energy&#39;</span><span class="p">,</span> <span class="n">num_bins</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">is_log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                       <span class="n">domain</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">80</span><span class="p">]</span><span class="o">*</span><span class="n">ureg</span><span class="o">.</span><span class="n">GeV</span><span class="p">)</span>
    <span class="n">b2</span> <span class="o">=</span> <span class="n">OneDimBinning</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;coszen&#39;</span><span class="p">,</span> <span class="n">num_bins</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">is_lin</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                       <span class="n">domain</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">mdb</span> <span class="o">=</span> <span class="n">MultiDimBinning</span><span class="p">([</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">])</span>

    <span class="k">assert</span> <span class="nb">eval</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">mdb</span><span class="p">))</span> <span class="o">==</span> <span class="n">mdb</span> <span class="c1"># pylint: disable=eval-used</span>

    <span class="n">_</span> <span class="o">=</span> <span class="n">hash_obj</span><span class="p">(</span><span class="n">mdb</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">mdb</span><span class="o">.</span><span class="n">hash</span>
    <span class="n">_</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="n">mdb</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">hash_obj</span><span class="p">(</span><span class="n">mdb</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">mdb</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">hash</span>
    <span class="n">_</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="n">mdb</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">mdb</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">mdb</span><span class="p">[</span><span class="mi">0</span><span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">mdb</span><span class="p">[</span><span class="mi">0</span><span class="p">:,</span> <span class="mi">0</span><span class="p">:]</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">mdb</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">:]</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">mdb</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># TODO: following should work as in Numpy:</span>
    <span class="c1"># assert mdb[:] == mdb</span>
    <span class="c1"># assert mdb[0] == b1</span>
    <span class="c1"># assert mdb[1] == b2</span>
    <span class="k">assert</span> <span class="n">mdb</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">==</span> <span class="n">mdb</span>

    <span class="c1"># Index by dim names</span>
    <span class="k">assert</span> <span class="n">mdb</span><span class="p">[</span><span class="s2">&quot;energy&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">b1</span>
    <span class="k">assert</span> <span class="n">mdb</span><span class="p">[</span><span class="s2">&quot;coszen&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">b2</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">mdb</span><span class="p">[</span><span class="s2">&quot;nonexistent&quot;</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;non-existent name should raise exception&#39;</span><span class="p">)</span>

    <span class="c1"># Index by dim number</span>
    <span class="k">assert</span> <span class="n">MultiDimBinning</span><span class="p">([</span><span class="n">b1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">MultiDimBinning</span><span class="p">([</span><span class="n">b1</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">mdb</span><span class="o">.</span><span class="n">energy</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;copy(mdb): </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="p">(</span><span class="n">mdb</span><span class="p">))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;deepcopy(mdb): </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">mdb</span><span class="p">))</span>
    <span class="k">assert</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">mdb</span><span class="p">)</span> <span class="o">==</span> <span class="n">mdb</span>

    <span class="n">s</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">mdb</span><span class="p">,</span> <span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span>
    <span class="n">mdb2</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">mdb2</span> <span class="o">==</span> <span class="n">mdb</span>

    <span class="n">s</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">mdb</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span>
    <span class="n">mdb2</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">mdb2</span> <span class="o">==</span> <span class="n">mdb</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="n">binning</span> <span class="o">=</span> <span class="n">MultiDimBinning</span><span class="p">([</span>
        <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;energy&#39;</span><span class="p">,</span> <span class="n">is_log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">80</span><span class="p">]</span><span class="o">*</span><span class="n">ureg</span><span class="o">.</span><span class="n">GeV</span><span class="p">,</span> <span class="n">num_bins</span><span class="o">=</span><span class="mi">40</span><span class="p">),</span>
        <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;coszen&#39;</span><span class="p">,</span> <span class="n">is_lin</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">num_bins</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
    <span class="p">])</span>

    <span class="n">ord_dict_of_binnings</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">([(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">mdb</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">binning</span><span class="p">)])</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">hash_obj</span><span class="p">(</span><span class="n">ord_dict_of_binnings</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">normQuant</span><span class="p">(</span><span class="n">ord_dict_of_binnings</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">flatindex</span><span class="p">,</span> <span class="n">this_bin</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">binning</span><span class="o">.</span><span class="n">iterbins</span><span class="p">()):</span>
        <span class="n">coord</span> <span class="o">=</span> <span class="n">binning</span><span class="o">.</span><span class="n">index2coord</span><span class="p">(</span><span class="n">flatindex</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">this_bin</span> <span class="o">==</span> <span class="n">binning</span><span class="p">[</span><span class="n">coord</span><span class="p">]</span>

    <span class="k">assert</span> <span class="n">binning</span><span class="o">.</span><span class="n">num_bins</span> <span class="o">==</span> <span class="p">[</span><span class="mi">40</span><span class="p">,</span> <span class="mi">20</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">binning</span><span class="o">.</span><span class="n">tot_num_bins</span> <span class="o">==</span> <span class="mi">40</span> <span class="o">*</span> <span class="mi">20</span>

    <span class="k">assert</span> <span class="n">binning</span><span class="o">.</span><span class="n">oversample</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">400</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">binning</span><span class="o">.</span><span class="n">oversample</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">400</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">binning</span><span class="o">.</span><span class="n">oversample</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="mi">60</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">binning</span><span class="o">.</span><span class="n">downsample</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    
    <span class="k">assert</span> <span class="n">binning</span><span class="o">.</span><span class="n">oversample</span><span class="p">(</span><span class="n">coszen</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">energy</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">80</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">binning</span><span class="o">.</span><span class="n">oversample</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">binning</span>

    <span class="k">assert</span> <span class="n">binning</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;MeV&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)[</span><span class="s1">&#39;energy&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">units</span> <span class="o">==</span> <span class="n">ureg</span><span class="o">.</span><span class="n">MeV</span>
    <span class="k">assert</span> <span class="n">binning</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;MeV&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">binning</span><span class="p">,</span> <span class="s1">&#39;converted=</span><span class="si">%s</span><span class="se">\n</span><span class="s1">orig=</span><span class="si">%s</span><span class="s1">&#39;</span> \
            <span class="o">%</span><span class="p">(</span><span class="n">binning</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;MeV&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">),</span> <span class="n">binning</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">binning</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;MeV&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">hash</span> <span class="o">==</span> <span class="n">binning</span><span class="o">.</span><span class="n">hash</span>

    <span class="n">_</span> <span class="o">=</span> <span class="n">binning</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">entity</span><span class="o">=</span><span class="s1">&#39;bin_edges&#39;</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">binning</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">entity</span><span class="o">=</span><span class="s1">&#39;weighted_centers&#39;</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">binning</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">entity</span><span class="o">=</span><span class="s1">&#39;midpoints&#39;</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">binning</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">entity</span><span class="o">=</span><span class="s1">&#39;bin_widths&#39;</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">binning</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">entity</span><span class="o">=</span><span class="s1">&#39;weighted_bin_widths&#39;</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">binning</span><span class="o">.</span><span class="n">bin_volumes</span><span class="p">(</span><span class="n">attach_units</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">binning</span><span class="o">.</span><span class="n">bin_volumes</span><span class="p">(</span><span class="n">attach_units</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">binning</span><span class="o">.</span><span class="n">weighted_bin_volumes</span><span class="p">(</span><span class="n">attach_units</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">binning</span><span class="o">.</span><span class="n">weighted_bin_volumes</span><span class="p">(</span><span class="n">attach_units</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">binning</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;MeV&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">binning</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="s1">&#39;MeV&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">binning</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">ureg</span><span class="o">.</span><span class="n">joule</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    
    <span class="n">oversampled</span> <span class="o">=</span> <span class="n">binning</span><span class="o">.</span><span class="n">oversample</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">oversampled</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">400</span><span class="p">,</span> <span class="mi">60</span><span class="p">)</span>
    <span class="n">downsampled</span> <span class="o">=</span> <span class="n">binning</span><span class="o">.</span><span class="n">downsample</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">downsampled</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    
    <span class="n">over_vols</span> <span class="o">=</span> <span class="n">oversampled</span><span class="o">.</span><span class="n">bin_volumes</span><span class="p">(</span><span class="n">attach_units</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">down_vols</span> <span class="o">=</span> <span class="n">downsampled</span><span class="o">.</span><span class="n">bin_volumes</span><span class="p">(</span><span class="n">attach_units</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">norm_vols</span> <span class="o">=</span> <span class="n">binning</span><span class="o">.</span><span class="n">bin_volumes</span><span class="p">(</span><span class="n">attach_units</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">over_vols</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">norm_vols</span><span class="p">),</span> <span class="o">**</span><span class="n">ALLCLOSE_KW</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">down_vols</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">norm_vols</span><span class="p">),</span> <span class="o">**</span><span class="n">ALLCLOSE_KW</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">down_vols</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">over_vols</span><span class="p">),</span> <span class="o">**</span><span class="n">ALLCLOSE_KW</span><span class="p">)</span>
    
    <span class="n">over_vols</span> <span class="o">=</span> <span class="n">oversampled</span><span class="o">.</span><span class="n">weighted_bin_volumes</span><span class="p">(</span><span class="n">attach_units</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">down_vols</span> <span class="o">=</span> <span class="n">downsampled</span><span class="o">.</span><span class="n">weighted_bin_volumes</span><span class="p">(</span><span class="n">attach_units</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">norm_vols</span> <span class="o">=</span> <span class="n">binning</span><span class="o">.</span><span class="n">weighted_bin_volumes</span><span class="p">(</span><span class="n">attach_units</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">over_vols</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">norm_vols</span><span class="p">),</span> <span class="o">**</span><span class="n">ALLCLOSE_KW</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">down_vols</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">norm_vols</span><span class="p">),</span> <span class="o">**</span><span class="n">ALLCLOSE_KW</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">down_vols</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">over_vols</span><span class="p">),</span> <span class="o">**</span><span class="n">ALLCLOSE_KW</span><span class="p">)</span>
    
    <span class="n">testdir</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkdtemp</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">b_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">testdir</span><span class="p">,</span> <span class="s1">&#39;multi_dim_binning.json&#39;</span><span class="p">)</span>
        <span class="n">binning</span><span class="o">.</span><span class="n">to_json</span><span class="p">(</span><span class="n">b_file</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">b_</span> <span class="o">=</span> <span class="n">MultiDimBinning</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">b_file</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">b_</span> <span class="o">==</span> <span class="n">binning</span><span class="p">,</span> <span class="s1">&#39;binning=</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="s1">b_=</span><span class="se">\n</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">binning</span><span class="p">,</span> <span class="n">b_</span><span class="p">)</span>
        <span class="n">jsons</span><span class="o">.</span><span class="n">to_json</span><span class="p">(</span><span class="n">binning</span><span class="p">,</span> <span class="n">b_file</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">b_</span> <span class="o">=</span> <span class="n">MultiDimBinning</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">b_file</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">b_</span> <span class="o">==</span> <span class="n">binning</span><span class="p">,</span> <span class="s1">&#39;binning=</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="s1">b_=</span><span class="se">\n</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">binning</span><span class="p">,</span> <span class="n">b_</span><span class="p">)</span>

        <span class="c1"># Had bug where datastruct containing MultiDimBinning failed to be</span>
        <span class="c1"># saved. Test tuple containing list containing OrderedDict</span>
        <span class="c1"># containing MultiDimBinning here, just to make sure MultiDimBinning</span>
        <span class="c1"># can be written inside a nested structure.</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">binning</span>
        <span class="n">struct</span> <span class="o">=</span> <span class="p">([</span><span class="n">OrderedDict</span><span class="p">(</span><span class="n">mdb</span><span class="o">=</span><span class="n">b</span><span class="p">)],)</span>
        <span class="n">jsons</span><span class="o">.</span><span class="n">to_json</span><span class="p">(</span><span class="n">struct</span><span class="p">,</span> <span class="n">b_file</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">loaded</span> <span class="o">=</span> <span class="n">jsons</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">b_file</span><span class="p">)</span>
        <span class="n">b_</span> <span class="o">=</span> <span class="n">MultiDimBinning</span><span class="p">(</span><span class="o">**</span><span class="n">loaded</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;mdb&#39;</span><span class="p">])</span>
        <span class="k">assert</span> <span class="n">b_</span> <span class="o">==</span> <span class="n">b</span>

        <span class="c1"># Now try with pickle</span>
        <span class="n">b_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">testdir</span><span class="p">,</span> <span class="s1">&#39;multi_dim_binning.pkl&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">b_file</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fobj</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">struct</span><span class="p">,</span> <span class="n">fobj</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">b_file</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fobj</span><span class="p">:</span>
            <span class="n">loaded</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fobj</span><span class="p">)</span>
        <span class="n">b_</span> <span class="o">=</span> <span class="n">loaded</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;mdb&#39;</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">b_</span> <span class="o">==</span> <span class="n">b</span>

    <span class="k">finally</span><span class="p">:</span>
        <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">testdir</span><span class="p">,</span> <span class="n">ignore_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Test that reordering dimensions works correctly</span>
    <span class="n">e_binning</span> <span class="o">=</span> <span class="n">OneDimBinning</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;true_energy&#39;</span><span class="p">,</span> <span class="n">num_bins</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">is_log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">80</span><span class="p">]</span><span class="o">*</span><span class="n">ureg</span><span class="o">.</span><span class="n">GeV</span>
    <span class="p">)</span>
    <span class="n">reco_e_binning</span> <span class="o">=</span> <span class="n">OneDimBinning</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;reco_energy&#39;</span><span class="p">,</span> <span class="n">num_bins</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">is_log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">80</span><span class="p">]</span><span class="o">*</span><span class="n">ureg</span><span class="o">.</span><span class="n">GeV</span>
    <span class="p">)</span>
    <span class="n">cz_binning</span> <span class="o">=</span> <span class="n">OneDimBinning</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;true_coszen&#39;</span><span class="p">,</span> <span class="n">num_bins</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">is_lin</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">reco_cz_binning</span> <span class="o">=</span> <span class="n">OneDimBinning</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;reco_coszen&#39;</span><span class="p">,</span> <span class="n">num_bins</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">is_lin</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">az_binning</span> <span class="o">=</span> <span class="n">OneDimBinning</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;true_azimuth&#39;</span><span class="p">,</span> <span class="n">num_bins</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">is_lin</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">domain</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="o">*</span><span class="n">ureg</span><span class="o">.</span><span class="n">rad</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">ureg</span><span class="o">.</span><span class="n">rad</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">reco_az_binning</span> <span class="o">=</span> <span class="n">OneDimBinning</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;true_azimuth&#39;</span><span class="p">,</span> <span class="n">num_bins</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">is_lin</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">domain</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="o">*</span><span class="n">ureg</span><span class="o">.</span><span class="n">rad</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">ureg</span><span class="o">.</span><span class="n">rad</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="n">mdb_2d_orig</span> <span class="o">=</span> <span class="n">MultiDimBinning</span><span class="p">([</span><span class="n">e_binning</span><span class="p">,</span> <span class="n">cz_binning</span><span class="p">])</span>
    <span class="n">orig_order</span> <span class="o">=</span> <span class="n">mdb_2d_orig</span><span class="o">.</span><span class="n">names</span>

    <span class="c1"># Reverse ordering; reorder by dimension names</span>
    <span class="n">new_order</span> <span class="o">=</span> <span class="n">orig_order</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">mdb_2d_new</span> <span class="o">=</span> <span class="n">MultiDimBinning</span><span class="p">(</span><span class="n">mdb_2d_orig</span><span class="p">)</span>
    <span class="n">mdb_2d_new</span> <span class="o">=</span> <span class="n">mdb_2d_new</span><span class="o">.</span><span class="n">reorder_dimensions</span><span class="p">(</span><span class="n">new_order</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">mdb_2d_new</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="n">new_order</span>
    <span class="n">new_order</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;true_azimuth&#39;</span><span class="p">,</span> <span class="s1">&#39;true_energy&#39;</span><span class="p">,</span> <span class="s1">&#39;true_coszen&#39;</span><span class="p">]</span>
    <span class="n">mdb_2d_new</span> <span class="o">=</span> <span class="n">mdb_2d_new</span><span class="o">.</span><span class="n">reorder_dimensions</span><span class="p">(</span><span class="n">new_order</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">mdb_2d_new</span> <span class="o">==</span> <span class="n">mdb_2d_orig</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">MultiDimBinning</span><span class="p">([</span><span class="n">e_binning</span><span class="p">,</span> <span class="n">cz_binning</span><span class="p">])</span>

    <span class="n">mdb_3d_orig</span> <span class="o">=</span> <span class="n">MultiDimBinning</span><span class="p">([</span><span class="n">e_binning</span><span class="p">,</span> <span class="n">cz_binning</span><span class="p">,</span> <span class="n">az_binning</span><span class="p">])</span>
    <span class="n">orig_order</span> <span class="o">=</span> <span class="n">mdb_3d_orig</span><span class="o">.</span><span class="n">names</span>
    <span class="n">new_order</span> <span class="o">=</span> <span class="p">[</span><span class="n">orig_order</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">orig_order</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">orig_order</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

    <span class="n">mdb_3d_new</span> <span class="o">=</span> <span class="n">MultiDimBinning</span><span class="p">(</span><span class="n">mdb_3d_orig</span><span class="p">)</span>
    <span class="n">mdb_3d_new</span> <span class="o">=</span> <span class="n">mdb_3d_new</span><span class="o">.</span><span class="n">reorder_dimensions</span><span class="p">(</span><span class="n">new_order</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">mdb_3d_new</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="n">new_order</span>
    <span class="c1"># Reorder by MultiDimBinning object</span>
    <span class="n">mdb_3d_new</span> <span class="o">=</span> <span class="n">mdb_3d_new</span><span class="o">.</span><span class="n">reorder_dimensions</span><span class="p">(</span><span class="n">mdb_3d_orig</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">mdb_3d_new</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="n">orig_order</span>

    <span class="c1"># Reorder by indices</span>
    <span class="n">mdb_3d_new</span> <span class="o">=</span> <span class="n">MultiDimBinning</span><span class="p">(</span><span class="n">mdb_3d_orig</span><span class="p">)</span>
    <span class="n">mdb_3d_new</span> <span class="o">=</span> <span class="n">mdb_3d_new</span><span class="o">.</span><span class="n">reorder_dimensions</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="k">assert</span> <span class="n">mdb_3d_new</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="n">new_order</span>

    <span class="c1"># Reorder by combination of index, OneDimBinning, and name</span>
    <span class="n">mdb_3d_new</span> <span class="o">=</span> <span class="n">MultiDimBinning</span><span class="p">(</span><span class="n">mdb_3d_orig</span><span class="p">)</span>
    <span class="n">mdb_3d_new</span> <span class="o">=</span> <span class="n">mdb_3d_new</span><span class="o">.</span><span class="n">reorder_dimensions</span><span class="p">(</span>
        <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;true_energy&#39;</span><span class="p">,</span> <span class="n">mdb_2d_orig</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="p">)</span>
    <span class="k">assert</span> <span class="n">mdb_3d_new</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="n">new_order</span>

    <span class="c1"># Reorder by superset</span>
    <span class="n">mdb_2d_new</span> <span class="o">=</span> <span class="n">MultiDimBinning</span><span class="p">(</span><span class="n">mdb_3d_orig</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">mdb_2d_new</span> <span class="o">=</span> <span class="n">mdb_2d_new</span> <span class="o">=</span> <span class="n">mdb_2d_new</span><span class="o">.</span><span class="n">reorder_dimensions</span><span class="p">(</span><span class="n">new_order</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">mdb_2d_new</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="p">[</span><span class="n">o</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">new_order</span> <span class="k">if</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">mdb_2d_new</span><span class="p">]</span>

    <span class="c1"># Reorder by subset</span>
    <span class="n">mdb_3d_new</span> <span class="o">=</span> <span class="n">MultiDimBinning</span><span class="p">(</span><span class="n">mdb_3d_orig</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">mdb_3d_new</span> <span class="o">=</span> <span class="n">mdb_3d_new</span><span class="o">.</span><span class="n">reorder_dimensions</span><span class="p">(</span><span class="n">new_order</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Should not be able to reorder by subset.&#39;</span><span class="p">)</span>

    <span class="c1"># Create a basename-equivalent binning</span>
    <span class="n">mdb_3d_reco</span> <span class="o">=</span> <span class="n">MultiDimBinning</span><span class="p">([</span><span class="n">reco_e_binning</span><span class="p">,</span> <span class="n">reco_cz_binning</span><span class="p">,</span>
                                   <span class="n">reco_az_binning</span><span class="p">])</span>
    <span class="k">assert</span> <span class="n">mdb_3d_reco</span><span class="o">.</span><span class="n">basename_binning</span> <span class="o">==</span> <span class="n">mdb_3d_orig</span><span class="o">.</span><span class="n">basename_binning</span>

    <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">_</span> <span class="o">=</span> <span class="p">[</span><span class="n">tup</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">mdb_3d_reco</span><span class="o">.</span><span class="n">iteredgetuples</span><span class="p">()]</span>
    <span class="n">tprofile</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Time to iterate over </span><span class="si">%d</span><span class="s1"> edge tuples: </span><span class="si">%.6f</span><span class="s1"> sec&#39;</span><span class="p">,</span>
                  <span class="n">mdb_3d_reco</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0</span><span class="p">)</span>

    <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">_</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">mdb_3d_reco</span><span class="o">.</span><span class="n">iterbins</span><span class="p">()]</span>
    <span class="n">tprofile</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Time to iterate over </span><span class="si">%d</span><span class="s1"> bins: </span><span class="si">%.6f</span><span class="s1"> sec&#39;</span><span class="p">,</span>
                  <span class="n">mdb_3d_reco</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0</span><span class="p">)</span>
    
    <span class="c1"># Test compatibility test</span>
    <span class="n">mdb1</span> <span class="o">=</span> <span class="n">MultiDimBinning</span><span class="p">([</span>
        <span class="n">OneDimBinning</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;energy&#39;</span><span class="p">,</span> <span class="n">num_bins</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">is_log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">80</span><span class="p">]</span><span class="o">*</span><span class="n">ureg</span><span class="o">.</span><span class="n">GeV</span><span class="p">),</span>
        <span class="n">OneDimBinning</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;coszen&#39;</span><span class="p">,</span> <span class="n">num_bins</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">is_lin</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="p">])</span>
    <span class="n">mdb2</span> <span class="o">=</span> <span class="n">MultiDimBinning</span><span class="p">([</span>
        <span class="n">OneDimBinning</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;energy&#39;</span><span class="p">,</span> <span class="n">num_bins</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">is_log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">80</span><span class="p">]</span><span class="o">*</span><span class="n">ureg</span><span class="o">.</span><span class="n">GeV</span><span class="p">),</span>
        <span class="n">OneDimBinning</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;coszen&#39;</span><span class="p">,</span> <span class="n">num_bins</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">is_lin</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="p">])</span>
    <span class="c1"># These should be compatible</span>
    <span class="k">assert</span> <span class="n">mdb1</span><span class="o">.</span><span class="n">is_compat</span><span class="p">(</span><span class="n">mdb2</span><span class="p">)</span>
    <span class="n">mdb1</span><span class="o">.</span><span class="n">assert_compat</span><span class="p">(</span><span class="n">mdb2</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">mdb2</span><span class="o">.</span><span class="n">is_compat</span><span class="p">(</span><span class="n">mdb1</span><span class="p">)</span>
    <span class="n">mdb2</span><span class="o">.</span><span class="n">assert_compat</span><span class="p">(</span><span class="n">mdb1</span><span class="p">)</span>
    
    <span class="n">mdb2</span> <span class="o">=</span> <span class="n">MultiDimBinning</span><span class="p">([</span>
        <span class="n">OneDimBinning</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;energy&#39;</span><span class="p">,</span> <span class="n">num_bins</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">is_log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">80</span><span class="p">]</span><span class="o">*</span><span class="n">ureg</span><span class="o">.</span><span class="n">GeV</span><span class="p">),</span>
        <span class="n">OneDimBinning</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;coszen&#39;</span><span class="p">,</span> <span class="n">num_bins</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">is_lin</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="p">])</span>
    
    <span class="c1"># In this direction, they should *not* be compatible</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">mdb1</span><span class="o">.</span><span class="n">is_compat</span><span class="p">(</span><span class="n">mdb2</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">pytest</span><span class="o">.</span><span class="n">raises</span><span class="p">(</span><span class="ne">AssertionError</span><span class="p">)</span> <span class="k">as</span> <span class="n">ae</span><span class="p">:</span>
        <span class="n">mdb1</span><span class="o">.</span><span class="n">assert_compat</span><span class="p">(</span><span class="n">mdb2</span><span class="p">)</span>
    <span class="c1"># In this direction, they *should* be compatible (downsampling)</span>
    <span class="k">assert</span> <span class="n">mdb2</span><span class="o">.</span><span class="n">is_compat</span><span class="p">(</span><span class="n">mdb1</span><span class="p">)</span>
    <span class="n">mdb2</span><span class="o">.</span><span class="n">assert_compat</span><span class="p">(</span><span class="n">mdb1</span><span class="p">)</span>
    
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;&lt;&lt; PASS : test_MultiDimBinning &gt;&gt;&#39;</span><span class="p">)</span></div>



<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">set_verbosity</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">test_OneDimBinning</span><span class="p">()</span>
    <span class="n">test_MultiDimBinning</span><span class="p">()</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, The IceCube/PINGU Collaboration.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>