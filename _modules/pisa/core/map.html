<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pisa.core.map &mdash; PISA 4.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=9f5556dd"></script>
        <script src="../../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            PISA
          </a>
              <div class="version">
                4.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">API reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">PISA</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">pisa.core.map</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pisa.core.map</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Map class to contain 2D histogram, error, and metadata about the contents.</span>
<span class="sd">MapSet class to contain a set of maps.</span>

<span class="sd">Also provide basic mathematical operations that user applies directly to the</span>
<span class="sd">containers but that get passed down to operate on the contained data.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Sequence</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span><span class="p">,</span> <span class="n">copy</span>
<span class="kn">from</span> <span class="nn">fnmatch</span> <span class="kn">import</span> <span class="n">fnmatch</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">reduce</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">permutations</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">add</span><span class="p">,</span> <span class="n">getitem</span><span class="p">,</span> <span class="n">setitem</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">tempfile</span>

<span class="kn">from</span> <span class="nn">decorator</span> <span class="kn">import</span> <span class="n">decorate</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">poisson</span><span class="p">,</span> <span class="n">norm</span>
<span class="kn">from</span> <span class="nn">six</span> <span class="kn">import</span> <span class="n">string_types</span>
<span class="kn">import</span> <span class="nn">uncertainties</span>
<span class="kn">from</span> <span class="nn">uncertainties</span> <span class="kn">import</span> <span class="n">ufloat</span>
<span class="kn">from</span> <span class="nn">uncertainties</span> <span class="kn">import</span> <span class="n">unumpy</span> <span class="k">as</span> <span class="n">unp</span>

<span class="kn">from</span> <span class="nn">pisa</span> <span class="kn">import</span> <span class="n">ureg</span><span class="p">,</span> <span class="n">HASH_SIGFIGS</span>
<span class="kn">from</span> <span class="nn">pisa.core.binning</span> <span class="kn">import</span> <span class="n">OneDimBinning</span><span class="p">,</span> <span class="n">MultiDimBinning</span>
<span class="kn">from</span> <span class="nn">pisa.utils.comparisons</span> <span class="kn">import</span> <span class="n">normQuant</span><span class="p">,</span> <span class="n">recursiveEquality</span><span class="p">,</span> <span class="n">ALLCLOSE_KW</span>
<span class="kn">from</span> <span class="nn">pisa.utils.flavInt</span> <span class="kn">import</span> <span class="n">NuFlavIntGroup</span>
<span class="kn">from</span> <span class="nn">pisa.utils.hash</span> <span class="kn">import</span> <span class="n">hash_obj</span>
<span class="kn">from</span> <span class="nn">pisa.utils</span> <span class="kn">import</span> <span class="n">jsons</span>
<span class="kn">from</span> <span class="nn">pisa.utils.fileio</span> <span class="kn">import</span> <span class="n">get_valid_filename</span><span class="p">,</span> <span class="n">mkdir</span>
<span class="kn">from</span> <span class="nn">pisa.utils.format</span> <span class="kn">import</span> <span class="p">(</span><span class="n">make_valid_python_name</span><span class="p">,</span> <span class="n">strip_outer_dollars</span><span class="p">,</span>
                               <span class="n">text2tex</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">pisa.utils.log</span> <span class="kn">import</span> <span class="n">logging</span><span class="p">,</span> <span class="n">set_verbosity</span>
<span class="kn">from</span> <span class="nn">pisa.utils.random_numbers</span> <span class="kn">import</span> <span class="n">get_random_state</span>
<span class="kn">from</span> <span class="nn">pisa.utils</span> <span class="kn">import</span> <span class="n">stats</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;FLUCTUATE_METHODS&#39;</span><span class="p">,</span> <span class="s1">&#39;type_error&#39;</span><span class="p">,</span> <span class="s1">&#39;reduceToHist&#39;</span><span class="p">,</span> <span class="s1">&#39;rebin&#39;</span><span class="p">,</span>
           <span class="s1">&#39;valid_nominal_values&#39;</span><span class="p">,</span> <span class="s1">&#39;Map&#39;</span><span class="p">,</span> <span class="s1">&#39;MapSet&#39;</span><span class="p">,</span> <span class="s1">&#39;test_Map&#39;</span><span class="p">,</span> <span class="s1">&#39;test_MapSet&#39;</span><span class="p">]</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s1">&#39;J.L. Lanfranchi&#39;</span>

<span class="n">__license__</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;Copyright (c) 2014-2020, The IceCube Collaboration</span>

<span class="s1"> Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s1"> you may not use this file except in compliance with the License.</span>
<span class="s1"> You may obtain a copy of the License at</span>

<span class="s1">   http://www.apache.org/licenses/LICENSE-2.0</span>

<span class="s1"> Unless required by applicable law or agreed to in writing, software</span>
<span class="s1"> distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s1"> WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s1"> See the License for the specific language governing permissions and</span>
<span class="s1"> limitations under the License.&#39;&#39;&#39;</span>


<span class="c1"># TODO: inconsistent treatment of metrics in *chi2*, *llh*, and metric* methods</span>
<span class="c1"># (Issue #264: https://github.com/jllanfranchi/pisa/issues/264)</span>

<span class="c1"># TODO: make sure logic works for PID-separated-maps as well as</span>
<span class="c1"># PID-as-binning-dimension maps</span>

<span class="c1"># TODO: CUDA and numba implementations of rebin if these libs are available</span>

<span class="c1"># TODO: move these utilities functions to a generic utils module?</span>

<span class="n">FLUCTUATE_METHODS</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;poisson&#39;</span><span class="p">,</span> <span class="s1">&#39;scaled_poisson&#39;</span><span class="p">,</span> <span class="s1">&#39;gauss&#39;</span><span class="p">,</span> <span class="s1">&#39;gauss+poisson&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="type_error">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.type_error">[docs]</a>
<span class="k">def</span> <span class="nf">type_error</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generic formulation of a TypeError that can be called throughout the</span>
<span class="sd">    code&quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Type of argument not supported: &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span>
                    <span class="o">%</span> <span class="n">value</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span></div>



<div class="viewcode-block" id="reduceToHist">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.reduceToHist">[docs]</a>
<span class="k">def</span> <span class="nf">reduceToHist</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Recursively sum to reduce an object to a single histogram.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    obj : numpy.ndarray, Map, MapSet, or iterable of MapSets</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    hist : numpy.ndarray</span>
<span class="sd">        Single histogram version of `obj`</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError if `obj` is an unhandled type</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">hist</span> <span class="o">=</span> <span class="n">obj</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Map</span><span class="p">):</span>
        <span class="n">hist</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">hist</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">MapSet</span><span class="p">):</span>
        <span class="n">hist</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="n">hist</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
        <span class="n">hist</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">reduceToHist</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unhandled type for `obj`: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">hist</span></div>



<div class="viewcode-block" id="rebin">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.rebin">[docs]</a>
<span class="k">def</span> <span class="nf">rebin</span><span class="p">(</span><span class="n">hist</span><span class="p">,</span> <span class="n">orig_binning</span><span class="p">,</span> <span class="n">new_binning</span><span class="p">,</span> <span class="n">normalize_values</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Rebin a histogram.</span>

<span class="sd">    Note that the new binning&#39;s edges must be a subset of the original</span>
<span class="sd">    binning&#39;s edges (i.e. no sub-division or extrapolation of bins is</span>
<span class="sd">    implemented).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    hist : numpy.ndarray</span>
<span class="sd">        Array containing the (original) histogram&#39;s entries</span>

<span class="sd">    orig_binning : MultiDimBinning</span>
<span class="sd">        Original binning</span>

<span class="sd">    new_binning : MultiDimBinning</span>
<span class="sd">        Desired binning, where `new_binning.bin_edges` must be a subset of</span>
<span class="sd">        `orig_binning.bin_edges`.</span>

<span class="sd">    normalize_values : bool</span>
<span class="sd">        Whether to apply `pisa.utils.comparisons.normQuant` to the bin edges</span>
<span class="sd">        prior to comparing `new_binning` to `orig_binning`. This is</span>
<span class="sd">        computationally expensive but ensures similar binnings and eqivalent</span>
<span class="sd">        units do not cause erroneous results. It is recommended to set</span>
<span class="sd">        `normalize_values=True` unless you know the two binning specs are</span>
<span class="sd">        consistently defined.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    new_hist : numpy.ndarray</span>
<span class="sd">        New histogram rebinned from `hist`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">new_binning</span><span class="o">.</span><span class="n">basenames</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">orig_binning</span><span class="o">.</span><span class="n">basenames</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;`new_binning` dimensions&#39; basenames </span><span class="si">%s</span><span class="s2"> do not have 1:1&quot;</span>
            <span class="s2">&quot; correspondence (modulo pre/suffixes) to original binning&quot;</span>
            <span class="s2">&quot; dimensions&#39; basenames </span><span class="si">%s</span><span class="s2">&quot;</span>
            <span class="o">%</span> <span class="p">(</span><span class="n">new_binning</span><span class="o">.</span><span class="n">basenames</span><span class="p">,</span> <span class="n">orig_binning</span><span class="o">.</span><span class="n">basenames</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">orig_binning</span><span class="o">.</span><span class="n">edges_hash</span> <span class="o">==</span> <span class="n">new_binning</span><span class="o">.</span><span class="n">edges_hash</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hist</span>

    <span class="n">orig_dim_indices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">new_dim_indices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">new_dim_idx</span><span class="p">,</span> <span class="n">new_dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_binning</span><span class="p">):</span>
        <span class="n">orig_dim_idx</span> <span class="o">=</span> <span class="n">orig_binning</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">new_dim</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">use_basenames</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">new_dim_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_dim_idx</span><span class="p">)</span>
        <span class="n">orig_dim_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">orig_dim_idx</span><span class="p">)</span>

        <span class="n">orig_dim</span> <span class="o">=</span> <span class="n">orig_binning</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="n">orig_dim_idx</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">normalize_values</span><span class="p">:</span>
            <span class="n">orig_edges</span> <span class="o">=</span> <span class="n">normQuant</span><span class="p">(</span><span class="n">orig_dim</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">sigfigs</span><span class="o">=</span><span class="n">HASH_SIGFIGS</span><span class="p">)</span>
            <span class="n">new_edges</span> <span class="o">=</span> <span class="n">normQuant</span><span class="p">(</span><span class="n">new_dim</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">sigfigs</span><span class="o">=</span><span class="n">HASH_SIGFIGS</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">orig_edges</span> <span class="o">=</span> <span class="n">orig_dim</span><span class="o">.</span><span class="n">bin_edges</span>
            <span class="n">new_edges</span> <span class="o">=</span> <span class="n">new_dim</span><span class="o">.</span><span class="n">bin_edges</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">new_edges</span> <span class="o">==</span> <span class="n">orig_edges</span><span class="p">):</span>
            <span class="n">orig_edge_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">orig_edges</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span>
                                      <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">new_edges</span><span class="p">])</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduceat</span><span class="p">(</span><span class="n">hist</span><span class="p">,</span> <span class="n">orig_edge_idx</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                   <span class="n">axis</span><span class="o">=</span><span class="n">orig_dim_idx</span><span class="p">)</span>

    <span class="n">new_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">hist</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">orig_dim_indices</span><span class="p">,</span>
                           <span class="n">destination</span><span class="o">=</span><span class="n">new_dim_indices</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">new_hist</span></div>



<span class="k">def</span> <span class="nf">_new_obj</span><span class="p">(</span><span class="n">original_function</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Decorator to deepcopy unaltered states into new Map object.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">new_function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Augmented function to replace `original_function`. Note that this</span>
<span class="sd">        docstring and the function signature will be overwritten by those from</span>
<span class="sd">        `original_function` upon the call to `decorate` below.&quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=protected-access</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
        <span class="n">new_state</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">state_updates</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">slot</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state_attrs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">state_updates</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">slot</span> <span class="ow">in</span> <span class="n">state_updates</span><span class="p">:</span>
                <span class="n">new_state</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="n">state_updates</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_state</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slot</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_state</span><span class="p">[</span><span class="s1">&#39;binning&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">new_state</span><span class="p">[</span><span class="s1">&#39;hist&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">Map</span><span class="p">(</span><span class="o">**</span><span class="n">new_state</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">decorate</span><span class="p">(</span><span class="n">original_function</span><span class="p">,</span> <span class="n">new_function</span><span class="p">)</span>


<div class="viewcode-block" id="valid_nominal_values">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.valid_nominal_values">[docs]</a>
<span class="k">def</span> <span class="nf">valid_nominal_values</span><span class="p">(</span><span class="n">data_array</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the the nominal values that are valid for an array&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="n">unp</span><span class="o">.</span><span class="n">nominal_values</span><span class="p">(</span><span class="n">data_array</span><span class="p">))</span></div>



<span class="c1"># TODO: implement strategies for decreasing dimensionality (i.e.</span>
<span class="c1"># projecting map onto subset of dimensions in the original map)</span>

<span class="c1"># TODO: Should all calls to np.&lt;...&gt; be replaced with unp.&lt;...&gt; as is done for</span>
<span class="c1"># unp.sqrt below?</span>

<div class="viewcode-block" id="Map">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.Map">[docs]</a>
<span class="k">class</span> <span class="nc">Map</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class to contain a multi-dimensional histogram, error, and metadata</span>
<span class="sd">    about the histogram. Also provides basic mathematical operations for the</span>
<span class="sd">    contained data. See Examples below for how to use a Map object.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : string</span>
<span class="sd">        Name for the map. Used to identify the map.</span>

<span class="sd">    hist : numpy.ndarray (incl. obj array from uncertainties.unumpy.uarray)</span>
<span class="sd">        The &quot;data&quot; (counts, etc.) in the map.  The shape of `hist` must be</span>
<span class="sd">        compatible with the `binning` specified.</span>

<span class="sd">    binning : MultiDimBinning</span>
<span class="sd">        Describes the binning of the Map.</span>

<span class="sd">    error_hist : numpy ndarray</span>
<span class="sd">        Must be same shape as `hist`. If specified, sets the error standard</span>
<span class="sd">        deviations for the contained `hist`, replacing any stddev information</span>
<span class="sd">        that might be contained in the passed `hist` arg.</span>

<span class="sd">    hash : None, or immutable object (typically an integer)</span>
<span class="sd">        Hash value to attach to the map.</span>

<span class="sd">    tex : None or string</span>
<span class="sd">        TeX string that can be used for e.g. plotting.</span>

<span class="sd">    full_comparison : bool</span>
<span class="sd">        Whether to perform full (recursive) comparisons when testing the</span>
<span class="sd">        equality of this map with another. See `__eq__` method.</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from pisa.core.binning import MultiDimBinning</span>
<span class="sd">    &gt;&gt;&gt; binning = MultiDimBinning([dict(name=&#39;energy&#39;, is_log=True, num_bins=4,</span>
<span class="sd">    ...                                 domain=[1, 80], units=&#39;GeV&#39;),</span>
<span class="sd">    ...                            dict(name=&#39;coszen&#39;, is_lin=True, num_bins=5,</span>
<span class="sd">    ...                                 domain=[-1, 0])])</span>
<span class="sd">    &gt;&gt;&gt; m0 = Map(name=&#39;x&#39;, binning=binning, hist=np.zeros(binning.shape))</span>
<span class="sd">    &gt;&gt;&gt; m0</span>
<span class="sd">    array([[ 0.,  0.,  0.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  0.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  0.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  0.,  0.,  0.]])</span>
<span class="sd">    &gt;&gt;&gt; m0.binning</span>
<span class="sd">    energy: 4 logarithmically-uniform bins spanning [1.0, 80.0] GeV</span>
<span class="sd">    coszen: 5 equally-sized bins spanning [-1.0, 0.0]</span>
<span class="sd">    &gt;&gt;&gt; m0.hist[0:4, 0] = 1</span>
<span class="sd">    &gt;&gt;&gt; m0</span>
<span class="sd">    array([[ 1.,  0.,  0.,  0.,  0.],</span>
<span class="sd">           [ 1.,  0.,  0.,  0.,  0.],</span>
<span class="sd">           [ 1.,  0.,  0.,  0.,  0.],</span>
<span class="sd">           [ 1.,  0.,  0.,  0.,  0.]])</span>
<span class="sd">    &gt;&gt;&gt; m1 = m0[0:3, 0:2]</span>
<span class="sd">    &gt;&gt;&gt; m1.binning</span>
<span class="sd">    energy: 3 logarithmically-uniform bins spanning [1.0, 26.7496121991]</span>
<span class="sd">    coszen: 2 equally-sized bins spanning [-1.0, -0.6]</span>
<span class="sd">    &gt;&gt;&gt; m1</span>
<span class="sd">    array([[ 1.,  0.],</span>
<span class="sd">           [ 1.,  0.],</span>
<span class="sd">           [ 1.,  0.]])</span>
<span class="sd">    &gt;&gt;&gt; for bin in m1.iterbins():</span>
<span class="sd">    ...     print(&#39;({0:~.2f}, {1:~.2f}): {2:0.1f}&#39;.format(</span>
<span class="sd">    ...             bin.binning.energy.midpoints[0],</span>
<span class="sd">    ...             bin.binning.coszen.midpoints[0],</span>
<span class="sd">    ...             bin.hist[0, 0]))</span>
<span class="sd">    (2.00 GeV, -0.90 ): 1.0</span>
<span class="sd">    (2.00 GeV, -0.70 ): 0.0</span>
<span class="sd">    (5.97 GeV, -0.90 ): 1.0</span>
<span class="sd">    (5.97 GeV, -0.70 ): 0.0</span>
<span class="sd">    (17.85 GeV, -0.90 ): 1.0</span>
<span class="sd">    (17.85 GeV, -0.70 ): 0.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_slots</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;hist&#39;</span><span class="p">,</span> <span class="s1">&#39;binning&#39;</span><span class="p">,</span> <span class="s1">&#39;hash&#39;</span><span class="p">,</span> <span class="s1">&#39;_hash&#39;</span><span class="p">,</span> <span class="s1">&#39;tex&#39;</span><span class="p">,</span>
              <span class="s1">&#39;full_comparison&#39;</span><span class="p">,</span> <span class="s1">&#39;parent_indexer&#39;</span><span class="p">,</span> <span class="s1">&#39;_normalize_values&#39;</span><span class="p">)</span>
    <span class="n">_state_attrs</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;hist&#39;</span><span class="p">,</span> <span class="s1">&#39;binning&#39;</span><span class="p">,</span> <span class="s1">&#39;hash&#39;</span><span class="p">,</span> <span class="s1">&#39;tex&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;full_comparison&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">hist</span><span class="p">,</span> <span class="n">binning</span><span class="p">,</span> <span class="n">error_hist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">hash</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">tex</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">full_comparison</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># Set Read/write attributes via their defined setters</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="s1">&#39;_name&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="s1">&#39;_tex&#39;</span><span class="p">,</span> <span class="n">tex</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="s1">&#39;_hash&#39;</span><span class="p">,</span> <span class="nb">hash</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="s1">&#39;_full_comparison&#39;</span><span class="p">,</span> <span class="n">full_comparison</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">binning</span><span class="p">,</span> <span class="n">MultiDimBinning</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">binning</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
                <span class="n">binning</span> <span class="o">=</span> <span class="n">MultiDimBinning</span><span class="p">(</span><span class="n">dimensions</span><span class="o">=</span><span class="n">binning</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">binning</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
                <span class="n">binning</span> <span class="o">=</span> <span class="n">MultiDimBinning</span><span class="p">(</span><span class="o">**</span><span class="n">binning</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Do not know what to do with `binning`=</span><span class="si">%s</span><span class="s1"> of&#39;</span>
                                 <span class="s1">&#39; type </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">binning</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">binning</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent_indexer</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Do the work here to set read-only attributes</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="s1">&#39;_binning&#39;</span><span class="p">,</span> <span class="n">binning</span><span class="p">)</span>
        <span class="n">binning</span><span class="o">.</span><span class="n">assert_array_fits</span><span class="p">(</span><span class="n">hist</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span>
            <span class="s1">&#39;_hist&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">hist</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">error_hist</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_errors</span><span class="p">(</span><span class="n">error_hist</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_values</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">previous_precision</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">get_printoptions</span><span class="p">()[</span><span class="s1">&#39;precision&#39;</span><span class="p">]</span>
        <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">serializable_state</span>
            <span class="n">state</span><span class="p">[</span><span class="s1">&#39;hist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_repr</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s1">&#39;hist&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;error_hist&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">state</span><span class="p">[</span><span class="s1">&#39;error_hist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_repr</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s1">&#39;error_hist&#39;</span><span class="p">])</span>
            <span class="n">argstrs</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">=</span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">serializable_state</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
            <span class="n">r</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">    &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">argstrs</span><span class="p">))</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="n">previous_precision</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">r</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;tex&#39;</span><span class="p">,</span> <span class="s1">&#39;full_comparison&#39;</span><span class="p">,</span> <span class="s1">&#39;hash&#39;</span><span class="p">,</span> <span class="s1">&#39;parent_indexer&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;binning&#39;</span><span class="p">,</span> <span class="s1">&#39;hist&#39;</span><span class="p">]</span>
        <span class="n">state</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">}</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;tex&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s1">&#39;tex&#39;</span><span class="p">])</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;hist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_repr</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s1">&#39;hist&#39;</span><span class="p">])</span>
        <span class="n">argstrs</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">=</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">state</span><span class="p">[</span><span class="n">a</span><span class="p">]))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">]</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">    &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">argstrs</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">__pretty__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">cycle</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Method used by the `pretty` library for formatting&quot;&quot;&quot;</span>
        <span class="n">myname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">if</span> <span class="n">cycle</span><span class="p">:</span>
            <span class="n">p</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">(...)&#39;</span> <span class="o">%</span> <span class="n">myname</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p</span><span class="o">.</span><span class="n">begin_group</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">(&#39;</span> <span class="o">%</span> <span class="n">myname</span><span class="p">)</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;tex&#39;</span><span class="p">,</span> <span class="s1">&#39;full_comparison&#39;</span><span class="p">,</span> <span class="s1">&#39;hash&#39;</span><span class="p">,</span>
                     <span class="s1">&#39;parent_indexer&#39;</span><span class="p">,</span> <span class="s1">&#39;binning&#39;</span><span class="p">,</span> <span class="s1">&#39;hist&#39;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">attrs</span><span class="p">):</span>
                <span class="n">p</span><span class="o">.</span><span class="n">breakable</span><span class="p">()</span>
                <span class="n">p</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">attr</span> <span class="o">+</span> <span class="s1">&#39;=&#39;</span><span class="p">)</span>
                <span class="n">p</span><span class="o">.</span><span class="n">pretty</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">attrs</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
            <span class="n">p</span><span class="o">.</span><span class="n">end_group</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;)&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_repr_pretty_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">cycle</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Method used by e.g. ipython/Jupyter for formatting&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__pretty__</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cycle</span><span class="p">)</span>

<div class="viewcode-block" id="Map.item">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.Map.item">[docs]</a>
    <span class="k">def</span> <span class="nf">item</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Call ``item(*args)`` method on the contained `hist`, returning a</span>
<span class="sd">        single Python scalar corresponding to `*args`. See help for</span>
<span class="sd">        :method:`numpy.ndarray.item` for more info.</span>

<span class="sd">        Note that this method is called by :method:`numpy.asscalar`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *args</span>
<span class="sd">            Passed to :method:`numpy.ndarray.item`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        z : Standard Python scalar object</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span></div>


<div class="viewcode-block" id="Map.slice">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.Map.slice">[docs]</a>
    <span class="k">def</span> <span class="nf">slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Slice the map, where each argument is the name of a dimension.</span>
<span class="sd">        Dimensions not named are included in full (i.e., via `np.slice(None)`).</span>

<span class="sd">        Note that the resulting map maintains the same number of dimensions as</span>
<span class="sd">        its parent, including the ordering of the dimensions. The size of each</span>
<span class="sd">        dimension, however, is reduced by slicing.</span>

<span class="sd">        Note also that modifications to the returned object&#39;s `hist` will</span>
<span class="sd">        modify the parent&#39;s `hist`.</span>


<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Indexing can be done as in the following examples:</span>

<span class="sd">        &gt;&gt;&gt; mdb = MultiDimBinning([</span>
<span class="sd">        ...     dict(name=&#39;x&#39;, domain=[0,1], is_lin=True, num_bins=5),</span>
<span class="sd">        ...     dict(name=&#39;y&#39;, domain=[1,2], is_lin=True, num_bins=10)</span>
<span class="sd">        ... ])</span>
<span class="sd">        &gt;&gt;&gt; ones = mdb.ones(name=&#39;ones&#39;)</span>
<span class="sd">        &gt;&gt;&gt; print(ones.slice(x=0,))</span>
<span class="sd">        Map(name=&#39;ones&#39;,</span>
<span class="sd">                tex=&#39;{\\rm ones}&#39;,</span>
<span class="sd">                full_comparison=False,</span>
<span class="sd">                hash=None,</span>
<span class="sd">                parent_indexer=(0, slice(None, None, None)),</span>
<span class="sd">                binning=MultiDimBinning([</span>
<span class="sd">                            OneDimBinning(name=OneDimBinning(&#39;x&#39;, 1 bin with edges at [0.0, 0.2] (behavior is linear))),</span>
<span class="sd">                            OneDimBinning(name=OneDimBinning(&#39;y&#39;, 10 equally-sized bins spanning [1.0, 2.0]))]),</span>
<span class="sd">                hist=array([[ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.]]))</span>
<span class="sd">        &gt;&gt;&gt; print(ones.slice(x=0, y=slice(None)).hist)</span>
<span class="sd">        [[ 1.  1.  1.  1.  1.  1.  1.  1.  1.  1.]]</span>
<span class="sd">        &gt;&gt;&gt; print(ones.slice(x=0, y=0).hist)</span>
<span class="sd">        [[ 1.]]</span>

<span class="sd">        Modifications to the slice modifies the original:</span>

<span class="sd">        &gt;&gt;&gt; mdb = MultiDimBinning([</span>
<span class="sd">        ...     dict(name=&#39;x&#39;, domain=[0,1], is_lin=True, num_bins=5),</span>
<span class="sd">        ...     dict(name=&#39;y&#39;, domain=[1,2], is_lin=True, num_bins=10)</span>
<span class="sd">        ... ])</span>
<span class="sd">        &gt;&gt;&gt; ones = mdb.ones(name=&#39;ones&#39;)</span>
<span class="sd">        &gt;&gt;&gt; sl = ones.slice(x=2)</span>
<span class="sd">        &gt;&gt;&gt; sl.hist[...] = 0</span>
<span class="sd">        &gt;&gt;&gt; print(sl.hist)</span>
<span class="sd">        &gt;&gt;&gt; print(ones.hist)</span>
<span class="sd">        [[ 1.  1.  1.  1.  1.  1.  1.  1.  1.  1.]</span>
<span class="sd">         [ 1.  1.  1.  1.  1.  1.  1.  1.  1.  1.]</span>
<span class="sd">         [ 0.  0.  0.  0.  0.  0.  0.  0.  0.  0.]</span>
<span class="sd">         [ 1.  1.  1.  1.  1.  1.  1.  1.  1.  1.]</span>
<span class="sd">         [ 1.  1.  1.  1.  1.  1.  1.  1.  1.  1.]]</span>


<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pisa.core.binning.MultiDimBinning.indexer</span>
<span class="sd">            Method used to generate a raw indexer (that can be used to</span>
<span class="sd">            index into a map or a Numpy array of same dimensionality).</span>
<span class="sd">            This method is accessible from a Map `map_x` object via its</span>
<span class="sd">            `binning` attribute: `map_x.binning.indexer(...)`</span>

<span class="sd">        pisa.core.binning.MultiDimBinning.broadcast</span>
<span class="sd">            Broadcast a 1D Numpy array to dimensionality with reference to this</span>
<span class="sd">            object&#39;s dimensionality.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">indexer</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)]</span></div>


<div class="viewcode-block" id="Map.set_poisson_errors">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.Map.set_poisson_errors">[docs]</a>
    <span class="k">def</span> <span class="nf">set_poisson_errors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Approximate poisson errors using sqrt(n).&quot;&quot;&quot;</span>
        <span class="n">nom_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nominal_values</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span>
            <span class="s1">&#39;_hist&#39;</span><span class="p">,</span>
            <span class="n">unp</span><span class="o">.</span><span class="n">uarray</span><span class="p">(</span><span class="n">nom_values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">nom_values</span><span class="p">))</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Map.set_errors">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.Map.set_errors">[docs]</a>
    <span class="k">def</span> <span class="nf">set_errors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">error_hist</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Manually define the error with an array the same shape as the</span>
<span class="sd">        contained histogram. Can also remove errors by passing None.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        error_hist : None or ndarray (same shape as hist)</span>
<span class="sd">            Standard deviations to apply to `self.hist`.</span>
<span class="sd">            If None is passed, any errors present are removed, making</span>
<span class="sd">            `self.hist` a bare numpy array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">error_hist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span>
                <span class="s1">&#39;_hist&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nominal_values</span>
            <span class="p">)</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assert_compat</span><span class="p">(</span><span class="n">error_hist</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span>
            <span class="s1">&#39;_hist&#39;</span><span class="p">,</span>
            <span class="n">unp</span><span class="o">.</span><span class="n">uarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nominal_values</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">error_hist</span><span class="p">))</span>
        <span class="p">)</span></div>


    <span class="c1"># TODO: make this return an OrderedDict to organize all of the returned</span>
    <span class="c1"># objects</span>
<div class="viewcode-block" id="Map.compare">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.Map.compare">[docs]</a>
    <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compare this map with another, where the other map is taken to be</span>
<span class="sd">        the &quot;reference&quot; against which this is compared.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ref : Map</span>
<span class="sd">            Map against with to compare this one. `ref is taken as reference.</span>
<span class="sd">            Each dimension in `ref.binning` must have the same name and</span>
<span class="sd">            bin edges as this map, but the order of the dimensions does not</span>
<span class="sd">            matter.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        comparisons : OrderedDict containing the following key/value pairs:</span>
<span class="sd">          * &#39;diff&#39; : Map, `self - ref`</span>
<span class="sd">          * &#39;fract&#39; : Map, `self / ref`</span>
<span class="sd">          * &#39;fractdiff&#39; : Map, `(self - ref) / ref`</span>
<span class="sd">          * &#39;max_abs_diff&#39; : float, `max(abs(diff))`</span>
<span class="sd">          * &#39;max_abs_fractdiff&#39; : float, `max(abs(fractdiff))`</span>
<span class="sd">          * &#39;nanmatch&#39; : bool, whether nan elements match</span>
<span class="sd">          * &#39;infmatch&#39; : bool, whether +inf (and separately -inf) entries match</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">Map</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">ref</span><span class="o">.</span><span class="n">binning</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">-</span> <span class="n">ref</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="n">fract</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">/</span> <span class="n">ref</span>
            <span class="n">fractdiff</span> <span class="o">=</span> <span class="n">diff</span> <span class="o">/</span> <span class="n">ref</span>

        <span class="n">max_abs_fractdiff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fractdiff</span><span class="o">.</span><span class="n">nominal_values</span><span class="p">))</span>

        <span class="c1"># Handle cases where ratio returns infinite</span>
        <span class="c1"># This isn&#39;t necessarily a fail, since all it means is the referene was</span>
        <span class="c1"># zero; if the new value is sufficiently close to zero then it&#39;s still</span>
        <span class="c1"># fine.</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">max_abs_fractdiff</span><span class="p">):</span>
            <span class="c1"># First find all the finite elements</span>
            <span class="n">finite_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">fractdiff</span><span class="o">.</span><span class="n">nominal_values</span><span class="p">)</span>
            <span class="c1"># Then find the nanmax of this, will be our new test value</span>
            <span class="n">max_abs_fractdiff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
                <span class="n">fractdiff</span><span class="o">.</span><span class="n">nominal_values</span><span class="p">[</span><span class="n">finite_mask</span><span class="p">]</span>
            <span class="p">))</span>

            <span class="c1"># TODO(bug): Why is ~finite_mask used to select elements here?</span>
            <span class="c1"># Shouldn&#39;t all elements be considered, regardless if fractdiff is</span>
            <span class="c1"># inf somewhere?</span>

            <span class="c1"># Also find all the infinite elements; compute a second test value</span>
            <span class="n">max_abs_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diff</span><span class="o">.</span><span class="n">nominal_values</span><span class="p">[</span><span class="o">~</span><span class="n">finite_mask</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Without any infinite elements we can ignore this second test</span>
            <span class="n">max_abs_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diff</span><span class="o">.</span><span class="n">nominal_values</span><span class="p">))</span>

        <span class="n">nanmatch</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nominal_values</span><span class="p">)</span>
                               <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">nominal_values</span><span class="p">)))</span>
        <span class="n">infmatch</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nominal_values</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nominal_values</span><span class="p">)]</span>
            <span class="o">==</span> <span class="n">ref</span><span class="o">.</span><span class="n">nominal_values</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">nominal_values</span><span class="p">)]</span>
        <span class="p">))</span>

        <span class="n">comparisons</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">([</span>
            <span class="p">(</span><span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="n">diff</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;fract&#39;</span><span class="p">,</span> <span class="n">fract</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;fractdiff&#39;</span><span class="p">,</span> <span class="n">fractdiff</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;max_abs_fractdiff&#39;</span><span class="p">,</span> <span class="n">max_abs_fractdiff</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;max_abs_diff&#39;</span><span class="p">,</span> <span class="n">max_abs_diff</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;nanmatch&#39;</span><span class="p">,</span> <span class="n">nanmatch</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;infmatch&#39;</span><span class="p">,</span> <span class="n">infmatch</span><span class="p">)</span>
        <span class="p">])</span>

        <span class="k">return</span> <span class="n">comparisons</span></div>


<div class="viewcode-block" id="Map.plot">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.Map.plot">[docs]</a>
    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">logz</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clabel</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clabelsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">xlabelsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ylabelsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">titlesize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fig_kw</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">pcolormesh_kw</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">colorbar_kw</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">colorbar_label_kw</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">outdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fname</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">binlabel_format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">binlabel_colors</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;white&quot;</span><span class="p">,</span> <span class="s2">&quot;black&quot;</span><span class="p">],</span> <span class="n">binlabel_color_thresh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">binlabel_stripzeros</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">bad_color</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">pure_bin_names</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bin_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">full_ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot a 2D map.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        symm : bool, optional</span>
<span class="sd">            Plot with symmetric (about 0) value-range limits.</span>

<span class="sd">        logz : bool, optional</span>
<span class="sd">            Plot logarithmic value-range</span>

<span class="sd">        vmin, vmax : float, optional</span>
<span class="sd">            Minimum and maximum values for the value-range of the plot. If None</span>
<span class="sd">            specified, these are set according to `symm` and/or the values of</span>
<span class="sd">            the `hist` in this Map.</span>

<span class="sd">        backend : string, optional</span>
<span class="sd">            Matplotlib backend to use (only takes effect if matplotlib is first</span>
<span class="sd">            imported by this function).</span>

<span class="sd">        ax : matplotlib.axis.Axis, optional</span>
<span class="sd">            Provide an axis onto which the plot is drawn; if None is specified,</span>
<span class="sd">            a new figure and axis are created.</span>

<span class="sd">        title : string, optional</span>
<span class="sd">            Set the title to this value; if None is specified, the title is</span>
<span class="sd">            taken from the name of this Map.</span>

<span class="sd">        cmap : string or matplotlib.colors.Colormap, optional</span>

<span class="sd">        clabel : string, optional</span>
<span class="sd">            Label to place on the colorbar</span>

<span class="sd">        clabelsize, xlabelsize, ylabelsize, titlesize : float, optional</span>
<span class="sd">            Size of the colorbar, x-axis label, y-axis label, and title text</span>

<span class="sd">        fig_kw : mapping, optional</span>
<span class="sd">            Keyword arguments passed to call to matplotlib.pyplot.subplots;</span>
<span class="sd">            this is only done, however, if `ax` is None and so a new figure</span>
<span class="sd">            needs to be created.</span>

<span class="sd">        pcolormesh_kw : mapping, optional</span>
<span class="sd">            Keyword arguments to pass to call to `matplotlib.pyplot.pcolormesh`</span>
<span class="sd">            (if Map is two or more dimensions).</span>

<span class="sd">        colorbar_kw : mapping, optional</span>
<span class="sd">            Keyword arguments to pass to call to `matplotlib.colorbar`.</span>

<span class="sd">        colorbar_label_kw : mapping, optional</span>
<span class="sd">            Keyword arguments to pass to call to `matplotlib.colorbar.set_label`.</span>

<span class="sd">        fmt : string in (&#39;pdf&#39;, &#39;png&#39;) or iterable thereof, optional</span>
<span class="sd">            File format(s) in which to save the file. If None, then the plot</span>
<span class="sd">            will not be saved.</span>

<span class="sd">        outdir : string, optional</span>
<span class="sd">            Directory into which to save the plot. If None is provided, the the</span>
<span class="sd">            default is the current directory. Note that if `fmt` is None, then</span>
<span class="sd">            this argument is irrelevant.</span>

<span class="sd">        fname : string, optional</span>
<span class="sd">             Custom filename to set for saved figure. If not provided, a name</span>
<span class="sd">             is derived from the `name` attribute of the Map. Note that if</span>
<span class="sd">             `fmt` is None, then this argument is irrelevant.</span>

<span class="sd">        binlabel_format : :obj:`str`, optional</span>
<span class="sd">            Format string to label the content in each bin. If None (default), the bins</span>
<span class="sd">            will not be labeled. Bin labels are generated by calling `.format(zi)` on</span>
<span class="sd">            the given string, where `zi` is the z-value of bin i.</span>
<span class="sd">        </span>
<span class="sd">        binlabel_stripzeros : bool, optional</span>
<span class="sd">            Strip zeros from bin labels. Default: `True`</span>

<span class="sd">        binlabel_colors : :obj:`str` or list of :obj:`str`, optional</span>
<span class="sd">            Colors to be used below (index 0) and above (index 1) the</span>
<span class="sd">            `binlabel_color_thresh` value. Default: &quot;white&quot; below and &quot;black&quot; above</span>
<span class="sd">            threshold. If only one :obj:`str` is given, all labels will have that color.</span>

<span class="sd">        binlabel_color_thresh : float or :obj:`str`, optional</span>
<span class="sd">            Threshold at which to switch color of the bin labels for better contrast. If</span>
<span class="sd">            `None` (default), all labels will use the last color given in</span>
<span class="sd">            `binlabel_colors`. If a `float` is given, bins with a value below the given</span>
<span class="sd">            number use the first color in `binlabel_colors` and bins with a value above</span>
<span class="sd">            the given number use the second color in `binlabel_colors`. If &quot;auto&quot;, set</span>
<span class="sd">            threshold automatically (basically half way).</span>
<span class="sd">        dpi : int, optional</span>
<span class="sd">            Dots per inch for saved figure. Default: 300</span>
<span class="sd">        bad_color : string, optional</span>
<span class="sd">            Can choose the color used for &quot;bad&quot; bins (e.g. NaN)</span>
<span class="sd">        pure_bin_names : bool, optional</span>
<span class="sd">            If True, use the (third dimension) bin names as they are defined in binning config, without any formatting. Default: `False`</span>
<span class="sd">        bin_id : int, optional</span>
<span class="sd">            If the map is a slice of a multi-dimensional map, this is the index of the slice.</span>
<span class="sd">            Used for the internal recursive function call, to keep track of current third dimension slice.</span>
<span class="sd">            Default setting produces the correct behaviour for 3-dimensional histograms. Default: `None`</span>
<span class="sd">        full_ax : :class:`matplotlib.axes.Axes`, optional</span>
<span class="sd">            If the map is a slice of a multi-dimensional map, this is the full axis object of the overall map.</span>
<span class="sd">            Used for the internal recursive function call, to keep track of the main axis.</span>
<span class="sd">            Default setting produces the correct behaviour for 3-dimensional histograms. Default: `None`</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fig : :class:`matplotlib.figure.Figure` object</span>
<span class="sd">        ax : :class:`matplotlib.axes.Axes` object</span>
<span class="sd">        pcmesh : :class:`matplotlib.collections.QuadMesh`</span>
<span class="sd">        colorbar : :class:`matplotlib.colorbar.Colorbar`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">matplotlib</span> <span class="k">as</span> <span class="nn">mpl</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="kn">from</span> <span class="nn">mpl_toolkits.axes_grid1</span> <span class="kn">import</span> <span class="n">make_axes_locatable</span>

        <span class="n">cmap_seq</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s2">&quot;Spectral_r&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">cmap_seq</span><span class="o">.</span><span class="n">set_bad</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">cmap_div</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s2">&quot;RdBu_r&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">cmap_div</span><span class="o">.</span><span class="n">set_bad</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># TODO: use https://matplotlib.org/users/colormapnorms.html</span>
        <span class="c1"># to allow for both symm and logz (and to implement logz in the first</span>
        <span class="c1"># place!)</span>
        <span class="k">assert</span> <span class="ow">not</span><span class="p">(</span><span class="n">symm</span> <span class="ow">and</span> <span class="n">logz</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;$</span><span class="si">%s</span><span class="s1">$&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tex</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">tex</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">fname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="n">get_valid_filename</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="n">fig_kw</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">fig_kw</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">fig_kw</span>
        <span class="n">pcolormesh_kw</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">pcolormesh_kw</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">pcolormesh_kw</span>
        <span class="n">colorbar_kw</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">colorbar_kw</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">colorbar_kw</span>
        <span class="n">colorbar_label_kw</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">colorbar_label_kw</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">colorbar_label_kw</span>
        <span class="k">if</span> <span class="n">fmt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
                <span class="n">fmt</span> <span class="o">=</span> <span class="p">[</span><span class="n">fmt</span><span class="p">]</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fmt</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">outdir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">outdir</span> <span class="o">=</span> <span class="s1">&#39;./&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mkdir</span><span class="p">(</span><span class="n">outdir</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="o">**</span><span class="n">fig_kw</span><span class="p">)</span>
            <span class="n">full_ax</span> <span class="o">=</span> <span class="n">ax</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">full_ax</span><span class="o">.</span><span class="n">figure</span>

        <span class="c1"># 2D by arraying them as 1D slices in the smallest dimension(s)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>

            <span class="n">smallest_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">shape</span><span class="p">)]</span>

            <span class="c1"># we need to set the vmin and vmax now by hand:</span>
            <span class="k">if</span> <span class="n">vmin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">vmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">unp</span><span class="o">.</span><span class="n">nominal_values</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">vmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">vmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">unp</span><span class="o">.</span><span class="n">nominal_values</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">symm</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="o">-</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">])</span>
                <span class="n">vmin</span> <span class="o">=</span> <span class="o">-</span><span class="n">v</span>
                <span class="n">vmax</span> <span class="o">=</span> <span class="n">v</span>

            <span class="n">divider</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>

            <span class="c1"># prepare some smaller axes:</span>
            <span class="n">small_axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ax</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">bin_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="p">[</span><span class="n">smallest_dim</span><span class="p">]</span><span class="o">.</span><span class="n">num_bins</span><span class="p">):</span>
                <span class="n">small_axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">divider</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s2">&quot;100%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">sharey</span><span class="o">=</span><span class="n">ax</span><span class="p">))</span>
                <span class="n">small_axes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">bin_idx</span><span class="p">,</span> <span class="n">to_plot</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">smallest_dim</span><span class="p">,</span> <span class="n">pure_bin_names</span><span class="o">=</span><span class="n">pure_bin_names</span><span class="p">)):</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">pcmesh</span><span class="p">,</span> <span class="n">colorbar</span> <span class="o">=</span> <span class="n">to_plot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                    <span class="n">symm</span><span class="o">=</span><span class="n">symm</span><span class="p">,</span> <span class="n">logz</span><span class="o">=</span><span class="n">logz</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span>
                    <span class="n">ax</span><span class="o">=</span><span class="n">small_axes</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">clabel</span><span class="o">=</span><span class="n">clabel</span><span class="p">,</span>
                    <span class="n">clabelsize</span><span class="o">=</span><span class="n">clabelsize</span><span class="p">,</span> <span class="n">xlabelsize</span><span class="o">=</span><span class="n">xlabelsize</span><span class="p">,</span>
                    <span class="n">ylabelsize</span><span class="o">=</span><span class="n">ylabelsize</span><span class="p">,</span> <span class="n">titlesize</span><span class="o">=</span><span class="n">titlesize</span><span class="p">,</span>
                    <span class="n">pcolormesh_kw</span><span class="o">=</span><span class="n">pcolormesh_kw</span><span class="p">,</span> <span class="n">colorbar_kw</span><span class="o">=</span><span class="n">colorbar_kw</span><span class="p">,</span> <span class="n">colorbar_label_kw</span><span class="o">=</span><span class="n">colorbar_label_kw</span><span class="p">,</span>
                    <span class="n">binlabel_format</span><span class="o">=</span><span class="n">binlabel_format</span><span class="p">,</span> <span class="n">binlabel_colors</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;white&quot;</span><span class="p">,</span> <span class="s2">&quot;black&quot;</span><span class="p">],</span>
                    <span class="n">binlabel_color_thresh</span><span class="o">=</span><span class="n">binlabel_color_thresh</span><span class="p">,</span> <span class="n">binlabel_stripzeros</span><span class="o">=</span><span class="n">binlabel_stripzeros</span><span class="p">,</span>
                    <span class="n">bin_id</span><span class="o">=</span><span class="n">bin_idx</span><span class="p">,</span> <span class="n">full_ax</span><span class="o">=</span><span class="n">full_ax</span>
                    <span class="p">)</span>

            <span class="k">if</span> <span class="n">fmt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">fmt_</span> <span class="ow">in</span> <span class="n">fmt</span><span class="p">:</span>
                    <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outdir</span><span class="p">,</span> <span class="n">fname</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">fmt_</span><span class="p">)</span>
                    <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="n">dpi</span><span class="p">)</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;&gt;&gt;&gt;&gt; Plot for inspection saved at </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">full_ax</span><span class="p">,</span> <span class="n">pcmesh</span><span class="p">,</span> <span class="n">colorbar</span>


        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">to_plot</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">to_plot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_plot</span><span class="o">.</span><span class="n">binning</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="n">fmt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">fname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="n">get_valid_filename</span><span class="p">(</span><span class="n">to_plot</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="n">hist</span> <span class="o">=</span> <span class="n">valid_nominal_values</span><span class="p">(</span><span class="n">to_plot</span><span class="o">.</span><span class="n">hist</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">symm</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">cmap_div</span> <span class="k">if</span> <span class="n">cmap</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">cmap</span>
            <span class="k">if</span> <span class="n">vmin</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">vmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">vmax_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">hist</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">vmin</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">vmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">vmax_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">vmax</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">vmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">vmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">vmax_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">vmin</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># neither vmax nor vmin are None</span>
                <span class="k">assert</span> <span class="n">vmax</span> <span class="o">&gt;</span> <span class="n">vmin</span> <span class="ow">and</span> <span class="n">vmax</span> <span class="o">==</span> <span class="o">-</span><span class="n">vmin</span>
                <span class="n">vmax_</span> <span class="o">=</span> <span class="n">vmax</span>
            <span class="n">vmin_</span> <span class="o">=</span> <span class="o">-</span><span class="n">vmax_</span>
        <span class="k">elif</span> <span class="n">logz</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">cmap_seq</span> <span class="k">if</span> <span class="n">cmap</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">cmap</span>
            <span class="n">vmin_</span> <span class="o">=</span> <span class="n">vmin</span> <span class="k">if</span> <span class="n">vmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">hist</span><span class="p">[</span><span class="n">hist</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">vmax_</span> <span class="o">=</span> <span class="n">vmax</span> <span class="k">if</span> <span class="n">vmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">hist</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">cmap_seq</span> <span class="k">if</span> <span class="n">cmap</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">cmap</span>
            <span class="n">vmin_</span> <span class="o">=</span> <span class="n">vmin</span> <span class="k">if</span> <span class="n">vmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">hist</span><span class="p">)</span>
            <span class="n">vmax_</span> <span class="o">=</span> <span class="n">vmax</span> <span class="k">if</span> <span class="n">vmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">hist</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">to_plot</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">bin_edges</span><span class="o">.</span><span class="n">magnitude</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">to_plot</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">bin_edges</span><span class="o">.</span><span class="n">magnitude</span>

        <span class="k">if</span> <span class="n">to_plot</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_log</span><span class="p">:</span>
            <span class="n">xticks</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">))),</span>
                                   <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">to_plot</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_log</span><span class="p">:</span>
            <span class="n">yticks</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">y</span><span class="p">))),</span>
                                   <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="c1"># If user specified a &quot;bad&quot; color, set this</span>
        <span class="c1"># Need a cmap object, so if we just have a string name then get the actual cmap object first</span>
        <span class="k">if</span> <span class="n">bad_color</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="p">:</span> <span class="c1"># Need a cmap</span>
                <span class="n">cmap</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span> 
            <span class="n">cmap</span><span class="o">.</span><span class="n">set_bad</span><span class="p">(</span><span class="n">bad_color</span><span class="p">)</span>

        <span class="n">defaults</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">vmin</span><span class="o">=</span><span class="n">vmin_</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax_</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span>
            <span class="n">shading</span><span class="o">=</span><span class="s1">&#39;flat&#39;</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;face&#39;</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">logz</span><span class="p">:</span>
            <span class="n">defaults</span><span class="p">[</span><span class="s1">&#39;norm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">LogNorm</span><span class="p">(</span>
                <span class="n">vmin_</span><span class="p">,</span> <span class="n">vmax_</span><span class="p">,</span> <span class="n">clip</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">dflt_val</span> <span class="ow">in</span> <span class="n">defaults</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">pcolormesh_kw</span><span class="p">:</span>
                <span class="n">pcolormesh_kw</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">dflt_val</span>

        <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">pcmesh</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">hist</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="o">**</span><span class="n">pcolormesh_kw</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">binlabel_format</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">X_mid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">true_divide</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">Y_mid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">true_divide</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">Y</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:],</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">zi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">X_mid</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">Y_mid</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">hist</span><span class="o">.</span><span class="n">T</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">binlabel_color_thresh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">binlabel_colors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;must give two colors with thresh&quot;</span>
                    <span class="k">if</span> <span class="n">binlabel_color_thresh</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
                        <span class="n">thresh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">hist</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">hist</span><span class="p">)])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">thresh</span> <span class="o">=</span> <span class="n">binlabel_color_thresh</span>
                    <span class="n">txtcolor</span> <span class="o">=</span> <span class="n">binlabel_colors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">zi</span> <span class="o">&lt;</span> <span class="n">thresh</span> <span class="k">else</span> <span class="n">binlabel_colors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">txtcolor</span> <span class="o">=</span> <span class="n">binlabel_colors</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">except</span><span class="p">:</span>  <span class="c1"># if binlabel_colors is not a list</span>
                        <span class="n">txtcolor</span> <span class="o">=</span> <span class="n">binlabel_colors</span>
                <span class="n">binlabel</span> <span class="o">=</span> <span class="n">binlabel_format</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">zi</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">binlabel_stripzeros</span><span class="p">:</span>
                    <span class="n">binlabel</span> <span class="o">=</span> <span class="n">binlabel</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">binlabel</span><span class="p">,</span>
                                <span class="n">horizontalalignment</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span>
                                <span class="n">verticalalignment</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span>
                                <span class="n">color</span><span class="o">=</span><span class="n">txtcolor</span><span class="p">,</span>
                                <span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>


        <span class="c1"># only plot colorbar once</span>
        <span class="k">if</span> <span class="n">bin_id</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">bin_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">colorbar</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">mappable</span><span class="o">=</span><span class="n">pcmesh</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">full_ax</span><span class="p">,</span> <span class="o">**</span><span class="n">colorbar_kw</span><span class="p">)</span>
            <span class="n">colorbar</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">labelsize</span><span class="o">=</span><span class="s1">&#39;large&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">clabel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">colorbar</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="n">clabel</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">clabelsize</span><span class="p">,</span> <span class="o">**</span><span class="n">colorbar_label_kw</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">colorbar</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">xlabel</span> <span class="o">=</span> <span class="s1">&#39;$</span><span class="si">%s</span><span class="s1">$&#39;</span> <span class="o">%</span> <span class="n">to_plot</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span>
        <span class="n">ylabel</span> <span class="o">=</span> <span class="s1">&#39;$</span><span class="si">%s</span><span class="s1">$&#39;</span> <span class="o">%</span> <span class="n">to_plot</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">label</span>

        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">xlabel</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">xlabelsize</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">ylabel</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">ylabelsize</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mf">1.03</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">titlesize</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">to_plot</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_log</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">xticks</span><span class="p">))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">xt</span><span class="p">))</span> <span class="k">for</span> <span class="n">xt</span> <span class="ow">in</span> <span class="n">xticks</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">to_plot</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_log</span><span class="p">:</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">yticks</span><span class="p">))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">yt</span><span class="p">))</span> <span class="k">for</span> <span class="n">yt</span> <span class="ow">in</span> <span class="n">yticks</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">fmt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">fmt_</span> <span class="ow">in</span> <span class="n">fmt</span><span class="p">:</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
                <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outdir</span><span class="p">,</span> <span class="n">fname</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">fmt_</span><span class="p">)</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="n">dpi</span><span class="p">)</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;&gt;&gt;&gt;&gt; Plot for inspection saved at </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fig</span><span class="p">,</span> <span class="n">full_ax</span><span class="p">,</span> <span class="n">pcmesh</span><span class="p">,</span> <span class="n">colorbar</span></div>


    <span class="nd">@_new_obj</span>
    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Hook for deepcopy to correctly handle hists &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{}</span>

<div class="viewcode-block" id="Map.reorder_dimensions">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.Map.reorder_dimensions">[docs]</a>
    <span class="nd">@_new_obj</span>
    <span class="k">def</span> <span class="nf">reorder_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Rearrange the dimensions in the map. This affects both the binning</span>
<span class="sd">        and the contained histogram.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        order : MultiDimBinning or sequence of str, int, or OneDimBinning</span>
<span class="sd">            Ordering desired for the dimensions of this map. See</span>
<span class="sd">            `binning.reorder_dimensions` for details on how to specify `order`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Map : copy of this map but with dimensions reordered</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        rebin</span>
<span class="sd">            Modify Map (and its binning) by splitting or combining adjacent</span>
<span class="sd">            bins</span>

<span class="sd">        downsample</span>
<span class="sd">            Modify Map (and its binning) by combining adjacent bins</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_binning</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">reorder_dimensions</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
        <span class="n">orig_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="p">)))</span>
        <span class="n">new_order</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">use_basenames</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">new_binning</span><span class="p">]</span>
        <span class="c1"># TODO: should this be a deepcopy rather than a simple veiw of the</span>
        <span class="c1"># original hist (the result of np.moveaxis)?</span>
        <span class="n">new_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">new_order</span><span class="p">,</span>
                               <span class="n">destination</span><span class="o">=</span><span class="n">orig_order</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;hist&#39;</span><span class="p">:</span> <span class="n">new_hist</span><span class="p">,</span> <span class="s1">&#39;binning&#39;</span><span class="p">:</span> <span class="n">new_binning</span><span class="p">}</span></div>


<div class="viewcode-block" id="Map.squeeze">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.Map.squeeze">[docs]</a>
    <span class="nd">@_new_obj</span>
    <span class="k">def</span> <span class="nf">squeeze</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove any singleton dimensions (i.e. that have only a single bin).</span>
<span class="sd">        Analagous to `numpy.squeeze`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Map with equivalent values but singleton dimensions removed</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_binning</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="n">new_hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;hist&#39;</span><span class="p">:</span> <span class="n">new_hist</span><span class="p">,</span> <span class="s1">&#39;binning&#39;</span><span class="p">:</span> <span class="n">new_binning</span><span class="p">}</span></div>


<div class="viewcode-block" id="Map.round2int">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.Map.round2int">[docs]</a>
    <span class="nd">@_new_obj</span>
    <span class="k">def</span> <span class="nf">round2int</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">binning</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span>
        <span class="n">nominal_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nominal_values</span><span class="p">)</span>
        <span class="n">std_devs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">std_devs</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;hist&#39;</span><span class="p">:</span> <span class="n">unp</span><span class="o">.</span><span class="n">uarray</span><span class="p">(</span><span class="n">nominal_values</span><span class="p">,</span> <span class="n">std_devs</span><span class="p">)}</span></div>


<div class="viewcode-block" id="Map.sum">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.Map.sum">[docs]</a>
    <span class="nd">@_new_obj</span>
    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sum over dimensions corresponding to `axis` specification. Similar</span>
<span class="sd">        in behavior to `numpy.sum` method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : None; or str, int, or sequence thereof</span>
<span class="sd">            Dimension(s) to be summed over. If None, sum over _all_ dimensions.</span>

<span class="sd">        keepdims : bool</span>
<span class="sd">            If True, marginalizes out (removes) the specified dimensions. If</span>
<span class="sd">            False, the binning in the summed dimension(s) is expanded to the</span>
<span class="sd">            full range of the binning for each dimension over which the sum is</span>
<span class="sd">            performed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        s : Map or scalar</span>
<span class="sd">            If all contained dimensiosn are summed over and `keepdims` is</span>
<span class="sd">            False, a scalar is returned. Otherwise, a Map is returned with</span>
<span class="sd">            dimensions marginalized out in the sum removed if `keepdims` is</span>
<span class="sd">            False.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#TODO This function does&#39;t work if axis=None, since @_new_obj expects the output to be a map</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">names</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="p">(</span><span class="n">string_types</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="c1"># Note that the tuple is necessary here (I think...)</span>
        <span class="n">sum_indices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">])</span>
        <span class="n">new_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">sum_indices</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>

        <span class="n">new_binning</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">dims</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">sum_indices</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">keepdims</span><span class="p">:</span>
                    <span class="n">new_binning</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dim</span><span class="o">.</span><span class="n">downsample</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dim</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_binning</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;hist&#39;</span><span class="p">:</span> <span class="n">new_hist</span><span class="p">,</span> <span class="s1">&#39;binning&#39;</span><span class="p">:</span> <span class="n">new_binning</span><span class="p">}</span></div>


<div class="viewcode-block" id="Map.project">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.Map.project">[docs]</a>
    <span class="k">def</span> <span class="nf">project</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Project all dimensions onto a single `axis`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : string or int</span>
<span class="sd">            Dimensions to be projected onto.</span>
<span class="sd">        keepdims : bool</span>
<span class="sd">            If True, marginalizes out (removes) the _un_specified dimensions.</span>
<span class="sd">            If False, the binning in the summed dimension(s) includes</span>
<span class="sd">            the full range of the binning for each dimension in the original</span>
<span class="sd">            Map. Note that if you want to remove all _singleton_ dimensions</span>
<span class="sd">            (which could include the `axis` specified here), call the</span>
<span class="sd">            `squeeze` method on the result of `project`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        projection : Map</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">keep_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">sum_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">dims</span><span class="p">)))</span>
        <span class="n">sum_indices</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">keep_index</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">sum_indices</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span></div>


<div class="viewcode-block" id="Map.rebin">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.Map.rebin">[docs]</a>
    <span class="nd">@_new_obj</span>
    <span class="k">def</span> <span class="nf">rebin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_binning</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Rebin the map with bin edge locations and names according to those</span>
<span class="sd">        specified in `new_binning`.</span>

<span class="sd">        Calls the `rebin` function in the pisa.core.map.rebin module to do the</span>
<span class="sd">        actual work.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        new_binning : MultiDimBinning</span>
<span class="sd">            Dimensions specified in `new_binning` must match (modulo</span>
<span class="sd">            pre/suffixes) the current dimensions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Map binned according to `new_binning`.</span>

<span class="sd">        See Also</span>
<span class="sd">        ---------</span>
<span class="sd">        `pisa.core.map.rebin` : function called to do the work</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: put uncertainties in</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;`rebin` function does not currenty support bin masking&quot;</span>

        <span class="n">new_hist</span> <span class="o">=</span> <span class="n">rebin</span><span class="p">(</span><span class="n">hist</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span> <span class="n">orig_binning</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="p">,</span>
                         <span class="n">new_binning</span><span class="o">=</span><span class="n">new_binning</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;hist&#39;</span><span class="p">:</span> <span class="n">new_hist</span><span class="p">,</span> <span class="s1">&#39;binning&#39;</span><span class="p">:</span> <span class="n">new_binning</span><span class="p">}</span></div>


<div class="viewcode-block" id="Map.downsample">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.Map.downsample">[docs]</a>
    <span class="k">def</span> <span class="nf">downsample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Downsample by integer factor(s), summing together merged bins&#39;</span>
<span class="sd">        values.</span>

<span class="sd">        See pisa.utils.binning.MultiDimBinning.downsample for args/kwargs</span>
<span class="sd">        details.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_binning</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">downsample</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rebin</span><span class="p">(</span><span class="n">new_binning</span><span class="p">)</span></div>


<div class="viewcode-block" id="Map.fluctuate">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.Map.fluctuate">[docs]</a>
    <span class="nd">@_new_obj</span>
    <span class="k">def</span> <span class="nf">fluctuate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">jumpahead</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply fluctuations to the map&#39;s values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : None or string</span>
<span class="sd">            Valid strings are &#39;&#39;, &#39;none&#39;, &#39;poisson&#39;, &#39;scaled_poisson&#39;, &#39;gauss&#39;, or</span>
<span class="sd">            &#39;gauss+poisson&#39;. Strings are case-insensitive and whitespace is</span>
<span class="sd">            removed.</span>
<span class="sd">            The &#39;scaled_poisson&#39; method implements a Scaled Poisson Process, which is</span>
<span class="sd">            a better approximation than a normal distribution to the true distribution</span>
<span class="sd">            of bin counts that are the result of a Poisson process with weighted events[1].</span>
<span class="sd">            The fluctuated maps are guaranteed to have the same mean and standard</span>
<span class="sd">            deviation as the original map.</span>

<span class="sd">        random_state : None or type accepted by utils.random_numbers.get_random_state</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fluctuated_map : Map</span>
<span class="sd">            New map with entries fluctuated as compared to this map</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        ..  [1] Bohm &amp; Zech, &quot;Statistics of weighted Poisson events and its applications&quot; (2013),</span>
<span class="sd">            https://arxiv.org/abs/1309.1287</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">orig</span> <span class="o">=</span> <span class="n">method</span>
        <span class="n">method</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">method</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">FLUCTUATE_METHODS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Map fluctuation method &quot;</span><span class="si">%s</span><span class="s1">&quot; not recognized! Valid choices are:&#39;</span>
                <span class="s1">&#39; </span><span class="si">%s</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">FLUCTUATE_METHODS</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;poisson&#39;</span><span class="p">:</span>
            <span class="n">random_state</span> <span class="o">=</span> <span class="n">get_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">,</span> <span class="n">jumpahead</span><span class="o">=</span><span class="n">jumpahead</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                <span class="n">orig_hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nominal_values</span>
                <span class="n">nan_at</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">orig_hist</span><span class="p">)</span>
                <span class="n">valid_mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">nan_at</span>

                <span class="n">hist_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">orig_hist</span><span class="p">)</span>
                <span class="n">hist_vals</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">poisson</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span>
                    <span class="n">orig_hist</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">],</span>
                    <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span>
                <span class="p">)</span>
                <span class="n">hist_vals</span><span class="p">[</span><span class="n">nan_at</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

                <span class="n">error_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">orig_hist</span><span class="p">)</span>
                <span class="n">error_vals</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">orig_hist</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">])</span>
                <span class="n">error_vals</span><span class="p">[</span><span class="n">nan_at</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;hist&#39;</span><span class="p">:</span> <span class="n">unp</span><span class="o">.</span><span class="n">uarray</span><span class="p">(</span><span class="n">hist_vals</span><span class="p">,</span> <span class="n">error_vals</span><span class="p">)}</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;scaled_poisson&#39;</span><span class="p">:</span>
            <span class="n">random_state</span> <span class="o">=</span> <span class="n">get_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">,</span> <span class="n">jumpahead</span><span class="o">=</span><span class="n">jumpahead</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                <span class="n">orig_hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nominal_values</span>
                <span class="n">sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">std_devs</span>

                <span class="n">nan_at</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">orig_hist</span><span class="p">)</span>
                <span class="n">zero_at</span> <span class="o">=</span> <span class="n">orig_hist</span> <span class="o">==</span> <span class="mf">0.</span>
                <span class="n">valid_mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">nan_at</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">sigma</span><span class="p">[</span><span class="n">valid_mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">zero_at</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">):</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="s2">&quot;Some bins have non-zero counts but no assiciated error! &quot;</span>
                        <span class="s2">&quot;All errors will be set to their Poisson expectation now. &quot;</span>
                        <span class="s2">&quot;To avoid this warning, call `set_poisson_errors()` on the &quot;</span>
                        <span class="s2">&quot;map or set non-zero errors manually.&quot;</span>
                    <span class="p">)</span>
                    <span class="n">sigma</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">orig_hist</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">])</span>
                <span class="n">variance_valid</span> <span class="o">=</span> <span class="n">sigma</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>

                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">variance_valid</span><span class="p">,</span> <span class="n">orig_hist</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">],</span> <span class="o">**</span><span class="n">ALLCLOSE_KW</span><span class="p">):</span>
                    <span class="n">scale_factor</span> <span class="o">=</span> <span class="mf">1.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">scale_factor</span> <span class="o">=</span> <span class="n">variance_valid</span><span class="o">/</span><span class="n">orig_hist</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">]</span>
                <span class="n">poisson_lambda</span> <span class="o">=</span> <span class="n">orig_hist</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">]</span><span class="o">/</span><span class="n">scale_factor</span>

                <span class="n">hist_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">orig_hist</span><span class="p">)</span>
                <span class="n">hist_vals</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">poisson</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span>
                    <span class="n">poisson_lambda</span><span class="p">,</span>
                    <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span>
                <span class="p">)</span>
                <span class="n">hist_vals</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">]</span> <span class="o">*=</span> <span class="n">scale_factor</span>
                <span class="n">hist_vals</span><span class="p">[</span><span class="n">nan_at</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">hist_vals</span><span class="p">[</span><span class="n">zero_at</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
                <span class="c1"># the standard deviation is unchanged</span>
                <span class="n">sigma</span><span class="p">[</span><span class="n">nan_at</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;hist&#39;</span><span class="p">:</span> <span class="n">unp</span><span class="o">.</span><span class="n">uarray</span><span class="p">(</span><span class="n">hist_vals</span><span class="p">,</span> <span class="n">sigma</span><span class="p">)}</span>

        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;gauss+poisson&#39;</span><span class="p">:</span>
            <span class="n">random_state</span> <span class="o">=</span> <span class="n">get_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">,</span> <span class="n">jumpahead</span><span class="o">=</span><span class="n">jumpahead</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                <span class="n">orig_hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nominal_values</span>
                <span class="n">sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">std_devs</span>
                <span class="n">nan_at</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">orig_hist</span><span class="p">)</span>
                <span class="n">valid_mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">nan_at</span>
                <span class="n">gauss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">orig_hist</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="n">gauss</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span>
                    <span class="n">loc</span><span class="o">=</span><span class="n">orig_hist</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">],</span> <span class="n">scale</span><span class="o">=</span><span class="n">sigma</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">],</span>
                    <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span>
                <span class="p">)</span>

                <span class="n">hist_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">orig_hist</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="n">hist_vals</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">poisson</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span>
                    <span class="n">gauss</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">],</span>
                    <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span>
                <span class="p">)</span>
                <span class="n">hist_vals</span><span class="p">[</span><span class="n">nan_at</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

                <span class="n">error_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">orig_hist</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="n">error_vals</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">orig_hist</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">])</span>
                <span class="n">error_vals</span><span class="p">[</span><span class="n">nan_at</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;hist&#39;</span><span class="p">:</span> <span class="n">unp</span><span class="o">.</span><span class="n">uarray</span><span class="p">(</span><span class="n">hist_vals</span><span class="p">,</span> <span class="n">error_vals</span><span class="p">)}</span>

        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;gauss&#39;</span><span class="p">:</span>
            <span class="n">random_state</span> <span class="o">=</span> <span class="n">get_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">,</span> <span class="n">jumpahead</span><span class="o">=</span><span class="n">jumpahead</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                <span class="n">orig_hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nominal_values</span>
                <span class="n">sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">std_devs</span>
                <span class="n">nan_at</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">orig_hist</span><span class="p">)</span>
                <span class="n">valid_mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">nan_at</span>
                <span class="n">hist_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">orig_hist</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="n">hist_vals</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span>
                    <span class="n">loc</span><span class="o">=</span><span class="n">orig_hist</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">],</span> <span class="n">scale</span><span class="o">=</span><span class="n">sigma</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">],</span>
                    <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span>
                <span class="p">)</span>

                <span class="n">hist_vals</span><span class="p">[</span><span class="n">nan_at</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">error_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">orig_hist</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="n">error_vals</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">orig_hist</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">])</span>
                <span class="n">error_vals</span><span class="p">[</span><span class="n">nan_at</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;hist&#39;</span><span class="p">:</span> <span class="n">unp</span><span class="o">.</span><span class="n">uarray</span><span class="p">(</span><span class="n">hist_vals</span><span class="p">,</span> <span class="n">error_vals</span><span class="p">)}</span>

        <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;none&#39;</span><span class="p">]:</span>
            <span class="k">return</span> <span class="p">{}</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;tuple : shape of the map, akin to `nump.ndarray.shape`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="o">.</span><span class="n">shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;int : total number of elements&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="o">.</span><span class="n">size</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_entries</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;int : total number of weighted entries in all bins&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">valid_nominal_values</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">serializable_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;hist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nominal_values</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;binning&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">serializable_state</span>
        <span class="n">stddevs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">std_devs</span>
        <span class="n">stddevs</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">stddevs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">else</span> <span class="n">stddevs</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;error_hist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stddevs</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;hash&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;tex&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tex</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;full_comparison&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_comparison</span>
        <span class="k">return</span> <span class="n">state</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">hashable_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalize_values</span><span class="p">:</span>
            <span class="n">state</span><span class="p">[</span><span class="s1">&#39;hist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">normQuant</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nominal_values</span><span class="p">,</span>
                                      <span class="n">sigfigs</span><span class="o">=</span><span class="n">HASH_SIGFIGS</span><span class="p">)</span>
            <span class="n">stddevs</span> <span class="o">=</span> <span class="n">normQuant</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">std_devs</span><span class="p">,</span> <span class="n">sigfigs</span><span class="o">=</span><span class="n">HASH_SIGFIGS</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">state</span><span class="p">[</span><span class="s1">&#39;hist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nominal_values</span>
            <span class="n">stddevs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">std_devs</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;binning&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">hashable_state</span>
        <span class="c1"># TODO: better check here to see if the contained datatype is unp, as</span>
        <span class="c1"># opposed to 0 stddev (which could be the case but the user wants for</span>
        <span class="c1"># uncertainties to propagate)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">stddevs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">stddevs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalize_values</span><span class="p">:</span>
            <span class="n">stddevs</span> <span class="o">=</span> <span class="n">normQuant</span><span class="p">(</span><span class="n">stddevs</span><span class="p">,</span> <span class="n">sigfigs</span><span class="o">=</span><span class="n">HASH_SIGFIGS</span><span class="p">)</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;error_hist&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stddevs</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;full_comparison&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">full_comparison</span>
        <span class="k">return</span> <span class="n">state</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">normalize_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_values</span>

    <span class="nd">@normalize_values</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">normalize_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_values</span> <span class="o">=</span> <span class="n">b</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">serializable_state</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">state</span><span class="p">)</span>

<div class="viewcode-block" id="Map.to_json">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.Map.to_json">[docs]</a>
    <span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Serialize the state to a JSON file that can be instantiated as a new</span>
<span class="sd">        object later.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">            Filename; must be either a relative or absolute path (*not</span>
<span class="sd">            interpreted as a PISA resource specification*)</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Further keyword args are sent to `pisa.utils.jsons.to_json()`</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        from_json : Intantiate new object from the file written by this method</span>
<span class="sd">        pisa.utils.jsons.to_json</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">jsons</span><span class="o">.</span><span class="n">to_json</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">serializable_state</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Map.from_json">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.Map.from_json">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_json</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">resource</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instantiate a new Map object from a JSON file.</span>

<span class="sd">        The format of the JSON is generated by the `Map.to_json` method, which</span>
<span class="sd">        converts a Map object to basic types and then numpy arrays are</span>
<span class="sd">        converted in a call to `pisa.utils.jsons.to_json`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        resource : str</span>
<span class="sd">            A PISA resource specification (see pisa.utils.resources)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        to_json</span>
<span class="sd">        pisa.utils.jsons.to_json</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">jsons</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">resource</span><span class="p">)</span>
        <span class="c1"># State is a dict with kwargs, so instantiate with double-asterisk</span>
        <span class="c1"># syntax</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">state</span><span class="p">)</span></div>


<div class="viewcode-block" id="Map.assert_compat">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.Map.assert_compat">[docs]</a>
    <span class="k">def</span> <span class="nf">assert_compat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="n">uncertainties</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">assert_array_fits</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Map</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">assert_compat</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">binning</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unhandled type </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">))</span></div>


<div class="viewcode-block" id="Map.iterbins">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.Map.iterbins">[docs]</a>
    <span class="k">def</span> <span class="nf">iterbins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a bin iterator which yields a map containing a single bin</span>
<span class="sd">        each time. Note that modifications to that single-bin map will be</span>
<span class="sd">        reflected in this (the parent) map.</span>

<span class="sd">        Note that the returned map has the attribute `parent_indexer` for</span>
<span class="sd">        indexing directly into to the parent map (or to a similar map).</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        Map object containing one of each bin of this Map</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="n">idx_coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">index2coord</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">idx_view</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">idx_coord</span><span class="p">)</span>
            <span class="n">single_bin_map</span> <span class="o">=</span> <span class="n">Map</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="n">hist</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">[</span><span class="n">idx_view</span><span class="p">],</span>
                <span class="n">binning</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="p">[</span><span class="n">idx_coord</span><span class="p">],</span>
                <span class="nb">hash</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">tex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tex</span><span class="p">,</span>
                <span class="n">full_comparison</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">full_comparison</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">single_bin_map</span><span class="o">.</span><span class="n">parent_indexer</span> <span class="o">=</span> <span class="n">idx_coord</span>
            <span class="k">yield</span> <span class="n">single_bin_map</span></div>


    <span class="c1"># TODO : example!</span>
<div class="viewcode-block" id="Map.itercoords">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.Map.itercoords">[docs]</a>
    <span class="k">def</span> <span class="nf">itercoords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterator that yields the coordinate of each bin in the map.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">itercoords</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No hash defined.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Only allow setting attributes defined in slots&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slots</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Attribute &quot;</span><span class="si">%s</span><span class="s1">&quot; not allowed to be set.&#39;</span> <span class="o">%</span> <span class="n">attr</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_slice_or_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Slice or index into the map. Indexing single element in self.hist</span>
<span class="sd">        e.g. hist[1,3] returns a 0D array while hist[1,3:8] returns a 1D array,</span>
<span class="sd">        but we need 2D (in his example)... so reshape after indexing (the</span>
<span class="sd">        indexed binning obj implements this logic and so knows the shape the</span>
<span class="sd">        hist should be).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_binning</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="n">new_map</span> <span class="o">=</span> <span class="n">Map</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                      <span class="n">hist</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">new_binning</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
                      <span class="n">binning</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                      <span class="nb">hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hash</span><span class="p">,</span>
                      <span class="n">tex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tex</span><span class="p">,</span>
                      <span class="n">full_comparison</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">full_comparison</span><span class="p">)</span>
        <span class="n">new_map</span><span class="o">.</span><span class="n">parent_indexer</span> <span class="o">=</span> <span class="n">idx</span>
        <span class="k">return</span> <span class="n">new_map</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_slice_or_index</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

    <span class="c1"># TODO: if no bin name is given (i.e., 1D indexing), then split into maps</span>
    <span class="c1"># and return a MapSet with a map per bin; append &#39;__%s__%s&#39; %(dim_name,</span>
    <span class="c1"># bin_name) to this map&#39;s name to name each new map, and if no bin names</span>
    <span class="c1"># are given, use str(int(ind)) instead for bin_name.</span>
<div class="viewcode-block" id="Map.split">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.Map.split">[docs]</a>
    <span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="nb">bin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_basenames</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">pure_bin_names</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Split this map into one or more maps by selecting the `dim`</span>
<span class="sd">        dimension and optionally the specific bin(s) within that dimension</span>
<span class="sd">        specified by `bin`.</span>

<span class="sd">        If both `dim` and `bin` are specified and this identifies a single bin,</span>
<span class="sd">        a single Map is returned, while if this locates multiple bins, a MapSet</span>
<span class="sd">        is returned where each map corresponds to a bin (in the order dictated</span>
<span class="sd">        by the `bin` specification).</span>

<span class="sd">        If only `dim` is specified, _regardless_ if multiple bins meet the</span>
<span class="sd">        (dim, bin) criteria, the maps corresponding to each `bin` are collected</span>
<span class="sd">        into a MapSet and returned.</span>

<span class="sd">        Resulting maps are ordered according to the binning and are renamed as:</span>

<span class="sd">            new_map[j].name = orig_map.name__dim.binning.bin_names[i]</span>

<span class="sd">        if the current map has a name, or</span>

<span class="sd">            new_map[j].name = dim.binning.bin_names[i]</span>

<span class="sd">        if the current map has a zero-length name.</span>

<span class="sd">        In the above, j is the index into the new MapSet and i is the index to</span>
<span class="sd">        the bin in the original binning spec. `map.name` is the current</span>
<span class="sd">        (pre-split) map&#39;s name, and if the bins do not have names, then the</span>
<span class="sd">        stringified integer index to the bin, str(i), is used instead.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim : string, int</span>
<span class="sd">            Name or index of a dimension in the map</span>
<span class="sd">        bin : None or bin indexing object (str, int, slice, ellipsis)</span>
<span class="sd">            Optionally specify specific bin(s) to split out from the chosen</span>
<span class="sd">            dimension.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        split_maps : Map or MapSet</span>
<span class="sd">            If only `dim` is passed, returns MapSet regardless of how many maps</span>
<span class="sd">            are found. If both `dim` and `bin` are specified and this results</span>
<span class="sd">            in selecting more than one bin, also returns a MapSet. However if</span>
<span class="sd">            both `dim` and `bin` are specified and this selects a single bin,</span>
<span class="sd">            just the indexed Map is returned. Naming of the maps and MapSet is</span>
<span class="sd">            updated to reflect what the map represents, while the hash value is</span>
<span class="sd">            copied into the new map(s).</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">dim_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">use_basenames</span><span class="o">=</span><span class="n">use_basenames</span><span class="p">)</span>
        <span class="n">spliton_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">dims</span><span class="p">[</span><span class="n">dim_index</span><span class="p">]</span>

        <span class="c1"># Move the dimension we&#39;re going to split on to be the first dim</span>
        <span class="n">new_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="p">)))</span>
        <span class="n">new_order</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">dim_index</span><span class="p">)</span>
        <span class="n">new_order</span> <span class="o">=</span> <span class="p">[</span><span class="n">dim_index</span><span class="p">]</span> <span class="o">+</span> <span class="n">new_order</span>
        <span class="n">rearranged_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reorder_dimensions</span><span class="p">(</span><span class="n">new_order</span><span class="p">)</span>
        <span class="n">rearranged_hist</span> <span class="o">=</span> <span class="n">rearranged_map</span><span class="o">.</span><span class="n">hist</span>
        <span class="n">rearranged_dims</span> <span class="o">=</span> <span class="n">rearranged_map</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">dims</span>

        <span class="c1"># Take all dims except the one being split on</span>
        <span class="n">new_binning</span> <span class="o">=</span> <span class="n">rearranged_dims</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="n">singleton</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">bin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">bin</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">string_types</span><span class="p">)):</span>
                <span class="n">bin_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">spliton_dim</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">bin</span><span class="p">)]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">bin</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                <span class="n">bin_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spliton_dim</span><span class="p">)))[</span><span class="nb">bin</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">bin</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">:</span>
                <span class="n">bin_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spliton_dim</span><span class="p">)))</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">singleton</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bin_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spliton_dim</span><span class="p">)))</span>

        <span class="n">maps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">bin_index</span> <span class="ow">in</span> <span class="n">bin_indices</span><span class="p">:</span>
            <span class="nb">bin</span> <span class="o">=</span> <span class="n">spliton_dim</span><span class="p">[</span><span class="n">bin_index</span><span class="p">]</span>
            <span class="n">new_hist</span> <span class="o">=</span> <span class="n">rearranged_hist</span><span class="p">[</span><span class="n">bin_index</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">bin</span><span class="o">.</span><span class="n">bin_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">bin_name</span> <span class="o">=</span> <span class="nb">bin</span><span class="o">.</span><span class="n">bin_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">bin_tex</span> <span class="o">=</span> <span class="s1">&#39;=&#39;</span> <span class="o">+</span> <span class="n">text2tex</span><span class="p">(</span><span class="n">bin_name</span><span class="p">)</span>
                <span class="n">pure_bin_tex</span> <span class="o">=</span> <span class="n">text2tex</span><span class="p">(</span><span class="n">bin_name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bin_name</span> <span class="o">=</span> <span class="s1">&#39;bin_</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">bin_index</span>
                <span class="n">bin_tex</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;{\;}bin{\;}</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">bin_index</span>

            <span class="n">name_elements</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">spliton_dim</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">bin_name</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">name_elements</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="n">new_name</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">name_elements</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">pure_bin_names</span><span class="p">:</span>
                <span class="n">new_tex</span> <span class="o">=</span> <span class="n">pure_bin_tex</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_tex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tex</span> <span class="o">+</span> <span class="s1">&#39;,&#39;</span> <span class="o">+</span> <span class="sa">r</span><span class="s1">&#39;{\;}&#39;</span> <span class="o">+</span> <span class="n">spliton_dim</span><span class="o">.</span><span class="n">tex</span> <span class="o">+</span> <span class="n">bin_tex</span>

            <span class="n">maps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">Map</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">new_name</span><span class="p">,</span> <span class="n">hist</span><span class="o">=</span><span class="n">new_hist</span><span class="p">,</span> <span class="n">binning</span><span class="o">=</span><span class="n">new_binning</span><span class="p">,</span>
                    <span class="nb">hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hash</span><span class="p">,</span> <span class="n">tex</span><span class="o">=</span><span class="n">new_tex</span><span class="p">,</span>
                    <span class="n">full_comparison</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">full_comparison</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">singleton</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">maps</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">maps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mapset_name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">__split_on__</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">spliton_dim</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mapset_name</span> <span class="o">=</span> <span class="s1">&#39;split_on__</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">spliton_dim</span><span class="o">.</span><span class="n">name</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tex</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mapset_tex</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">, \; </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tex</span><span class="p">,</span> <span class="n">spliton_dim</span><span class="o">.</span><span class="n">tex</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mapset_tex</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">spliton_dim</span><span class="o">.</span><span class="n">tex</span>

        <span class="k">return</span> <span class="n">MapSet</span><span class="p">(</span><span class="n">maps</span><span class="o">=</span><span class="n">maps</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">mapset_name</span><span class="p">,</span> <span class="n">tex</span><span class="o">=</span><span class="n">mapset_tex</span><span class="p">)</span></div>


<div class="viewcode-block" id="Map.llh">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.Map.llh">[docs]</a>
    <span class="k">def</span> <span class="nf">llh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expected_values</span><span class="p">,</span> <span class="n">binned</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the total log-likelihood value between this map and the</span>
<span class="sd">        map described by `expected_values`; self is taken to be the &quot;actual</span>
<span class="sd">        values&quot; (or (pseudo)data), and `expected_values` are the expectation</span>
<span class="sd">        values for each bin.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        expected_values : numpy.ndarray or Map of same dimension as this</span>

<span class="sd">        binned : bool</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        total_llh : float or binned_llh if binned=True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">expected_values</span> <span class="o">=</span> <span class="n">reduceToHist</span><span class="p">(</span><span class="n">expected_values</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">binned</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">llh</span><span class="p">(</span><span class="n">actual_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span>
                             <span class="n">expected_values</span><span class="o">=</span><span class="n">expected_values</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">llh</span><span class="p">(</span><span class="n">actual_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span>
                                <span class="n">expected_values</span><span class="o">=</span><span class="n">expected_values</span><span class="p">))</span></div>


<div class="viewcode-block" id="Map.mcllh_mean">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.Map.mcllh_mean">[docs]</a>
    <span class="k">def</span> <span class="nf">mcllh_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expected_values</span><span class="p">,</span> <span class="n">binned</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the total LMean log-likelihood value between this map and the</span>
<span class="sd">        map described by `expected_values`; self is taken to be the &quot;actual</span>
<span class="sd">        values&quot; (or (pseudo)data), and `expected_values` are the expectation</span>
<span class="sd">        values for each bin.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        expected_values : numpy.ndarray or Map of same dimension as this</span>

<span class="sd">        binned : bool</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        total_llh : float or binned_llh if binned=True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">expected_values</span> <span class="o">=</span> <span class="n">reduceToHist</span><span class="p">(</span><span class="n">expected_values</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">binned</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">mcllh_mean</span><span class="p">(</span><span class="n">actual_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span>
                             <span class="n">expected_values</span><span class="o">=</span><span class="n">expected_values</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">mcllh_mean</span><span class="p">(</span><span class="n">actual_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span>
                                <span class="n">expected_values</span><span class="o">=</span><span class="n">expected_values</span><span class="p">))</span></div>



<div class="viewcode-block" id="Map.mcllh_eff">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.Map.mcllh_eff">[docs]</a>
    <span class="k">def</span> <span class="nf">mcllh_eff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expected_values</span><span class="p">,</span> <span class="n">binned</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the total LEff log-likelihood value between this map and the</span>
<span class="sd">        map described by `expected_values`; self is taken to be the &quot;actual</span>
<span class="sd">        values&quot; (or (pseudo)data), and `expected_values` are the expectation</span>
<span class="sd">        values for each bin.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        expected_values : numpy.ndarray or Map of same dimension as this</span>

<span class="sd">        binned : bool</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        total_llh : float or binned_llh if binned=True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">expected_values</span> <span class="o">=</span> <span class="n">reduceToHist</span><span class="p">(</span><span class="n">expected_values</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">binned</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">mcllh_eff</span><span class="p">(</span><span class="n">actual_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span>
                             <span class="n">expected_values</span><span class="o">=</span><span class="n">expected_values</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">mcllh_eff</span><span class="p">(</span><span class="n">actual_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span>
                                <span class="n">expected_values</span><span class="o">=</span><span class="n">expected_values</span><span class="p">))</span></div>


<div class="viewcode-block" id="Map.conv_llh">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.Map.conv_llh">[docs]</a>
    <span class="k">def</span> <span class="nf">conv_llh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expected_values</span><span class="p">,</span> <span class="n">binned</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the total convoluted log-likelihood value between this map</span>
<span class="sd">        and the map described by `expected_values`; self is taken to be the</span>
<span class="sd">        &quot;actual values&quot; (or (pseudo)data), and `expected_values` are the</span>
<span class="sd">        expectation values for each bin.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        expected_values : numpy.ndarray or Map of same dimension as this</span>

<span class="sd">        binned : bool</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        total_conv_llh : float or binned_conv_llh if binned=True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">expected_values</span> <span class="o">=</span> <span class="n">reduceToHist</span><span class="p">(</span><span class="n">expected_values</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">binned</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">conv_llh</span><span class="p">(</span><span class="n">actual_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span>
                                  <span class="n">expected_values</span><span class="o">=</span><span class="n">expected_values</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">conv_llh</span><span class="p">(</span><span class="n">actual_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span>
                                     <span class="n">expected_values</span><span class="o">=</span><span class="n">expected_values</span><span class="p">))</span></div>


<div class="viewcode-block" id="Map.barlow_llh">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.Map.barlow_llh">[docs]</a>
    <span class="k">def</span> <span class="nf">barlow_llh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expected_values</span><span class="p">,</span> <span class="n">binned</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the total barlow log-likelihood value between this map and</span>
<span class="sd">        the map described by `expected_values`; self is taken to be the &quot;actual</span>
<span class="sd">        values&quot; (or (pseudo)data), and `expected_values` are the expectation</span>
<span class="sd">        values for each bin. I assumes at the moment some things that are not</span>
<span class="sd">        true, namely that the weights are uniform</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        expected_values : numpy.ndarray or Map of same dimension as this</span>

<span class="sd">        binned : bool</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        total_barlow_llh : float or binned_barlow_llh if binned=True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: should this handle reduceToHist / expected_values as other</span>
        <span class="c1"># methods do, or should they handle these the way this method does?</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expected_values</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Map</span><span class="p">,</span> <span class="n">MapSet</span><span class="p">)):</span>
            <span class="n">expected_values</span> <span class="o">=</span> <span class="n">reduceToHist</span><span class="p">(</span><span class="n">expected_values</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expected_values</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">expected_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">reduceToHist</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">expected_values</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">binned</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">barlow_llh</span><span class="p">(</span><span class="n">actual_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span>
                                    <span class="n">expected_values</span><span class="o">=</span><span class="n">expected_values</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">barlow_llh</span><span class="p">(</span><span class="n">actual_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span>
                                       <span class="n">expected_values</span><span class="o">=</span><span class="n">expected_values</span><span class="p">))</span></div>


<div class="viewcode-block" id="Map.mod_chi2">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.Map.mod_chi2">[docs]</a>
    <span class="k">def</span> <span class="nf">mod_chi2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expected_values</span><span class="p">,</span> <span class="n">binned</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the total modified chi2 value between this map and the map</span>
<span class="sd">        described by `expected_values`; self is taken to be the &quot;actual values&quot;</span>
<span class="sd">        (or (pseudo)data), and `expected_values` are the expectation values for</span>
<span class="sd">        each bin.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        expected_values : numpy.ndarray or Map of same dimension as this.</span>

<span class="sd">        binned : bool</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        total_mod_chi2 : float or binned_mod_chi2 if binned=True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">expected_values</span> <span class="o">=</span> <span class="n">reduceToHist</span><span class="p">(</span><span class="n">expected_values</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">binned</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">mod_chi2</span><span class="p">(</span><span class="n">actual_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span>
                                  <span class="n">expected_values</span><span class="o">=</span><span class="n">expected_values</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">mod_chi2</span><span class="p">(</span><span class="n">actual_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span>
                                     <span class="n">expected_values</span><span class="o">=</span><span class="n">expected_values</span><span class="p">))</span></div>


<div class="viewcode-block" id="Map.correct_chi2">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.Map.correct_chi2">[docs]</a>
    <span class="k">def</span> <span class="nf">correct_chi2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expected_values</span><span class="p">,</span> <span class="n">binned</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the total correct chi2 value between this map and the map</span>
<span class="sd">        described by `expected_values`; self is taken to be the &quot;actual values&quot;</span>
<span class="sd">        (or (pseudo)data), and `expected_values` are the expectation values for</span>
<span class="sd">        each bin.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        expected_values : numpy.ndarray or Map of same dimension as this.</span>

<span class="sd">        binned : bool</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        total_correct_chi2 : float or binned_correct_chi2 if binned=True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">expected_values</span> <span class="o">=</span> <span class="n">reduceToHist</span><span class="p">(</span><span class="n">expected_values</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">binned</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">correct_chi2</span><span class="p">(</span><span class="n">actual_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span>
                                  <span class="n">expected_values</span><span class="o">=</span><span class="n">expected_values</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">correct_chi2</span><span class="p">(</span><span class="n">actual_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span>
                                     <span class="n">expected_values</span><span class="o">=</span><span class="n">expected_values</span><span class="p">))</span></div>


<div class="viewcode-block" id="Map.chi2">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.Map.chi2">[docs]</a>
    <span class="k">def</span> <span class="nf">chi2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expected_values</span><span class="p">,</span> <span class="n">binned</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the total chi-squared value between this map and the map</span>
<span class="sd">        described by `expected_values`; self is taken to be the &quot;actual values&quot;</span>
<span class="sd">        (or (pseudo)data), and `expected_values` are the expectation values for</span>
<span class="sd">        each bin.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        expected_values : numpy.ndarray or Map of same dimension as this</span>

<span class="sd">        binned : bool</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        total_chi2 : float or binned_chi2 if binned=True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">expected_values</span> <span class="o">=</span> <span class="n">reduceToHist</span><span class="p">(</span><span class="n">expected_values</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">binned</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">chi2</span><span class="p">(</span><span class="n">actual_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span>
                              <span class="n">expected_values</span><span class="o">=</span><span class="n">expected_values</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">chi2</span><span class="p">(</span><span class="n">actual_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span>
                                 <span class="n">expected_values</span><span class="o">=</span><span class="n">expected_values</span><span class="p">))</span></div>


<div class="viewcode-block" id="Map.signed_sqrt_mod_chi2">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.Map.signed_sqrt_mod_chi2">[docs]</a>
    <span class="k">def</span> <span class="nf">signed_sqrt_mod_chi2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expected_values</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the binwise (signed) square-root of the modified chi2 value</span>
<span class="sd">        between this map and the map described by `expected_values`; self is</span>
<span class="sd">        taken to be the &quot;actual values&quot; (or (pseudo)data), and `expected_values`</span>
<span class="sd">        are the expectation values for each bin.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        expected_values : numpy.ndarray or Map of same dimension as this.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        m_pulls : signed_sqrt_mod_chi2</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">expected_values</span> <span class="o">=</span> <span class="n">reduceToHist</span><span class="p">(</span><span class="n">expected_values</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">stats</span><span class="o">.</span><span class="n">signed_sqrt_mod_chi2</span><span class="p">(</span><span class="n">actual_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span>
                                          <span class="n">expected_values</span><span class="o">=</span><span class="n">expected_values</span><span class="p">)</span></div>



<div class="viewcode-block" id="Map.generalized_poisson_llh">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.Map.generalized_poisson_llh">[docs]</a>
    <span class="k">def</span> <span class="nf">generalized_poisson_llh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expected_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">empty_bins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">binned</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;compute the likelihood of this map&#39;s count to originate from</span>

<span class="sd">        Note that unlike the other likelihood functions, expected_values</span>
<span class="sd">        is expected to be a ditribution maker</span>

<span class="sd">        inputs:</span>
<span class="sd">        ------</span>

<span class="sd">            expected_values: OrderedDict of MapSets</span>

<span class="sd">            empty_bins: None, list or np.ndarray (list the bin indices that are empty)</span>

<span class="sd">            binned: bool (return the bin-by-bin llh or the sum over all bins)</span>

<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">llh_per_bin</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">generalized_poisson_llh</span><span class="p">(</span><span class="n">actual_values</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span>
                                                    <span class="n">expected_values</span><span class="o">=</span><span class="n">expected_values</span><span class="p">,</span>
                                                    <span class="n">empty_bins</span><span class="o">=</span><span class="n">empty_bins</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">binned</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">llh_per_bin</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">llh_per_bin</span><span class="p">)</span></div>



<div class="viewcode-block" id="Map.metric_total">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.Map.metric_total">[docs]</a>
    <span class="k">def</span> <span class="nf">metric_total</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expected_values</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">metric_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39; Compute the optimization metric on the bins of a Map</span>

<span class="sd">        Inputs</span>
<span class="sd">        -------</span>

<span class="sd">        expected_values: Map (the data/pseudo-data binned counts)</span>

<span class="sd">        metric: str (name of the optimization metric)</span>

<span class="sd">        metric_kwargs: None or Dict (special arguments to pass to</span>
<span class="sd">                                     a special metric - right now just </span>
<span class="sd">                                     useful for generalized_poisson_llh)</span>

<span class="sd">        Returns:</span>
<span class="sd">        ------</span>
<span class="sd">        float (sum of the metric over all bins of expected_values)</span>

<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># TODO: should this use reduceToHist as in chi2 and llh above?</span>
        <span class="k">if</span> <span class="n">metric_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">metric_kwargs</span><span class="o">=</span><span class="p">{}</span>
        <span class="k">if</span> <span class="n">metric</span> <span class="ow">in</span> <span class="n">stats</span><span class="o">.</span><span class="n">ALL_METRICS</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metric</span><span class="p">)(</span><span class="n">expected_values</span><span class="p">,</span> <span class="o">**</span><span class="n">metric_kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`metric` &quot;</span><span class="si">%s</span><span class="s1">&quot; not recognized; use one of </span><span class="si">%s</span><span class="s1">.&#39;</span>
                             <span class="o">%</span> <span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="n">stats</span><span class="o">.</span><span class="n">ALL_METRICS</span><span class="p">))</span></div>


    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">setitem</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;string : Map&#39;s name&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span>

    <span class="nd">@name</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;map name&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">string_types</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="s1">&#39;_name&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;string : TeX label&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">text2tex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tex</span>

    <span class="nd">@tex</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">tex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">string_types</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">strip_outer_dollars</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="s1">&#39;_tex&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">hash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;int or None : Hash value&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span>

    <span class="nd">@hash</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Hash must be an immutable type (i.e., have a __hash__ method)&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;__hash__&#39;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="s1">&#39;_hash&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">hist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;numpy.ndarray : Histogram array underlying the Map&quot;&quot;&quot;</span>

        <span class="c1"># Get the hist</span>
        <span class="n">hist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hist</span>

        <span class="c1"># Apply bin mask, if one exists</span>
        <span class="c1"># Set masked off elements to NaN (handling both cases where the hst is either a simple array, or has uncertainties)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="p">:</span>
            <span class="n">hist</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">ufloat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hist</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hist</span><span class="o">.</span><span class="n">shape</span><span class="p">)],</span> <span class="n">uncertainties</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span> <span class="c1">#TODO Is there a better way to check if this is a uarray?</span>

        <span class="c1"># Done</span>
        <span class="k">return</span> <span class="n">hist</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nominal_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;numpy.ndarray : Bin values stripped of uncertainties&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">unp</span><span class="o">.</span><span class="n">nominal_values</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">std_devs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;numpy.ndarray : Uncertainties (standard deviations) per bin&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">unp</span><span class="o">.</span><span class="n">std_devs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">binning</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;pisa.core.binning.MultiDimBinning : Map&#39;s binning&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_binning</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">full_comparison</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compare element-by-element instead of just comparing hashes.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_full_comparison</span>

    <span class="nd">@full_comparison</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">full_comparison</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="s1">&#39;_full_comparison&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="c1"># Common mathematical operators</span>

    <span class="nd">@_new_obj</span>
    <span class="k">def</span> <span class="fm">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">state_updates</span> <span class="o">=</span> <span class="p">{</span>
            <span class="c1">#&#39;name&#39;: &quot;|%s|&quot; % (self.name,),</span>
            <span class="c1">#&#39;tex&#39;: r&quot;{\left| %s \right|}&quot; % strip_outer_parens(self.tex),</span>
            <span class="s1">&#39;hist&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">state_updates</span>

    <span class="nd">@_new_obj</span>
    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add `other` to self&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="n">uncertainties</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">:</span>
            <span class="n">state_updates</span> <span class="o">=</span> <span class="p">{</span>
                <span class="c1">#&#39;name&#39;: &quot;(%s + %s)&quot; % (self.name, other),</span>
                <span class="c1">#&#39;tex&#39;: r&quot;{(%s + %s)}&quot; % (self.tex, other),</span>
                <span class="s1">&#39;hist&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">hist</span> <span class="o">+</span> <span class="n">other</span>
            <span class="p">}</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">state_updates</span> <span class="o">=</span> <span class="p">{</span>
                <span class="c1">#&#39;name&#39;: &quot;(%s + array)&quot; % self.name,</span>
                <span class="c1">#&#39;tex&#39;: r&quot;{(%s + X)}&quot; % self.tex,</span>
                <span class="s1">&#39;hist&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">hist</span> <span class="o">+</span> <span class="n">other</span>
            <span class="p">}</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Map</span><span class="p">):</span>
            <span class="n">state_updates</span> <span class="o">=</span> <span class="p">{</span>
                <span class="c1">#&#39;name&#39;: &quot;(%s + %s)&quot; % (self.name, other.name),</span>
                <span class="c1">#&#39;tex&#39;: r&quot;{(%s + %s)}&quot; % (self.tex, other.tex),</span>
                <span class="s1">&#39;hist&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">hist</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span>
                <span class="s1">&#39;full_comparison&#39;</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_comparison</span> <span class="ow">or</span>
                                    <span class="n">other</span><span class="o">.</span><span class="n">full_comparison</span><span class="p">),</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">type_error</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">state_updates</span>

    <span class="c1">#def __cmp__(self, other):</span>

    <span class="nd">@_new_obj</span>
    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="n">uncertainties</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">:</span>
            <span class="n">state_updates</span> <span class="o">=</span> <span class="p">{</span>
                <span class="c1">#&#39;name&#39;: &quot;(%s / %s)&quot; % (self.name, other),</span>
                <span class="c1">#&#39;tex&#39;: r&quot;{(%s / %s)}&quot; % (self.tex, other),</span>
                <span class="s1">&#39;hist&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">hist</span> <span class="o">/</span> <span class="n">other</span>
            <span class="p">}</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">state_updates</span> <span class="o">=</span> <span class="p">{</span>
                <span class="c1">#&#39;name&#39;: &quot;(%s / array)&quot; % self.name,</span>
                <span class="c1">#&#39;tex&#39;: r&quot;{(%s / X)}&quot; % self.tex,</span>
                <span class="s1">&#39;hist&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">hist</span> <span class="o">/</span> <span class="n">other</span>
            <span class="p">}</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Map</span><span class="p">):</span>
            <span class="n">state_updates</span> <span class="o">=</span> <span class="p">{</span>
                <span class="c1">#&#39;name&#39;: &quot;(%s / %s)&quot; % (self.name, other.name),</span>
                <span class="c1">#&#39;tex&#39;: r&quot;{(%s / %s)}&quot; % (self.tex, other.tex),</span>
                <span class="s1">&#39;hist&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">hist</span> <span class="o">/</span> <span class="n">other</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span>
                <span class="s1">&#39;full_comparison&#39;</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_comparison</span> <span class="ow">or</span>
                                    <span class="n">other</span><span class="o">.</span><span class="n">full_comparison</span><span class="p">),</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">type_error</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">state_updates</span>

    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__div__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__floordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;floordiv not implemented for type Map&#39;</span><span class="p">)</span>

    <span class="c1"># TODO: figure out what we actually want to overload &quot;==&quot; with, and how</span>
    <span class="c1"># to implement all the possible kinds of &quot;==&quot; that might be useful for the</span>
    <span class="c1"># user, possibly with different methods altogether</span>
    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if full state of maps are equal. *Not* element-by-element</span>
<span class="sd">        equality as for a numpy array. Call this.hist == other.hist for the</span>
<span class="sd">        element-by-element nominal value and the error.</span>

<span class="sd">        If `full_comparison` is true for either map, or if either map lacks a</span>
<span class="sd">        hash, performs a full comparison of the contents of each map.</span>

<span class="sd">        Otherwise, simply checks that the hashes are equal.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nominal_values</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="n">uncertainties</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Variable</span> \
                <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nominal_values</span>
                           <span class="o">==</span> <span class="n">unp</span><span class="o">.</span><span class="n">nominal_values</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
                    <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">std_devs</span>
                               <span class="o">==</span> <span class="n">unp</span><span class="o">.</span><span class="n">std_devs</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Map</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_comparison</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">full_comparison</span>
                    <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">hash</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">recursiveEquality</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hashable_state</span><span class="p">,</span>
                                         <span class="n">other</span><span class="o">.</span><span class="n">hashable_state</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">hash</span>

        <span class="n">type_error</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

<div class="viewcode-block" id="Map.log">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.Map.log">[docs]</a>
    <span class="nd">@_new_obj</span>
    <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Take natural logarithm of map&#39;s values, returning a new map.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        log_map : Map</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">state_updates</span> <span class="o">=</span> <span class="p">{</span>
            <span class="c1">#&#39;name&#39;: &quot;log(%s)&quot; % self.name,</span>
            <span class="c1">#&#39;tex&#39;: r&quot;\ln\left( %s \right)&quot; % self.tex,</span>
            <span class="s1">&#39;hist&#39;</span><span class="p">:</span> <span class="n">unp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">state_updates</span></div>


<div class="viewcode-block" id="Map.log10">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.Map.log10">[docs]</a>
    <span class="nd">@_new_obj</span>
    <span class="k">def</span> <span class="nf">log10</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Take base-10 logarithm of map&#39;s values, returning a new map.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        log10_map : Map</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">state_updates</span> <span class="o">=</span> <span class="p">{</span>
            <span class="c1">#&#39;name&#39;: &quot;log10(%s)&quot; % self.name,</span>
            <span class="c1">#&#39;tex&#39;: r&quot;\log_{10}\left( %s \right)&quot; % self.tex,</span>
            <span class="s1">&#39;hist&#39;</span><span class="p">:</span> <span class="n">unp</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">state_updates</span></div>


    <span class="nd">@_new_obj</span>
    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="n">uncertainties</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">:</span>
            <span class="n">state_updates</span> <span class="o">=</span> <span class="p">{</span>
                <span class="c1">#&#39;name&#39;: &quot;%s * %s&quot; % (other, self.name),</span>
                <span class="c1">#&#39;tex&#39;: r&quot;%s \cdot %s&quot; % (other, self.tex),</span>
                <span class="s1">&#39;hist&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">hist</span> <span class="o">*</span> <span class="n">other</span>
            <span class="p">}</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">state_updates</span> <span class="o">=</span> <span class="p">{</span>
                <span class="c1">#&#39;name&#39;: &quot;array * %s&quot; % self.name,</span>
                <span class="c1">#&#39;tex&#39;: r&quot;X \cdot %s&quot; % self.tex,</span>
                <span class="s1">&#39;hist&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">hist</span> <span class="o">*</span> <span class="n">other</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Map</span><span class="p">):</span>
            <span class="n">state_updates</span> <span class="o">=</span> <span class="p">{</span>
                <span class="c1">#&#39;name&#39;: &quot;%s * %s&quot; % (self.name, other.name),</span>
                <span class="c1">#&#39;tex&#39;: r&quot;%s \cdot %s&quot; % (self.tex, other.tex),</span>
                <span class="s1">&#39;hist&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">hist</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span>
                <span class="s1">&#39;full_comparison&#39;</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_comparison</span> <span class="ow">or</span>
                                    <span class="n">other</span><span class="o">.</span><span class="n">full_comparison</span><span class="p">),</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">type_error</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">state_updates</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="nd">@_new_obj</span>
    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">state_updates</span> <span class="o">=</span> <span class="p">{</span>
            <span class="c1">#&#39;name&#39;: &quot;-%s&quot; % self.name,</span>
            <span class="c1">#&#39;tex&#39;: r&quot;-%s&quot; % self.tex,</span>
            <span class="s1">&#39;hist&#39;</span><span class="p">:</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">state_updates</span>

    <span class="nd">@_new_obj</span>
    <span class="k">def</span> <span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="n">uncertainties</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">:</span>
            <span class="n">state_updates</span> <span class="o">=</span> <span class="p">{</span>
                <span class="c1">#&#39;name&#39;: &quot;%s**%s&quot; % (self.name, other),</span>
                <span class="c1">#&#39;tex&#39;: &quot;%s^{%s}&quot; % (self.tex, other),</span>
                <span class="s1">&#39;hist&#39;</span><span class="p">:</span> <span class="n">unp</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">state_updates</span> <span class="o">=</span> <span class="p">{</span>
                <span class="c1">#&#39;name&#39;: &quot;%s**(array)&quot; % self.name,</span>
                <span class="c1">#&#39;tex&#39;: r&quot;%s^{X}&quot; % self.tex,</span>
                <span class="s1">&#39;hist&#39;</span><span class="p">:</span> <span class="n">unp</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span> <span class="n">other</span><span class="p">),</span>
            <span class="p">}</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Map</span><span class="p">):</span>
            <span class="n">state_updates</span> <span class="o">=</span> <span class="p">{</span>
                <span class="c1">#&#39;name&#39;: &quot;%s**(%s)&quot; % (self.name,</span>
                <span class="c1">#                      strip_outer_parens(other.name)),</span>
                <span class="c1">#&#39;tex&#39;: r&quot;%s^{%s}&quot; % (self.tex, strip_outer_parens(other.tex)),</span>
                <span class="s1">&#39;hist&#39;</span><span class="p">:</span> <span class="n">unp</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">hist</span><span class="p">),</span>
                <span class="s1">&#39;full_comparison&#39;</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_comparison</span> <span class="ow">or</span>
                                    <span class="n">other</span><span class="o">.</span><span class="n">full_comparison</span><span class="p">),</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">type_error</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">state_updates</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">+</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">__rdiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Map</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other</span> <span class="o">/</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__rdiv</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="nd">@_new_obj</span>
    <span class="k">def</span> <span class="nf">__rdiv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="n">uncertainties</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">:</span>
            <span class="n">state_updates</span> <span class="o">=</span> <span class="p">{</span>
                <span class="c1">#&#39;name&#39;: &quot;(%s / %s)&quot; % (other, self.name),</span>
                <span class="c1">#&#39;tex&#39;: &quot;{(%s / %s)}&quot; % (other, self.tex),</span>
                <span class="s1">&#39;hist&#39;</span><span class="p">:</span> <span class="n">other</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">state_updates</span> <span class="o">=</span> <span class="p">{</span>
                <span class="c1">#&#39;name&#39;: &quot;array / %s&quot; % self.name,</span>
                <span class="c1">#&#39;tex&#39;: &quot;{(X / %s)}&quot; % self.tex,</span>
                <span class="s1">&#39;hist&#39;</span><span class="p">:</span> <span class="n">other</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">type_error</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">state_updates</span>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">*</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Map</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">other</span> <span class="o">-</span> <span class="bp">self</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__rsub</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="nd">@_new_obj</span>
    <span class="k">def</span> <span class="nf">__rsub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="n">uncertainties</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">:</span>
            <span class="n">state_updates</span> <span class="o">=</span> <span class="p">{</span>
                <span class="c1">#&#39;name&#39;: &quot;(%s - %s)&quot; % (other, self.name),</span>
                <span class="c1">#&#39;tex&#39;: &quot;{(%s - %s)}&quot; % (other, self.tex),</span>
                <span class="s1">&#39;hist&#39;</span><span class="p">:</span> <span class="n">other</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">state_updates</span> <span class="o">=</span> <span class="p">{</span>
                <span class="c1">#&#39;name&#39;: &quot;(array - %s)&quot; % self.name,</span>
                <span class="c1">#&#39;tex&#39;: &quot;{(X - %s)}&quot; % self.tex,</span>
                <span class="s1">&#39;hist&#39;</span><span class="p">:</span> <span class="n">other</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">type_error</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">state_updates</span>

<div class="viewcode-block" id="Map.sqrt">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.Map.sqrt">[docs]</a>
    <span class="nd">@_new_obj</span>
    <span class="k">def</span> <span class="nf">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Take square root of map&#39;s values, returning a new map.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sqrt_map : Map</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">state_updates</span> <span class="o">=</span> <span class="p">{</span>
            <span class="c1">#&#39;name&#39;: &quot;sqrt(%s)&quot; % self.name,</span>
            <span class="c1">#&#39;tex&#39;: r&quot;\sqrt{%s}&quot; % self.tex,</span>
            <span class="c1">#&#39;hist&#39;: np.asarray(unp.sqrt(self.hist), dtype=&#39;float&#39;),</span>
            <span class="s1">&#39;hist&#39;</span><span class="p">:</span> <span class="n">unp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hist</span><span class="p">),</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">state_updates</span></div>


    <span class="nd">@_new_obj</span>
    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">is</span> <span class="n">uncertainties</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Variable</span><span class="p">:</span>
            <span class="n">state_updates</span> <span class="o">=</span> <span class="p">{</span>
                <span class="c1">#&#39;name&#39;: &quot;(%s - %s)&quot; % (self.name, other),</span>
                <span class="c1">#&#39;tex&#39;: &quot;{(%s - %s)}&quot; % (self.tex, other),</span>
                <span class="s1">&#39;hist&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">hist</span> <span class="o">-</span> <span class="n">other</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">state_updates</span> <span class="o">=</span> <span class="p">{</span>
                <span class="c1">#&#39;name&#39;: &quot;(%s - array)&quot; % self.name,</span>
                <span class="c1">#&#39;tex&#39;: &quot;{(%s - X)}&quot; % self.tex,</span>
                <span class="s1">&#39;hist&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">hist</span> <span class="o">-</span> <span class="n">other</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Map</span><span class="p">):</span>
            <span class="n">state_updates</span> <span class="o">=</span> <span class="p">{</span>
                <span class="c1">#&#39;name&#39;: &quot;%s - %s&quot; % (self.name, other.name),</span>
                <span class="c1">#&#39;tex&#39;: &quot;{(%s - %s)}&quot; % (self.tex, other.tex),</span>
                <span class="s1">&#39;hist&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">hist</span> <span class="o">-</span> <span class="n">other</span><span class="o">.</span><span class="n">hist</span><span class="p">,</span>
                <span class="s1">&#39;full_comparison&#39;</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">full_comparison</span> <span class="ow">or</span>
                                    <span class="n">other</span><span class="o">.</span><span class="n">full_comparison</span><span class="p">),</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">type_error</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">state_updates</span>

<div class="viewcode-block" id="Map.allclose">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.Map.allclose">[docs]</a>
    <span class="k">def</span> <span class="nf">allclose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Check if this map and another have the same (within machine precision) bin counts&#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assert_compat</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nominal_values</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">nominal_values</span><span class="p">,</span> <span class="o">**</span><span class="n">ALLCLOSE_KW</span><span class="p">)</span></div>
</div>



<span class="c1"># TODO: instantiate individual maps from dicts if passed as such, so user</span>
<span class="c1"># doesn&#39;t have to instantiate each map. Also, check for name collisions with</span>
<span class="c1"># one another and with attrs (so that __getattr__ can retrieve the map by name)</span>

<span class="c1"># TODO: add docstrings</span>

<div class="viewcode-block" id="MapSet">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.MapSet">[docs]</a>
<span class="k">class</span> <span class="nc">MapSet</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ordered set of event rate maps (aka histograms) defined over an arbitrary</span>
<span class="sd">    regluar hyper-rectangular binning.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    maps : Map or sequence of Map</span>

<span class="sd">    name : string</span>

<span class="sd">    tex : string</span>

<span class="sd">    hash : immutable</span>

<span class="sd">    collate_by_name : bool</span>
<span class="sd">        If True, when this MapSet is passed alongside another MapSet to a</span>
<span class="sd">        function that operates on the maps, contained maps in each will be</span>
<span class="sd">        accessed by name. Hence, only maps with the same names will be operated</span>
<span class="sd">        on simultaneously.</span>

<span class="sd">        If false, the contained maps in each MapSet will be accessed by their</span>
<span class="sd">        order in each MapSet. This behavior is useful if maps are renamed</span>
<span class="sd">        through some operation but their order is maintained, and then</span>
<span class="sd">        comparisons are sought with their progenitors with the original</span>
<span class="sd">        (different) name.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__slots</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;_name&#39;</span><span class="p">,</span> <span class="s1">&#39;_hash&#39;</span><span class="p">,</span> <span class="s1">&#39;hash&#39;</span><span class="p">)</span>
    <span class="n">__state_attrs</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;maps&#39;</span><span class="p">,</span> <span class="s1">&#39;tex&#39;</span><span class="p">,</span> <span class="s1">&#39;hash&#39;</span><span class="p">,</span> <span class="s1">&#39;collate_by_name&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maps</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tex</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">hash</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">collate_by_name</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">maps</span><span class="p">,</span> <span class="n">Map</span><span class="p">):</span>
            <span class="n">maps</span> <span class="o">=</span> <span class="p">[</span><span class="n">maps</span><span class="p">]</span>

        <span class="n">maps_</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">maps</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">Map</span><span class="p">):</span>
                <span class="n">maps_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">MapSet</span><span class="p">):</span>
                <span class="n">maps_</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">maps_</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Map</span><span class="p">(</span><span class="o">**</span><span class="n">m</span><span class="p">))</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="s1">&#39;maps&#39;</span><span class="p">,</span> <span class="n">maps_</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="s1">&#39;tex&#39;</span><span class="p">,</span> <span class="n">tex</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span>
            <span class="s1">&#39;collate_by_name&#39;</span><span class="p">,</span> <span class="n">collate_by_name</span>
        <span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="s1">&#39;collate_by_num&#39;</span><span class="p">,</span> <span class="ow">not</span> <span class="n">collate_by_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hash</span> <span class="o">=</span> <span class="nb">hash</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">previous_precision</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">get_printoptions</span><span class="p">()[</span><span class="s1">&#39;precision&#39;</span><span class="p">]</span>
        <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">18</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">argstrs</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">=</span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">serializable_state</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
            <span class="n">r</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">    &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">argstrs</span><span class="p">))</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="n">previous_precision</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">r</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;tex&#39;</span><span class="p">,</span> <span class="s1">&#39;hash&#39;</span><span class="p">,</span> <span class="s1">&#39;maps&#39;</span><span class="p">]</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;tex&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tex</span><span class="p">)</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;hash&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hash</span><span class="p">)</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;maps&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;[</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="s1">&#39; &#39;</span><span class="o">*</span><span class="mi">8</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">    </span><span class="se">\n</span><span class="s1">]&#39;</span>
                         <span class="o">%</span> <span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">        &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]))</span>
        <span class="n">argstrs</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">=</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">state</span><span class="p">[</span><span class="n">a</span><span class="p">]))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">]</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="s1">&#39;,</span><span class="se">\n</span><span class="s1">    &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">argstrs</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">__pretty__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">cycle</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Method used by the `pretty` library for formatting&quot;&quot;&quot;</span>
        <span class="n">myname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">if</span> <span class="n">cycle</span><span class="p">:</span>
            <span class="n">p</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">(...)&#39;</span> <span class="o">%</span> <span class="n">myname</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p</span><span class="o">.</span><span class="n">begin_group</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">(&#39;</span> <span class="o">%</span> <span class="n">myname</span><span class="p">)</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;tex&#39;</span><span class="p">,</span> <span class="s1">&#39;hash&#39;</span><span class="p">,</span> <span class="s1">&#39;maps&#39;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">attrs</span><span class="p">):</span>
                <span class="n">p</span><span class="o">.</span><span class="n">breakable</span><span class="p">()</span>
                <span class="n">p</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">attr</span> <span class="o">+</span> <span class="s1">&#39;=&#39;</span><span class="p">)</span>
                <span class="n">p</span><span class="o">.</span><span class="n">pretty</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">attrs</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
            <span class="n">p</span><span class="o">.</span><span class="n">end_group</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;)&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_repr_pretty_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">cycle</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Method used by e.g. ipython/Jupyter for formatting&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__pretty__</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">cycle</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">serializable_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;OrderedDict : all state needed to reconstruct object&quot;&quot;&quot;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;maps&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">serializable_state</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;tex&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tex</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;collate_by_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collate_by_name</span>
        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">serializable_state</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">state</span><span class="p">)</span>

<div class="viewcode-block" id="MapSet.to_json">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.MapSet.to_json">[docs]</a>
    <span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Serialize the state to a JSON file that can be instantiated as a new</span>
<span class="sd">        object later.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">            Filename; must be either a relative or absolute path (*not</span>
<span class="sd">            interpreted as a PISA resource specification*)</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Further keyword args are sent to `pisa.utils.jsons.to_json()`</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        from_json : Intantiate new object from the file written by this method</span>
<span class="sd">        pisa.utils.jsons.to_json</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">jsons</span><span class="o">.</span><span class="n">to_json</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">serializable_state</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="MapSet.from_json">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.MapSet.from_json">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_json</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">resource</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instantiate a new MapSet object from a JSON file.</span>

<span class="sd">        The format of the JSON is generated by the `MapSet.to_json` method,</span>
<span class="sd">        which converts a MapSet object to basic types and then numpy arrays are</span>
<span class="sd">        converted in a call to `pisa.utils.jsons.to_json`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        resource : str</span>
<span class="sd">            A PISA resource specification (see pisa.utils.resources)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        to_json</span>
<span class="sd">        pisa.utils.jsons.to_json</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">jsons</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">resource</span><span class="p">)</span>
        <span class="c1"># State is a dict for Map, so instantiate with double-asterisk syntax</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">state</span><span class="p">)</span></div>


<div class="viewcode-block" id="MapSet.index">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.MapSet.index">[docs]</a>
    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find map corresponding to `x` and return its index. Accepts either</span>
<span class="sd">        an integer index or a map name to make interface consistent.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : int, string, or Map</span>
<span class="sd">            Map, map name, or integer index of map in this MapSet. If a Map is</span>
<span class="sd">            passed, only its name is matched to the maps in this set.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        integer index to the map</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">l</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">l</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Map</span><span class="p">):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
                <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unhandled type &quot;</span><span class="si">%s</span><span class="s1">&quot; for `x`&#39;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">AssertionError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;A map corresponding to &#39;</span><span class="si">%s</span><span class="s2">&#39; cannot be found in the set.&quot;</span>
                <span class="s2">&quot; Valid maps are </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span></div>


<div class="viewcode-block" id="MapSet.pop">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.MapSet.pop">[docs]</a>
    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span> <span class="c1">#x=None):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove a map and return it. If a value is passed, the map</span>
<span class="sd">        corresponding to `index(value)` is removed and returned instead.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x (optional) : int, string, or Map</span>
<span class="sd">            Map, map name, or integer index of map in this MapSet. If a Map is</span>
<span class="sd">            passed, only its name is matched to the maps in this set.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Map removed from this MapSet</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        list.pop</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maps</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maps</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`pop` takes 0 or 1 argument; </span><span class="si">%d</span><span class="s1"> passed instead.&#39;</span>
                             <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">m</span></div>


    <span class="c1"># TODO: add different aggregation options OR rename to sum_{wildcard|re}</span>
<div class="viewcode-block" id="MapSet.combine_re">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.MapSet.combine_re">[docs]</a>
    <span class="k">def</span> <span class="nf">combine_re</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">regexes</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;For each regex passed, add together contained maps whose names</span>
<span class="sd">        match.</span>

<span class="sd">        If a string or regex is passed, the corresponding maps are combined and</span>
<span class="sd">        returned as a Map object. If an iterable of one or more regexes is</span>
<span class="sd">        passed, each grouping found is combined into a Map separately and the</span>
<span class="sd">        resulting Maps are populated into a new MapSet to be returned.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        regexes : compiled regex, str representing a regex, or iterable thereof</span>
<span class="sd">            See Python module `re` for formatting.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        combined</span>
<span class="sd">            Map if `regexes` is a string or regex; MapSet if `regexes` is an</span>
<span class="sd">            iterable of one or more strings or regexes</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any `regexes` fail to match any map names.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If special characters are used in the regex, like a backslash, be sure</span>
<span class="sd">        to use a Python raw string (which does not interpret such special</span>
<span class="sd">        characters) by prefixing the string with an &quot;r&quot;. E.g., the regex to</span>
<span class="sd">        match a period requires passing</span>
<span class="sd">            `regex=r&#39;\.&#39;`</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Get total of trck and cscd maps, which are named with suffixes &quot;trck&quot;</span>
<span class="sd">        and &quot;cscd&quot;, respectively.</span>

<span class="sd">        &gt;&gt;&gt; total_trck_map = outputs.combine_re(&#39;.*trck&#39;)</span>
<span class="sd">        &gt;&gt;&gt; total_cscd_map = outputs.combine_re(&#39;.*cscd&#39;)</span>

<span class="sd">        Get a MapSet with both of the above maps in it (and a single command)</span>

<span class="sd">        &gt;&gt;&gt; total_pid_maps = outputs.combine_re([&#39;.*trck&#39;, &#39;.*cscd&#39;])</span>

<span class="sd">        Strict name-checking, combine  nue_cc + nuebar_cc, including both</span>
<span class="sd">        cascades and tracks.</span>

<span class="sd">        &gt;&gt;&gt; nue_cc_nuebar_cc_map = outputs.combine_re(</span>
<span class="sd">        ...     &#39;^nue(bar){0,1}_cc_(cscd|trck)$&#39;)</span>

<span class="sd">        Lenient nue_cc + nuebar_cc including both cascades and tracks.</span>

<span class="sd">        &gt;&gt;&gt; nue_cc_nuebar_cc_map = outputs.combine_re(&#39;nue.*_cc_.*&#39;)</span>

<span class="sd">        Total of all maps</span>

<span class="sd">        &gt;&gt;&gt; total = outputs.combine_re(&#39;.*&#39;)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        combine_wildcard</span>
<span class="sd">            Similar method but using wildcards (i.e., globbing, like filename</span>
<span class="sd">            matching in the Unix shell)</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        re : Python module used for parsing regular expressions</span>
<span class="sd">            https://docs.python.org/2/library/re.html</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">is_scalar</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">regexes</span><span class="p">,</span> <span class="n">string_types</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">regexes</span><span class="p">,</span> <span class="s1">&#39;pattern&#39;</span><span class="p">):</span>
            <span class="n">is_scalar</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">regexes</span> <span class="o">=</span> <span class="p">[</span><span class="n">regexes</span><span class="p">]</span>

        <span class="n">resulting_maps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">regex</span> <span class="ow">in</span> <span class="n">regexes</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">regex</span><span class="p">,</span> <span class="s1">&#39;pattern&#39;</span><span class="p">):</span>
                <span class="n">pattern</span> <span class="o">=</span> <span class="n">regex</span><span class="o">.</span><span class="n">pattern</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pattern</span> <span class="o">=</span> <span class="n">regex</span>
            <span class="n">maps_to_combine</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">names_to_combine</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">name</span>
                <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">regex</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Map &quot;</span><span class="si">%s</span><span class="s1">&quot; will be added...&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                    <span class="n">maps_to_combine</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                    <span class="n">names_to_combine</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">maps_to_combine</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No map names match `regex` &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">pattern</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">maps_to_combine</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="n">maps_to_combine</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">nufig</span> <span class="o">=</span> <span class="n">NuFlavIntGroup</span><span class="p">(</span><span class="n">names_to_combine</span><span class="p">)</span>
                    <span class="n">new_name</span> <span class="o">=</span> <span class="n">make_valid_python_name</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">nufig</span><span class="p">))</span>
                    <span class="n">new_tex</span> <span class="o">=</span> <span class="n">nufig</span><span class="o">.</span><span class="n">tex</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="c1"># Reasonable name for giving user an idea of what the map</span>
                    <span class="c1"># represents</span>
                    <span class="n">new_name</span> <span class="o">=</span> <span class="n">make_valid_python_name</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span>
                    <span class="n">new_tex</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">new_name</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                    <span class="n">new_name</span> <span class="o">=</span> <span class="s1">&#39;combined&#39;</span>
                <span class="n">m</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">new_name</span>
                <span class="n">m</span><span class="o">.</span><span class="n">tex</span> <span class="o">=</span> <span class="n">new_tex</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">maps_to_combine</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">resulting_maps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_scalar</span><span class="p">:</span>
            <span class="n">combined</span> <span class="o">=</span> <span class="n">resulting_maps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">combined</span> <span class="o">=</span> <span class="n">MapSet</span><span class="p">(</span><span class="n">maps</span><span class="o">=</span><span class="n">resulting_maps</span><span class="p">,</span>
                              <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                              <span class="n">tex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tex</span><span class="p">,</span>
                              <span class="n">collate_by_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">collate_by_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">combined</span></div>


<div class="viewcode-block" id="MapSet.combine_wildcard">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.MapSet.combine_wildcard">[docs]</a>
    <span class="k">def</span> <span class="nf">combine_wildcard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expressions</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;For each expression passed, add together contained maps whose names</span>
<span class="sd">        match.</span>

<span class="sd">        Expressions can contain wildcards like those used in the Unix shell.</span>

<span class="sd">        Valid wildcards (from fnmatch docs, link below):</span>
<span class="sd">            &quot;*&quot; : matches everything</span>
<span class="sd">            &quot;?&quot; : mateches any single character</span>
<span class="sd">            &quot;[`seq`]&quot; : matches any character in `seq`</span>
<span class="sd">            &quot;[!`seq`]&quot; : matches any character not in `seq`</span>

<span class="sd">        Note that if a string is passed, the matching maps are combined and</span>
<span class="sd">        returned as a Map object. If an iterable of strings is passed, each</span>
<span class="sd">        grouping found is combined into a Map separately and the resulting Maps</span>
<span class="sd">        are populated into a new MapSet to be returned.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        expressions : string or sequence thereof</span>
<span class="sd">            See Python module `fnmatch` for more info.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        combined</span>
<span class="sd">            Map if `expressions` is a string; MapSet if `expressions` is an</span>
<span class="sd">            iterable of one or more strings</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If any `expressions` fail to match any map names.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; total_trck_map = outputs.combine_wildcard(&#39;*trck&#39;)</span>
<span class="sd">        &gt;&gt;&gt; total_cscd_map = outputs.combine_wildcard(&#39;*cscd&#39;)</span>
<span class="sd">        &gt;&gt;&gt; total_pid_maps = outpubs.combine_wildcard([&#39;*trck&#39;, &#39;*cscd&#39;])</span>
<span class="sd">        &gt;&gt;&gt; nue_cc_nuebar_cc_map = outputs.combine_wildcard(&#39;nue*_cc_*&#39;)</span>
<span class="sd">        &gt;&gt;&gt; total = outputs.combine_wildcard(&#39;*&#39;)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        combine_re : similar method but using regular expressions</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        fnmatch : Python module used for parsing the expression with wildcards</span>
<span class="sd">            https://docs.python.org/2/library/fnmatch.html</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">is_scalar</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expressions</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">is_scalar</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">expressions</span> <span class="o">=</span> <span class="p">[</span><span class="n">expressions</span><span class="p">]</span>

        <span class="n">resulting_maps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">expressions</span><span class="p">:</span>
            <span class="n">maps_to_combine</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">names_to_combine</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">mapnum</span><span class="p">,</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">name</span>
                <span class="k">if</span> <span class="n">fnmatch</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Map </span><span class="si">%d</span><span class="s1">, &quot;</span><span class="si">%s</span><span class="s1">&quot;, will be added...&#39;</span><span class="p">,</span>
                                  <span class="n">mapnum</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                    <span class="n">maps_to_combine</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                    <span class="n">names_to_combine</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">maps_to_combine</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No map names match `expr` &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">expr</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">maps_to_combine</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="n">maps_to_combine</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">nufig</span> <span class="o">=</span> <span class="n">NuFlavIntGroup</span><span class="p">(</span><span class="n">names_to_combine</span><span class="p">)</span>
                    <span class="n">new_name</span> <span class="o">=</span> <span class="n">make_valid_python_name</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">nufig</span><span class="p">))</span>
                    <span class="n">new_tex</span> <span class="o">=</span> <span class="n">nufig</span><span class="o">.</span><span class="n">tex</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="c1"># Reasonable name for giving user an idea of what the map</span>
                    <span class="c1"># represents</span>
                    <span class="n">new_name</span> <span class="o">=</span> <span class="n">make_valid_python_name</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
                    <span class="n">new_tex</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">new_name</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                    <span class="n">new_name</span> <span class="o">=</span> <span class="s1">&#39;combined&#39;</span>
                <span class="n">m</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">new_name</span>
                <span class="n">m</span><span class="o">.</span><span class="n">tex</span> <span class="o">=</span> <span class="n">new_tex</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">copy</span><span class="p">(</span><span class="n">maps_to_combine</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">resulting_maps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_scalar</span><span class="p">:</span>
            <span class="n">combined</span> <span class="o">=</span> <span class="n">resulting_maps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">combined</span> <span class="o">=</span> <span class="n">MapSet</span><span class="p">(</span><span class="n">maps</span><span class="o">=</span><span class="n">resulting_maps</span><span class="p">,</span>
                              <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                              <span class="n">tex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tex</span><span class="p">,</span>
                              <span class="n">collate_by_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">collate_by_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">combined</span></div>


<div class="viewcode-block" id="MapSet.compare">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.MapSet.compare">[docs]</a>
    <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compare maps in this MapSet against a reference MapSet.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ref : MapSet</span>
<span class="sd">            Maps taken as the reference against which to compare maps</span>
<span class="sd">            contained within this MapSet.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        stats : OrderedDict</span>
<span class="sd">            Each key is the name of a map, and each value is istelf an</span>
<span class="sd">            OrderedDict as returned by the `Map.compare` method</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; stats = map_set_test.compare(map_set_ref)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">MapSet</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
        <span class="n">rslt</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref</span><span class="p">):</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="n">rslt</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">out</span>
        <span class="k">return</span> <span class="n">rslt</span></div>


    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">recursiveEquality</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hashable_state</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">hashable_state</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">MapSet</span><span class="p">([</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">],</span>
                      <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">tex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tex</span><span class="p">,</span> <span class="nb">hash</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hash</span><span class="p">,</span>
                      <span class="n">collate_by_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">collate_by_num</span><span class="p">)</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;string : name of the map (legal Python name)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="s1">&#39;_name&#39;</span><span class="p">)</span>

    <span class="nd">@name</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;string : name of the map (legal Python name)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="s1">&#39;_name&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">hash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Hash value of the map set is based upon the contained maps.</span>
<span class="sd">            * If all maps have the same hash value, this value is returned as</span>
<span class="sd">              the map set&#39;s hash</span>
<span class="sd">            * If one or more maps have different hash values, a list of the</span>
<span class="sd">              contained maps&#39; hash values is hashed</span>
<span class="sd">            * If any contained map has None for hash value, the hash value of</span>
<span class="sd">              the map set is also None (i.e., invalid)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hashes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hashes</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">([(</span><span class="n">h</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">h</span> <span class="o">==</span> <span class="n">hashes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">hashes</span><span class="p">]):</span>
            <span class="k">return</span> <span class="n">hashes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">([(</span><span class="n">h</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">hashes</span><span class="p">]):</span>
            <span class="k">return</span> <span class="n">hash_obj</span><span class="p">(</span><span class="n">hashes</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@hash</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Setting a hash to `val` for the map set sets the hash values of all</span>
<span class="sd">        contained maps to `val`.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;hash&#39;</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;list of strings : name of each map&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">mp</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">mp</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">hashes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;list of int : hash of each map&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">mp</span><span class="o">.</span><span class="n">hash</span> <span class="k">for</span> <span class="n">mp</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>

<div class="viewcode-block" id="MapSet.hash_maps">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.MapSet.hash_maps">[docs]</a>
    <span class="k">def</span> <span class="nf">hash_maps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">map_names</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate a hash on the contained maps (i.e. exclude state pertaining</span>
<span class="sd">        only to the MapSet itself, but include all state pertaining to the</span>
<span class="sd">        contained Maps).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        map_names : None or sequence of strings</span>
<span class="sd">            If sequence of strings, use these as the map names instead of any</span>
<span class="sd">            names contained.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hash : None or int</span>
<span class="sd">            If any contained map hashes to None, the resulting hash will also</span>
<span class="sd">            be None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">map_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">map_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
        <span class="n">hashes</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">hash</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">map_names</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">([(</span><span class="n">h</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">hashes</span><span class="p">]):</span>
            <span class="k">return</span> <span class="n">hash_obj</span><span class="p">(</span><span class="n">hashes</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="MapSet.collate_with_names">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.MapSet.collate_with_names">[docs]</a>
    <span class="k">def</span> <span class="nf">collate_with_names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vals</span><span class="p">):</span>
        <span class="n">ret_dict</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">,</span> <span class="n">vals</span><span class="p">):</span>
            <span class="n">setitem</span><span class="p">(</span><span class="n">ret_dict</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret_dict</span></div>


<div class="viewcode-block" id="MapSet.find_map">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.MapSet.find_map">[docs]</a>
    <span class="k">def</span> <span class="nf">find_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Map</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Could not find map name &quot;</span><span class="si">%s</span><span class="s1">&quot; among maps </span><span class="si">%s</span><span class="s1">&#39;</span>
                             <span class="o">%</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span></div>


<div class="viewcode-block" id="MapSet.plot">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.MapSet.plot">[docs]</a>
    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">maps</span><span class="p">:</span>
            <span class="n">m</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="MapSet.apply_to_maps">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.MapSet.apply_to_maps">[docs]</a>
    <span class="k">def</span> <span class="nf">apply_to_maps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Keyword arguments are not handled&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">):</span>
            <span class="n">attrname</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">attrname</span> <span class="o">=</span> <span class="n">attr</span>
        <span class="n">do_not_have_attr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">attrname</span><span class="p">))</span>
                                     <span class="k">for</span> <span class="n">mp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">maps</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">do_not_have_attr</span><span class="p">):</span>
            <span class="n">missing_in_names</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)[</span><span class="n">do_not_have_attr</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">num_missing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">do_not_have_attr</span><span class="p">)</span>
            <span class="n">num_total</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">do_not_have_attr</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s1">&#39;Maps </span><span class="si">%s</span><span class="s1"> (</span><span class="si">%d</span><span class="s1"> of </span><span class="si">%d</span><span class="s1"> maps in set) do not have attribute &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">missing_in_names</span><span class="p">,</span> <span class="n">num_missing</span><span class="p">,</span> <span class="n">num_total</span><span class="p">,</span> <span class="n">attrname</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="c1"># Retrieve the corresponding callables from contained maps</span>
        <span class="n">val_per_map</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="k">for</span> <span class="n">mp</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">meth</span><span class="p">,</span> <span class="s1">&#39;__call__&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">meth</span> <span class="ow">in</span> <span class="n">val_per_map</span><span class="p">]):</span>
            <span class="c1"># If all results are maps, populate a new map set &amp; return that</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">Map</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">val_per_map</span><span class="p">]):</span>
                <span class="k">return</span> <span class="n">MapSet</span><span class="p">(</span><span class="n">maps</span><span class="o">=</span><span class="n">val_per_map</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">tex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tex</span><span class="p">,</span>
                              <span class="n">collate_by_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">collate_by_name</span><span class="p">)</span>

            <span class="c1"># Otherwise put in an ordered dict with &lt;name&gt;: &lt;val&gt; pairs ordered</span>
            <span class="c1"># according to the map ordering in this map set</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">collate_with_names</span><span class="p">(</span><span class="n">val_per_map</span><span class="p">)</span>

        <span class="c1"># Rename for clarity</span>
        <span class="n">method_per_map</span> <span class="o">=</span> <span class="n">val_per_map</span>

        <span class="c1"># Create a set of args for *each* map in this map set: If an arg is a</span>
        <span class="c1"># MapSet, convert that arg into the map in that set corresponding to</span>
        <span class="c1"># the same map in this set.</span>
        <span class="n">args_per_map</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">map_num</span><span class="p">,</span> <span class="n">mp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">map_name</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">name</span>
            <span class="n">this_map_args</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="ow">or</span>
                        <span class="nb">type</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="ow">is</span> <span class="n">uncertainties</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Variable</span> <span class="ow">or</span>
                        <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="p">(</span><span class="n">string_types</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))):</span>
                    <span class="n">this_map_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">MapSet</span><span class="p">):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">collate_by_name</span><span class="p">:</span>
                        <span class="n">this_map_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="n">map_name</span><span class="p">])</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">collate_by_num</span><span class="p">:</span>
                        <span class="n">this_map_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="n">map_num</span><span class="p">])</span>

                <span class="c1"># TODO: test to make sure this works for e.g. metric_per_map</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
                    <span class="n">list_arg</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">MapSet</span><span class="p">):</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">collate_by_name</span><span class="p">:</span>
                                <span class="n">list_arg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="n">map_name</span><span class="p">])</span>
                            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">collate_by_num</span><span class="p">:</span>
                                <span class="n">list_arg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="n">map_num</span><span class="p">])</span>
                    <span class="n">this_map_args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">list_arg</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unhandled arg </span><span class="si">%s</span><span class="s1"> / type </span><span class="si">%s</span><span class="s1">&#39;</span>
                                    <span class="o">%</span> <span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">arg</span><span class="p">)))</span>
            <span class="n">args_per_map</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">this_map_args</span><span class="p">)</span>

        <span class="c1"># Make the method calls and collect returned values</span>
        <span class="n">returned_vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">meth</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
                         <span class="k">for</span> <span class="n">meth</span><span class="p">,</span> <span class="n">args</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">method_per_map</span><span class="p">,</span> <span class="n">args_per_map</span><span class="p">)]</span>

        <span class="c1"># If all results are maps, put them into a new map set &amp; return</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">Map</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">returned_vals</span><span class="p">]):</span>
            <span class="k">return</span> <span class="n">MapSet</span><span class="p">(</span><span class="n">maps</span><span class="o">=</span><span class="n">returned_vals</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">tex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tex</span><span class="p">,</span>
                          <span class="n">collate_by_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">collate_by_name</span><span class="p">)</span>

        <span class="c1"># If None returned by all, return a single None</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">([(</span><span class="n">r</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">returned_vals</span><span class="p">]):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Otherwise put into an ordered dict with name: val pairs</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">collate_with_names</span><span class="p">(</span><span class="n">returned_vals</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>

    <span class="c1">#def __setattr__(self, attr, val):</span>
    <span class="c1">#    print(&#39;__setattr__ being accessed, attr = %s, val = %s&#39; %(attr, val))</span>
    <span class="c1">#    if attr in MapSet.__slots:</span>
    <span class="c1">#        print(&#39;attr &quot;%s&quot; found in MapSet.slots.&#39; %attr)</span>
    <span class="c1">#        object.__setattr__(self, attr, val)</span>
    <span class="c1">#    else:</span>
    <span class="c1">#        returned_vals = [setattr(mp, attr, val) for mp in self]</span>
    <span class="c1">#        if all([(r is None) for r in returned_vals]):</span>
    <span class="c1">#            return</span>
    <span class="c1">#        return self.collate_with_names(returned_vals)</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_to_maps</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maps</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maps</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve a map by name or retrieve maps&#39; histogram values by index</span>
<span class="sd">        or slice.</span>

<span class="sd">        If `item` is a string, retrieve map by name.</span>
<span class="sd">        If `item is an integer or one-dim slice, retrieve maps by index/slice</span>
<span class="sd">        If `item` is length-2 tuple or two-dim slice, retrieve value(s) of all</span>
<span class="sd">            contained maps, each indexed by map[`item`]. The output is returned</span>
<span class="sd">            in an ordered dict with format {&lt;map name&gt;: &lt;values&gt;, ...}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_map</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)):</span>
            <span class="n">rslt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maps</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">rslt</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">rslt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">MapSet</span><span class="p">(</span><span class="n">maps</span><span class="o">=</span><span class="n">rslt</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">tex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tex</span><span class="p">,</span>
                              <span class="n">collate_by_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">collate_by_name</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">rslt</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
                <span class="n">item</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">maps</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">MapSet</span><span class="p">(</span><span class="n">maps</span><span class="o">=</span><span class="p">[</span><span class="n">getitem</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">],</span>
                              <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">tex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tex</span><span class="p">,</span>
                              <span class="n">collate_by_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">collate_by_name</span><span class="p">)</span>

            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s1">&#39;too many indices for 2D hist&#39;</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;getitem does not support `item` of type </span><span class="si">%s</span><span class="s1">&#39;</span>
                        <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_to_maps</span><span class="p">(</span><span class="s1">&#39;__abs__&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_to_maps</span><span class="p">(</span><span class="s1">&#39;__add__&#39;</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_to_maps</span><span class="p">(</span><span class="s1">&#39;__truediv__&#39;</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_to_maps</span><span class="p">(</span><span class="s1">&#39;__div__&#39;</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

<div class="viewcode-block" id="MapSet.log">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.MapSet.log">[docs]</a>
    <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_to_maps</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="MapSet.log10">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.MapSet.log10">[docs]</a>
    <span class="k">def</span> <span class="nf">log10</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_to_maps</span><span class="p">(</span><span class="s1">&#39;log10&#39;</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_to_maps</span><span class="p">(</span><span class="s1">&#39;__mul__&#39;</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_to_maps</span><span class="p">(</span><span class="s1">&#39;__neg__&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_to_maps</span><span class="p">(</span><span class="s1">&#39;__pow__&#39;</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_to_maps</span><span class="p">(</span><span class="s1">&#39;__radd__&#39;</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rdiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_to_maps</span><span class="p">(</span><span class="s1">&#39;__rdiv__&#39;</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_to_maps</span><span class="p">(</span><span class="s1">&#39;__rmul__&#39;</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_to_maps</span><span class="p">(</span><span class="s1">&#39;__rsub__&#39;</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

<div class="viewcode-block" id="MapSet.sqrt">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.MapSet.sqrt">[docs]</a>
    <span class="k">def</span> <span class="nf">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_to_maps</span><span class="p">(</span><span class="s1">&#39;sqrt&#39;</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_to_maps</span><span class="p">(</span><span class="s1">&#39;__sub__&#39;</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

<div class="viewcode-block" id="MapSet.sum">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.MapSet.sum">[docs]</a>
    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">MapSet</span><span class="p">(</span><span class="n">maps</span><span class="o">=</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">],</span>
                      <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">tex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tex</span><span class="p">,</span>
                      <span class="n">collate_by_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">collate_by_name</span><span class="p">)</span></div>


<div class="viewcode-block" id="MapSet.project">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.MapSet.project">[docs]</a>
    <span class="k">def</span> <span class="nf">project</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Per-map projections onto single axis. See Map.project for more</span>
<span class="sd">        detailed help.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : string or int</span>
<span class="sd">        keepdims : bool</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        projection : MapSet</span>
<span class="sd">            Each map in this MapSet projected onto `axis`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        sum</span>
<span class="sd">            Sum over specified dimension(s)</span>

<span class="sd">        Map.project</span>
<span class="sd">            Method called for each map in this MapSet to perform the actual</span>
<span class="sd">            projection.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">MapSet</span><span class="p">(</span><span class="n">maps</span><span class="o">=</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">],</span>
                      <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">tex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tex</span><span class="p">,</span>
                      <span class="n">collate_by_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">collate_by_name</span><span class="p">)</span></div>


<div class="viewcode-block" id="MapSet.reorder_dimensions">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.MapSet.reorder_dimensions">[docs]</a>
    <span class="k">def</span> <span class="nf">reorder_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new MapSet object with dimensions ordered</span>
<span class="sd">        according to `order`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        order : MultiDimBinning or sequence of string, int, or OneDimBinning</span>
<span class="sd">            Order of dimensions to use. Strings are interpreted as dimension</span>
<span class="sd">            basenames, integers are interpreted as dimension indices, and</span>
<span class="sd">            OneDimBinning objects are interpreted by their `basename`</span>
<span class="sd">            attributes (so e.g. the exact binnings in `order` do not have to</span>
<span class="sd">            match this object&#39;s exact binnings; only their basenames). Note</span>
<span class="sd">            that a MultiDimBinning object is a valid sequence type to use for</span>
<span class="sd">            `order`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Dimensions specified in `order` that are not in this object are</span>
<span class="sd">        ignored, but dimensions in this object that are missing in `order`</span>
<span class="sd">        result in an error.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MapSet object with reordred dimensions.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError if dimensions present in this object are missing from</span>
<span class="sd">        `order`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">MapSet</span><span class="p">(</span><span class="n">maps</span><span class="o">=</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">reorder_dimensions</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">],</span>
                      <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">tex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tex</span><span class="p">,</span>
                      <span class="n">collate_by_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">collate_by_name</span><span class="p">)</span></div>


<div class="viewcode-block" id="MapSet.squeeze">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.MapSet.squeeze">[docs]</a>
    <span class="k">def</span> <span class="nf">squeeze</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove any singleton dimensions (i.e. that have only a single bin)</span>
<span class="sd">        from all contained maps. Analagous to `numpy.squeeze`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MapSet with equivalent values but singleton Map dimensions removed</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">MapSet</span><span class="p">(</span><span class="n">maps</span><span class="o">=</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                      <span class="n">tex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tex</span><span class="p">,</span> <span class="n">collate_by_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">collate_by_name</span><span class="p">)</span></div>


<div class="viewcode-block" id="MapSet.rebin">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.MapSet.rebin">[docs]</a>
    <span class="k">def</span> <span class="nf">rebin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">MapSet</span><span class="p">(</span><span class="n">maps</span><span class="o">=</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">rebin</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">],</span>
                      <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">tex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tex</span><span class="p">,</span>
                      <span class="n">collate_by_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">collate_by_name</span><span class="p">)</span></div>


<div class="viewcode-block" id="MapSet.downsample">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.MapSet.downsample">[docs]</a>
    <span class="k">def</span> <span class="nf">downsample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">MapSet</span><span class="p">(</span><span class="n">maps</span><span class="o">=</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">downsample</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">],</span>
                      <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">tex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tex</span><span class="p">,</span>
                      <span class="n">collate_by_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">collate_by_name</span><span class="p">)</span></div>


<div class="viewcode-block" id="MapSet.metric_per_map">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.MapSet.metric_per_map">[docs]</a>
    <span class="k">def</span> <span class="nf">metric_per_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expected_values</span><span class="p">,</span> <span class="n">metric</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">metric</span> <span class="o">=</span> <span class="n">metric</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            <span class="k">if</span> <span class="s1">&#39;binned_&#39;</span> <span class="ow">in</span> <span class="n">metric</span><span class="p">:</span>
                <span class="n">metric</span> <span class="o">=</span> <span class="n">metric</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;binned_&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="n">binned</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">binned</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">metric</span> <span class="ow">in</span> <span class="n">stats</span><span class="o">.</span><span class="n">ALL_METRICS</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_to_maps</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="n">expected_values</span><span class="p">,</span> <span class="n">binned</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`metric` &quot;</span><span class="si">%s</span><span class="s1">&quot; not recognized; use one of </span><span class="si">%s</span><span class="s1">.&#39;</span>
                             <span class="o">%</span> <span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="n">stats</span><span class="o">.</span><span class="n">ALL_METRICS</span><span class="p">))</span></div>


<div class="viewcode-block" id="MapSet.metric_total">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.MapSet.metric_total">[docs]</a>
    <span class="k">def</span> <span class="nf">metric_total</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expected_values</span><span class="p">,</span> <span class="n">metric</span><span class="p">,</span> <span class="n">metric_kwargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Compute the binned optimization metric on all maps of a mapset,</span>
<span class="sd">           then sum it up.</span>

<span class="sd">           metric_kwargs allows to pass extra arguments to the metric, like </span>
<span class="sd">                         the number of empty bins for the generalized poisson llh</span>
<span class="sd">                         (Not yet implemented for Mapset) </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metric_per_map</span><span class="p">(</span><span class="n">expected_values</span><span class="p">,</span> <span class="n">metric</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span></div>


<div class="viewcode-block" id="MapSet.chi2_per_map">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.MapSet.chi2_per_map">[docs]</a>
    <span class="k">def</span> <span class="nf">chi2_per_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expected_values</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_to_maps</span><span class="p">(</span><span class="s1">&#39;chi2&#39;</span><span class="p">,</span> <span class="n">expected_values</span><span class="p">)</span></div>


<div class="viewcode-block" id="MapSet.chi2_total">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.MapSet.chi2_total">[docs]</a>
    <span class="k">def</span> <span class="nf">chi2_total</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expected_values</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chi2_per_map</span><span class="p">(</span><span class="n">expected_values</span><span class="p">))</span></div>


<div class="viewcode-block" id="MapSet.fluctuate">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.MapSet.fluctuate">[docs]</a>
    <span class="k">def</span> <span class="nf">fluctuate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">jumpahead</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add fluctuations to the maps in the set and return as a new MapSet.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : None or string</span>
<span class="sd">        random_state : None, numpy.random.RandomState, or seed spec</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">random_state</span> <span class="o">=</span> <span class="n">get_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">,</span>
                                        <span class="n">jumpahead</span><span class="o">=</span><span class="n">jumpahead</span><span class="p">)</span>
        <span class="n">new_maps</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">fluctuate</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">random_state</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">MapSet</span><span class="p">(</span><span class="n">maps</span><span class="o">=</span><span class="n">new_maps</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">tex</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tex</span><span class="p">,</span> <span class="nb">hash</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">collate_by_name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">collate_by_name</span><span class="p">)</span></div>


<div class="viewcode-block" id="MapSet.llh_per_map">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.MapSet.llh_per_map">[docs]</a>
    <span class="k">def</span> <span class="nf">llh_per_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expected_values</span><span class="p">):</span>  
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_to_maps</span><span class="p">(</span><span class="s1">&#39;llh&#39;</span><span class="p">,</span> <span class="n">expected_values</span><span class="p">)</span></div>


<div class="viewcode-block" id="MapSet.llh_total">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.MapSet.llh_total">[docs]</a>
    <span class="k">def</span> <span class="nf">llh_total</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expected_values</span><span class="p">):</span>   
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">llh</span><span class="p">(</span><span class="n">expected_values</span><span class="p">))</span></div>


<div class="viewcode-block" id="MapSet.set_poisson_errors">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.MapSet.set_poisson_errors">[docs]</a>
    <span class="k">def</span> <span class="nf">set_poisson_errors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_to_maps</span><span class="p">(</span><span class="s1">&#39;set_poisson_errors&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="MapSet.allclose">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.MapSet.allclose">[docs]</a>
    <span class="k">def</span> <span class="nf">allclose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Check if this mapset and another have the same (within machine precision) bin counts&#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">apply_to_maps</span><span class="p">(</span><span class="s1">&#39;allclose&#39;</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="p">)</span></div>
</div>


<span class="c1">## Now dynamically add all methods from Map to MapSet that don&#39;t already exist</span>
<span class="c1">## in MapSet (and make these methods distribute to contained maps)</span>
<span class="c1">##for method_name, method in sorted(Map.__dict__.items()):</span>
<span class="c1">#add_methods = &#39;&#39;&#39;__abs__ __add__ __div__ __mul__ __neg__ __pow__ __radd__</span>
<span class="c1">#__rdiv__ __rmul__ __rsub__ __sub__&#39;&#39;&#39;.split()</span>
<span class="c1">#</span>
<span class="c1">#for method_name in add_methods:</span>
<span class="c1">#    #if not hasattr(method, &#39;__call__&#39;) or method_name in MapSet.__dict__:</span>
<span class="c1">#    #    continue</span>
<span class="c1">#    disallowed = (&#39;__getattr__&#39;, &#39;__setattr__&#39;, &#39;__getattribute__&#39;,</span>
<span class="c1">#                  &#39;__getitem__&#39;, &#39;__eq__&#39;, &#39;__ne__&#39;, &#39;__str__&#39;, &#39;__repr__&#39;)</span>
<span class="c1">#    if method_name in disallowed:</span>
<span class="c1">#        continue</span>
<span class="c1">#    print(&#39;adding method &quot;%s&quot; to MapSet as an apply func&#39; % method_name)</span>
<span class="c1">#    arg_str = &#39;, *args&#39; # if len(args) &gt; 0 else &#39;&#39;</span>
<span class="c1">#    eval((&#39;def {method_name}(self{arg_str}):\n&#39;</span>
<span class="c1">#          &#39;    return self.apply_to_maps({method_name}{arg_str})&#39;)</span>
<span class="c1">#          .format(method_name=method_name, arg_str=arg_str))</span>
<span class="c1">#    #f.__doc__ = &#39;Apply method %s to all contained maps&#39; % method_name</span>
<span class="c1">#    #method = getattr(Map, method_name)</span>
<span class="c1">#    #if method.__doc__:</span>
<span class="c1">#    #    f.__doc__ += &#39;... &#39; + method.__doc__</span>
<span class="c1">#    setattr(MapSet, method_name, MethodType(eval(method_name), None, MapSet))</span>


<span class="c1"># TODO: add tests for llh, chi2 methods</span>
<div class="viewcode-block" id="test_Map">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.test_Map">[docs]</a>
<span class="k">def</span> <span class="nf">test_Map</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Unit tests for Map class&quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">pickle</span>
    <span class="n">n_ebins</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">n_czbins</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">n_azbins</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">e_binning</span> <span class="o">=</span> <span class="n">OneDimBinning</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;energy&#39;</span><span class="p">,</span> <span class="n">tex</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;E_\nu&#39;</span><span class="p">,</span> <span class="n">num_bins</span><span class="o">=</span><span class="n">n_ebins</span><span class="p">,</span>
                              <span class="n">domain</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span><span class="o">*</span><span class="n">ureg</span><span class="o">.</span><span class="n">GeV</span><span class="p">,</span> <span class="n">is_log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">cz_binning</span> <span class="o">=</span> <span class="n">OneDimBinning</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;coszen&#39;</span><span class="p">,</span> <span class="n">tex</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;\cos\,\theta&#39;</span><span class="p">,</span>
                               <span class="n">num_bins</span><span class="o">=</span><span class="n">n_czbins</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">is_lin</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">az_binning</span> <span class="o">=</span> <span class="n">OneDimBinning</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;azimuth&#39;</span><span class="p">,</span> <span class="n">tex</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;\phi&#39;</span><span class="p">,</span>
                               <span class="n">num_bins</span><span class="o">=</span><span class="n">n_azbins</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">),</span>
                               <span class="n">is_lin</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># set directly unumpy array with errors</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">e_binning</span> <span class="o">*</span> <span class="n">cz_binning</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">m1</span> <span class="o">=</span> <span class="n">Map</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span>
             <span class="n">hist</span><span class="o">=</span><span class="n">unp</span><span class="o">.</span><span class="n">uarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="p">))),</span>
             <span class="n">binning</span><span class="o">=</span><span class="p">(</span><span class="n">e_binning</span><span class="p">,</span> <span class="n">cz_binning</span><span class="p">))</span>
    <span class="c1"># or call init poisson error afterwards</span>
    <span class="n">m1</span> <span class="o">=</span> <span class="n">Map</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">hist</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_ebins</span><span class="p">,</span> <span class="n">n_czbins</span><span class="p">)),</span> <span class="nb">hash</span><span class="o">=</span><span class="mi">23</span><span class="p">,</span>
             <span class="n">binning</span><span class="o">=</span><span class="p">(</span><span class="n">e_binning</span><span class="p">,</span> <span class="n">cz_binning</span><span class="p">))</span>

    <span class="c1"># Test rebin</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">m1</span><span class="o">.</span><span class="n">rebin</span><span class="p">(</span><span class="n">m1</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">downsample</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
    <span class="n">m_rebinned</span> <span class="o">=</span> <span class="n">m1</span><span class="o">.</span><span class="n">rebin</span><span class="p">(</span><span class="n">m1</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">downsample</span><span class="p">(</span><span class="n">n_ebins</span><span class="p">,</span> <span class="n">n_czbins</span><span class="p">))</span>
    <span class="k">assert</span> <span class="n">m_rebinned</span><span class="o">.</span><span class="n">hist</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">m1</span><span class="o">.</span><span class="n">hist</span><span class="p">)</span>

    <span class="c1"># Test fluctuate</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">m1</span><span class="o">.</span><span class="n">fluctuate</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s2">&quot;poisson&quot;</span><span class="p">)</span>  <span class="c1"># just ensure that None random_state is handled</span>
    <span class="n">m1_seed0</span> <span class="o">=</span> <span class="n">m1</span><span class="o">.</span><span class="n">fluctuate</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s2">&quot;poisson&quot;</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">m1_seed1</span> <span class="o">=</span> <span class="n">m1</span><span class="o">.</span><span class="n">fluctuate</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s2">&quot;poisson&quot;</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">m1_seed0_reprod</span> <span class="o">=</span> <span class="n">m1</span><span class="o">.</span><span class="n">fluctuate</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s2">&quot;poisson&quot;</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="p">[</span><span class="n">m1_seed0</span><span class="p">,</span> <span class="n">m1_seed1</span><span class="p">,</span> <span class="n">m1_seed0_reprod</span><span class="p">]:</span>
        <span class="c1"># The full comparison has to be ON for all maps, otherwise we would only</span>
        <span class="c1"># compare the hash value, which doesn&#39;t change when maps are fluctuated.</span>
        <span class="c1"># Because the value of full_comparison is included in the comparison, two </span>
        <span class="c1"># maps will not be considered equal if only one of them has</span>
        <span class="c1"># `full_comparison=True`.</span>
        <span class="c1"># TODO: How does this make sense?</span>
        <span class="n">m</span><span class="o">.</span><span class="n">full_comparison</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Fluctuated map with seed 0:&quot;</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">m1_seed0</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Fluctuated map with seed 1:&quot;</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">m1_seed1</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Fluctuated map with seed 0, reproduced:&quot;</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">m1_seed0_reprod</span><span class="p">)</span>
    
    <span class="k">assert</span> <span class="n">m1_seed0</span> <span class="o">==</span> <span class="n">m1_seed0_reprod</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="n">m1_seed0</span> <span class="o">==</span> <span class="n">m1_seed1</span><span class="p">)</span>
    
    <span class="c1"># Test sum()</span>
    <span class="n">m1</span> <span class="o">=</span> <span class="n">Map</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span>
        <span class="n">hist</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_ebins</span><span class="o">*</span><span class="n">n_czbins</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">n_ebins</span><span class="p">,</span> <span class="n">n_czbins</span><span class="p">)),</span>
        <span class="n">binning</span><span class="o">=</span><span class="p">(</span><span class="n">e_binning</span><span class="p">,</span> <span class="n">cz_binning</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">s1</span> <span class="o">=</span> <span class="n">m1</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">s1</span><span class="o">.</span><span class="n">hist</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">225</span><span class="p">,</span> <span class="mi">235</span><span class="p">,</span> <span class="mi">245</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">265</span><span class="p">]]))</span>
    <span class="k">assert</span> <span class="n">s1</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="k">assert</span> <span class="s1">&#39;energy&#39;</span> <span class="ow">in</span> <span class="n">s1</span><span class="o">.</span><span class="n">binning</span>
    <span class="k">assert</span> <span class="s1">&#39;coszen&#39;</span> <span class="ow">in</span> <span class="n">s1</span><span class="o">.</span><span class="n">binning</span>
    <span class="n">s2</span> <span class="o">=</span> <span class="n">m1</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="s1">&#39;energy&#39;</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">s2</span><span class="o">.</span><span class="n">hist</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">225</span><span class="p">,</span> <span class="mi">235</span><span class="p">,</span> <span class="mi">245</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">265</span><span class="p">]))</span>
    <span class="k">assert</span> <span class="n">s2</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">5</span><span class="p">,)</span>
    <span class="k">assert</span> <span class="s1">&#39;energy&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">s2</span><span class="o">.</span><span class="n">binning</span>
    <span class="k">assert</span> <span class="s1">&#39;coszen&#39;</span> <span class="ow">in</span> <span class="n">s2</span><span class="o">.</span><span class="n">binning</span>

    <span class="n">m1</span> <span class="o">=</span> <span class="n">Map</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">hist</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_ebins</span><span class="p">,</span> <span class="n">n_czbins</span><span class="p">)),</span> <span class="nb">hash</span><span class="o">=</span><span class="mi">23</span><span class="p">,</span>
             <span class="n">binning</span><span class="o">=</span><span class="p">(</span><span class="n">e_binning</span><span class="p">,</span> <span class="n">cz_binning</span><span class="p">))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="s2">&quot;downsampling =====================&quot;</span><span class="p">)))</span>
    <span class="n">m2</span> <span class="o">=</span> <span class="n">m1</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="n">m2</span><span class="o">.</span><span class="n">downsample</span><span class="p">(</span><span class="mi">1</span><span class="p">))))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="n">m2</span><span class="o">.</span><span class="n">downsample</span><span class="p">(</span><span class="mi">5</span><span class="p">))))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="n">m2</span><span class="o">.</span><span class="n">downsample</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="n">m2</span><span class="o">.</span><span class="n">downsample</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">))))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="n">m2</span><span class="o">.</span><span class="n">downsample</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="n">m2</span><span class="o">.</span><span class="n">downsample</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">))))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="n">m2</span><span class="o">.</span><span class="n">downsample</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">binning</span><span class="p">)))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="s2">&quot;===================== downsampling&quot;</span><span class="p">)))</span>

    <span class="k">assert</span> <span class="n">m1</span><span class="o">.</span><span class="n">hash</span> <span class="o">==</span> <span class="mi">23</span>
    <span class="n">m1</span><span class="o">.</span><span class="n">hash</span> <span class="o">=</span> <span class="mi">42</span>
    <span class="k">assert</span> <span class="n">m1</span><span class="o">.</span><span class="n">hash</span> <span class="o">==</span> <span class="mi">42</span>
    <span class="n">m1</span><span class="o">.</span><span class="n">set_poisson_errors</span><span class="p">()</span>
    <span class="c1"># or no errors at all</span>
    <span class="n">m2</span> <span class="o">=</span> <span class="n">Map</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">hist</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_ebins</span><span class="p">,</span> <span class="n">n_czbins</span><span class="p">)),</span>
             <span class="n">binning</span><span class="o">=</span><span class="p">(</span><span class="n">e_binning</span><span class="p">,</span> <span class="n">cz_binning</span><span class="p">))</span>
    <span class="n">m3</span> <span class="o">=</span> <span class="n">Map</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="n">hist</span><span class="o">=</span><span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_ebins</span><span class="p">,</span> <span class="n">n_czbins</span><span class="p">,</span> <span class="n">n_azbins</span><span class="p">)),</span>
             <span class="n">binning</span><span class="o">=</span><span class="p">(</span><span class="n">e_binning</span><span class="p">,</span> <span class="n">cz_binning</span><span class="p">,</span> <span class="n">az_binning</span><span class="p">))</span>

    <span class="k">assert</span> <span class="n">m3</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;m3[0, 0, 0] = </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">m3</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">testdir</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkdtemp</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="p">[</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">,</span> <span class="n">m1</span><span class="o">+</span><span class="n">m2</span><span class="p">,</span> <span class="n">m1</span><span class="o">-</span><span class="n">m2</span><span class="p">,</span> <span class="n">m1</span><span class="o">/</span><span class="n">m2</span><span class="p">,</span> <span class="n">m1</span><span class="o">*</span><span class="n">m2</span><span class="p">]:</span>
            <span class="n">m_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">testdir</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;.json&#39;</span><span class="p">)</span>
            <span class="n">m</span><span class="o">.</span><span class="n">to_json</span><span class="p">(</span><span class="n">m_file</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">m_</span> <span class="o">=</span> <span class="n">Map</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">m_file</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">m_</span> <span class="o">==</span> <span class="n">m</span><span class="p">,</span> <span class="s1">&#39;m=</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="s1">m_=</span><span class="se">\n</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">m_</span><span class="p">)</span>
            <span class="n">jsons</span><span class="o">.</span><span class="n">to_json</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">m_file</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">m_</span> <span class="o">=</span> <span class="n">Map</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">m_file</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">m_</span> <span class="o">==</span> <span class="n">m</span><span class="p">,</span> <span class="s1">&#39;m=</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="s1">m_=</span><span class="se">\n</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">m_</span><span class="p">)</span>
            <span class="c1"># Had bug where datastruct containing MapSet failed to be saved.</span>
            <span class="c1"># Test tuple containing list containing OrderedDict containing</span>
            <span class="c1"># Map here.</span>
            <span class="n">struct</span> <span class="o">=</span> <span class="p">([</span><span class="n">OrderedDict</span><span class="p">(</span><span class="nb">map</span><span class="o">=</span><span class="n">m</span><span class="p">)],)</span>
            <span class="n">jsons</span><span class="o">.</span><span class="n">to_json</span><span class="p">(</span><span class="n">struct</span><span class="p">,</span> <span class="n">m_file</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">loaded</span> <span class="o">=</span> <span class="n">jsons</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">m_file</span><span class="p">)</span>
            <span class="n">m_</span> <span class="o">=</span> <span class="n">Map</span><span class="p">(</span><span class="o">**</span><span class="n">loaded</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;map&#39;</span><span class="p">])</span>
            <span class="k">assert</span> <span class="n">m_</span> <span class="o">==</span> <span class="n">m</span>
            <span class="c1"># Now try with pickle</span>
            <span class="n">m_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">testdir</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;.pkl&#39;</span><span class="p">)</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">struct</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">m_file</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">),</span>
                        <span class="n">protocol</span><span class="o">=</span><span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span>
            <span class="n">loaded</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">m_file</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">))</span>
            <span class="n">m_</span> <span class="o">=</span> <span class="n">loaded</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;map&#39;</span><span class="p">]</span>
            <span class="k">assert</span> <span class="n">m_</span> <span class="o">==</span> <span class="n">m</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">testdir</span><span class="p">,</span> <span class="n">ignore_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="n">m1</span><span class="p">,</span> <span class="n">m1</span><span class="o">.</span><span class="n">binning</span><span class="p">)))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="n">m2</span><span class="p">,</span> <span class="n">m2</span><span class="o">.</span><span class="n">binning</span><span class="p">)))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="n">m1</span><span class="o">.</span><span class="n">nominal_values</span><span class="p">)))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="n">m1</span><span class="o">.</span><span class="n">std_devs</span><span class="p">)))</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">m1</span> <span class="o">+</span> <span class="n">m2</span>
    <span class="c1"># compare only nominal val</span>
    <span class="k">assert</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">3</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="n">r</span><span class="p">)))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="s1">&#39;m1+m2=3:&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])))</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">m2</span> <span class="o">+</span> <span class="n">m1</span>
    <span class="c1"># or compare including errors</span>
    <span class="k">assert</span> <span class="n">r</span> <span class="o">==</span> <span class="n">ufloat</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="s1">&#39;m2+m1=3:&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])))</span>
    <span class="n">r</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">m1</span>
    <span class="k">assert</span> <span class="n">r</span> <span class="o">==</span> <span class="n">ufloat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">hist</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="s1">&#39;2*m1=2:&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])))</span>
    <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">m1</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)</span> <span class="o">/</span> <span class="n">m2</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="s1">&#39;(2*(1+/-1) + 8) / 2:&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])))</span>
    <span class="k">assert</span> <span class="n">r</span> <span class="o">==</span> <span class="n">ufloat</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">hist</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="s1">&#39;(2*m1 + 8) / m2=5:&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">r</span><span class="o">.</span><span class="n">hist</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])))</span>
    <span class="c1">#r[:, 1] = 1</span>
    <span class="c1">#r[2, :] = 2</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="s1">&#39;r[0:2, 0:5].hist:&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">hist</span><span class="p">)))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="s1">&#39;r[0:2, 0:5].binning:&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span><span class="o">.</span><span class="n">binning</span><span class="p">)))</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">m1</span> <span class="o">/</span> <span class="n">m2</span>
    <span class="k">assert</span> <span class="n">r</span> <span class="o">==</span> <span class="n">ufloat</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">(([</span><span class="n">b</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">energy</span><span class="o">.</span><span class="n">midpoints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">m1</span><span class="o">.</span><span class="n">iterbins</span><span class="p">()][</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])))</span>

    <span class="c1"># Test reorder_dimensions</span>
    <span class="n">e_binning</span> <span class="o">=</span> <span class="n">OneDimBinning</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;energy&#39;</span><span class="p">,</span> <span class="n">num_bins</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">is_log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">80</span><span class="p">]</span><span class="o">*</span><span class="n">ureg</span><span class="o">.</span><span class="n">GeV</span>
    <span class="p">)</span>
    <span class="n">cz_binning</span> <span class="o">=</span> <span class="n">OneDimBinning</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;coszen&#39;</span><span class="p">,</span> <span class="n">num_bins</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">is_lin</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">az_binning</span> <span class="o">=</span> <span class="n">OneDimBinning</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;azimuth&#39;</span><span class="p">,</span> <span class="n">num_bins</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">is_lin</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">domain</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">]</span><span class="o">*</span><span class="n">ureg</span><span class="o">.</span><span class="n">rad</span>
    <span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">e_binning</span><span class="p">)):</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cz_binning</span><span class="p">)):</span>
            <span class="n">c</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">az_binning</span><span class="p">)):</span>
                <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">100</span> <span class="o">+</span> <span class="n">j</span><span class="o">*</span><span class="mi">10</span> <span class="o">+</span> <span class="n">k</span><span class="p">)</span>
            <span class="n">b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">a</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">m_orig</span> <span class="o">=</span> <span class="n">Map</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;orig&#39;</span><span class="p">,</span> <span class="n">hist</span><span class="o">=</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">a</span><span class="p">),</span>
                 <span class="n">binning</span><span class="o">=</span><span class="p">[</span><span class="n">e_binning</span><span class="p">,</span> <span class="n">cz_binning</span><span class="p">,</span> <span class="n">az_binning</span><span class="p">])</span>
    <span class="n">m_new</span> <span class="o">=</span> <span class="n">m_orig</span><span class="o">.</span><span class="n">reorder_dimensions</span><span class="p">([</span><span class="s1">&#39;azimuth&#39;</span><span class="p">,</span> <span class="s1">&#39;energy&#39;</span><span class="p">,</span> <span class="s1">&#39;coszen&#39;</span><span class="p">])</span>

    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">alltrue</span><span class="p">(</span><span class="n">m_orig</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">hist</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">==</span>
                      <span class="n">m_new</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">hist</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">alltrue</span><span class="p">(</span><span class="n">m_orig</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">hist</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">==</span>
                      <span class="n">m_new</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">hist</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">alltrue</span><span class="p">(</span><span class="n">m_orig</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">hist</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">==</span>
                      <span class="n">m_new</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">hist</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>

    <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">m_orig</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">m_orig</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">binning</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">==</span> <span class="n">m_new</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">binning</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">m_orig</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">binning</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">==</span> <span class="n">m_new</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">binning</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">m_orig</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">binning</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">==</span> <span class="n">m_new</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">binning</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span>

    <span class="n">deepcopy</span><span class="p">(</span><span class="n">m_orig</span><span class="p">)</span>

    <span class="c1">#FIXME: Add unit test for plot function:</span>
        <span class="c1"># - test 3D *and* 2D case</span>
        <span class="c1"># - test saving option works</span>
        <span class="c1"># - test return types</span>

        <span class="c1"># start implementing some</span>
        <span class="c1"># test_return = xx.plot()</span>
        <span class="c1"># assert test_return[0] == matplotlib.figure.Figure</span>
        <span class="c1"># assert test_return[1] == matplotlib.axes._subplots.AxesSubplot</span>
        <span class="c1"># assert test_return[2] == matplotlib.collections.QuadMesh</span>
        <span class="c1"># assert test_return[3] == matplotlib.colorbar.Colorbar</span>

    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="s1">&#39;&lt;&lt; PASS : test_Map &gt;&gt;&#39;</span><span class="p">)))</span></div>



<span class="c1"># TODO: add tests for llh, chi2 methods</span>
<span class="c1"># TODO: make tests use assert rather than rely on logging.debug(str((!)))</span>
<div class="viewcode-block" id="test_MapSet">
<a class="viewcode-back" href="../../../pisa.core.html#pisa.core.map.test_MapSet">[docs]</a>
<span class="k">def</span> <span class="nf">test_MapSet</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Unit tests for MapSet class&quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">pickle</span>
    <span class="n">n_ebins</span> <span class="o">=</span> <span class="mi">6</span>
    <span class="n">n_czbins</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">e_binning</span> <span class="o">=</span> <span class="n">OneDimBinning</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;energy&#39;</span><span class="p">,</span> <span class="n">tex</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;E_\nu&#39;</span><span class="p">,</span> <span class="n">num_bins</span><span class="o">=</span><span class="n">n_ebins</span><span class="p">,</span>
                              <span class="n">domain</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span><span class="o">*</span><span class="n">ureg</span><span class="o">.</span><span class="n">GeV</span><span class="p">,</span> <span class="n">is_log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">cz_binning</span> <span class="o">=</span> <span class="n">OneDimBinning</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;coszen&#39;</span><span class="p">,</span> <span class="n">tex</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;\cos\,\theta&#39;</span><span class="p">,</span>
                               <span class="n">num_bins</span><span class="o">=</span><span class="n">n_czbins</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">is_lin</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">binning</span> <span class="o">=</span> <span class="n">MultiDimBinning</span><span class="p">([</span><span class="n">e_binning</span><span class="p">,</span> <span class="n">cz_binning</span><span class="p">])</span>
    <span class="n">m1</span> <span class="o">=</span> <span class="n">Map</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;ones&#39;</span><span class="p">,</span> <span class="n">hist</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">binning</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">binning</span><span class="o">=</span><span class="n">binning</span><span class="p">,</span>
             <span class="nb">hash</span><span class="o">=</span><span class="s1">&#39;xyz&#39;</span><span class="p">)</span>
    <span class="n">m1</span><span class="o">.</span><span class="n">set_poisson_errors</span><span class="p">()</span>
    <span class="n">m2</span> <span class="o">=</span> <span class="n">Map</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;twos&#39;</span><span class="p">,</span> <span class="n">hist</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">binning</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">binning</span><span class="o">=</span><span class="n">binning</span><span class="p">,</span>
             <span class="nb">hash</span><span class="o">=</span><span class="s1">&#39;xyz&#39;</span><span class="p">)</span>
    <span class="n">ms01</span> <span class="o">=</span> <span class="n">MapSet</span><span class="p">([</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">])</span>
    
    <span class="c1"># Test fluctuate</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ms01</span><span class="o">.</span><span class="n">fluctuate</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s2">&quot;poisson&quot;</span><span class="p">)</span>  <span class="c1"># just ensure that None random_state is handled</span>
    <span class="n">ms01_seed0</span> <span class="o">=</span> <span class="n">ms01</span><span class="o">.</span><span class="n">fluctuate</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s2">&quot;poisson&quot;</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">ms01_seed1</span> <span class="o">=</span> <span class="n">ms01</span><span class="o">.</span><span class="n">fluctuate</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s2">&quot;poisson&quot;</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ms01_seed0_reprod</span> <span class="o">=</span> <span class="n">ms01</span><span class="o">.</span><span class="n">fluctuate</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s2">&quot;poisson&quot;</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Fluctuated map set with seed 0:&quot;</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">ms01_seed0</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Fluctuated map set with seed 1:&quot;</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">ms01_seed1</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Fluctuated map set with seed 0, reproduced:&quot;</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">ms01_seed0_reprod</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">ms01_seed0</span> <span class="o">==</span> <span class="n">ms01_seed0_reprod</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="n">ms01_seed0</span> <span class="o">==</span> <span class="n">ms01_seed1</span><span class="p">)</span>
    
    <span class="c1"># Test rebin</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">ms01</span><span class="o">.</span><span class="n">rebin</span><span class="p">(</span><span class="n">m1</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">downsample</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">ms01_rebinned</span> <span class="o">=</span> <span class="n">ms01</span><span class="o">.</span><span class="n">rebin</span><span class="p">(</span><span class="n">m1</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">downsample</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">m_orig</span><span class="p">,</span> <span class="n">m_rebinned</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ms01</span><span class="p">,</span> <span class="n">ms01_rebinned</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">m_rebinned</span><span class="o">.</span><span class="n">hist</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">m_orig</span><span class="o">.</span><span class="n">hist</span><span class="p">)</span>

    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="s2">&quot;downsampling =====================&quot;</span><span class="p">)))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="n">ms01</span><span class="o">.</span><span class="n">downsample</span><span class="p">(</span><span class="mi">3</span><span class="p">))))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="s2">&quot;===================== downsampling&quot;</span><span class="p">)))</span>
    <span class="n">ms01</span> <span class="o">=</span> <span class="n">MapSet</span><span class="p">((</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;ms01&#39;</span><span class="p">)</span>
    <span class="n">ms02</span> <span class="o">=</span> <span class="n">MapSet</span><span class="p">((</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;map set 1&#39;</span><span class="p">)</span>
    <span class="n">ms1</span> <span class="o">=</span> <span class="n">MapSet</span><span class="p">(</span><span class="n">maps</span><span class="o">=</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;map set 1&#39;</span><span class="p">,</span> <span class="n">collate_by_name</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="nb">hash</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">ms1</span><span class="o">.</span><span class="n">combine_re</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;.*&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">hist</span> <span class="o">==</span> <span class="n">ms1</span><span class="o">.</span><span class="n">combine_wildcard</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">hist</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">ms1</span><span class="o">.</span><span class="n">combine_re</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;.*&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">hist</span> <span class="o">==</span> <span class="p">(</span><span class="n">ms1</span><span class="o">.</span><span class="n">ones</span> <span class="o">+</span> <span class="n">ms1</span><span class="o">.</span><span class="n">twos</span><span class="p">)</span><span class="o">.</span><span class="n">hist</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">ms1</span><span class="o">.</span><span class="n">combine_re</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^(one|two)s.*$&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">hist</span> <span class="o">==</span>
                  <span class="n">ms1</span><span class="o">.</span><span class="n">combine_wildcard</span><span class="p">(</span><span class="s1">&#39;*s&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">hist</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">ms1</span><span class="o">.</span><span class="n">combine_re</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^(one|two)s.*$&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">hist</span> <span class="o">==</span> <span class="p">(</span><span class="n">ms1</span><span class="o">.</span><span class="n">ones</span> <span class="o">+</span>
                                                             <span class="n">ms1</span><span class="o">.</span><span class="n">twos</span><span class="p">)</span><span class="o">.</span><span class="n">hist</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="n">ms1</span><span class="o">.</span><span class="n">combine_re</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^o&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">hist</span><span class="p">)))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="n">ms1</span><span class="o">.</span><span class="n">combine_wildcard</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;o*&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">hist</span><span class="p">)))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="n">ms1</span><span class="o">.</span><span class="n">combine_re</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^o&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">hist</span>
                       <span class="o">-</span> <span class="n">ms1</span><span class="o">.</span><span class="n">combine_wildcard</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;o*&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">hist</span><span class="p">)))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="s1">&#39;map sets equal after combining?&#39;</span><span class="p">,</span>
                       <span class="n">ms1</span><span class="o">.</span><span class="n">combine_re</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^o&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">ms1</span><span class="o">.</span><span class="n">combine_wildcard</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;o*&#39;</span><span class="p">))))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="s1">&#39;hist equal after combining?&#39;</span><span class="p">,</span>
                       <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">ms1</span><span class="o">.</span><span class="n">combine_re</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^o&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">hist</span> <span class="o">==</span>
                              <span class="n">ms1</span><span class="o">.</span><span class="n">combine_wildcard</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;o*&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">hist</span><span class="p">))))</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">ms1</span><span class="o">.</span><span class="n">combine_re</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^o.*&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">nominal_values</span>
                  <span class="o">==</span> <span class="n">ms1</span><span class="o">.</span><span class="n">combine_wildcard</span><span class="p">(</span><span class="s1">&#39;o*&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">nominal_values</span><span class="p">),</span> \
            <span class="s1">&#39;</span><span class="si">%s</span><span class="se">\n</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ms1</span><span class="o">.</span><span class="n">combine_re</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^o.*&#39;</span><span class="p">),</span> <span class="n">ms1</span><span class="o">.</span><span class="n">combine_wildcard</span><span class="p">(</span><span class="s1">&#39;o*&#39;</span><span class="p">))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="s1">&#39;5&#39;</span><span class="p">,</span> <span class="n">ms1</span><span class="o">.</span><span class="n">names</span><span class="p">)))</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">ms1</span><span class="o">.</span><span class="n">combine_re</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^o&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">nominal_values</span> <span class="o">==</span> <span class="n">ms1</span><span class="o">.</span><span class="n">ones</span><span class="o">.</span><span class="n">nominal_values</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">ms1</span><span class="o">.</span><span class="n">combine_wildcard</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;o*&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">nominal_values</span> <span class="o">==</span> <span class="n">ms1</span><span class="o">.</span><span class="n">ones</span><span class="o">.</span><span class="n">nominal_values</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="s1">&#39;6&#39;</span><span class="p">,</span> <span class="n">ms1</span><span class="o">.</span><span class="n">names</span><span class="p">)))</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">ms1</span><span class="o">.</span><span class="n">combine_re</span><span class="p">(</span><span class="s1">&#39;three&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="kc">False</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">ms1</span><span class="o">.</span><span class="n">combine_wildcard</span><span class="p">(</span><span class="s1">&#39;three&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="kc">False</span>

    <span class="k">assert</span> <span class="n">ms1</span><span class="o">.</span><span class="n">hash</span> <span class="o">==</span> <span class="s1">&#39;xyz&#39;</span>
    <span class="k">assert</span> <span class="n">ms1</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;map set 1&#39;</span>
    <span class="n">ms1</span><span class="o">.</span><span class="n">hash</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="k">assert</span> <span class="n">ms1</span><span class="o">.</span><span class="n">hash</span> <span class="o">==</span> <span class="mi">10</span>
    <span class="k">assert</span> <span class="n">m1</span><span class="o">.</span><span class="n">hash</span> <span class="o">==</span> <span class="mi">10</span>
    <span class="k">assert</span> <span class="n">m2</span><span class="o">.</span><span class="n">hash</span> <span class="o">==</span> <span class="mi">10</span>
    <span class="n">ms1</span><span class="o">.</span><span class="n">hash</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10</span>
    <span class="k">assert</span> <span class="n">ms1</span><span class="o">.</span><span class="n">hash</span> <span class="o">==</span> <span class="o">-</span><span class="mi">10</span>
    <span class="c1"># &quot;Remove&quot; the hash from the MapSet...</span>
    <span class="n">ms1</span><span class="o">.</span><span class="n">hash</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># ... but this should not remove hashes from the contained maps</span>
    <span class="k">assert</span> <span class="n">m1</span><span class="o">.</span><span class="n">hash</span> <span class="o">==</span> <span class="o">-</span><span class="mi">10</span>
    <span class="c1"># ... and hashing on the MapSet should see that all contained maps have the</span>
    <span class="c1"># SAME hash val, and so should just return the hash value shared among them</span>
    <span class="c1"># all</span>
    <span class="k">assert</span> <span class="n">ms1</span><span class="o">.</span><span class="n">hash</span> <span class="o">==</span> <span class="o">-</span><span class="mi">10</span>
    <span class="c1"># However changing a single map&#39;s hash means not all hashes are the same</span>
    <span class="c1"># for all maps...</span>
    <span class="n">m1</span><span class="o">.</span><span class="n">hash</span> <span class="o">=</span> <span class="mi">40</span>
    <span class="c1"># ... so a hash should be computed from all contained hashes</span>
    <span class="k">assert</span> <span class="n">ms1</span><span class="o">.</span><span class="n">hash</span> <span class="o">!=</span> <span class="mi">40</span> <span class="ow">and</span> <span class="n">ms1</span><span class="o">.</span><span class="n">hash</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">10</span>

    <span class="k">assert</span> <span class="n">ms1</span><span class="o">.</span><span class="n">maps</span> <span class="o">==</span> <span class="p">[</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">ms1</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;ones&#39;</span><span class="p">,</span> <span class="s1">&#39;twos&#39;</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">ms1</span><span class="o">.</span><span class="n">tex</span> <span class="ow">is</span> <span class="kc">None</span>
    <span class="c1"># Check the Poisson errors</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">ms1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">nominal_values</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">binning</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">ms1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">std_devs</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">binning</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">ms1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">hist</span> <span class="o">==</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">binning</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="s1">&#39;ms1[0:2].hist:&#39;</span><span class="p">,</span> <span class="n">ms1</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">hist</span><span class="p">)))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="s1">&#39;ms1[0:2, 0:2].hist:&#39;</span><span class="p">,</span> <span class="n">ms1</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">hist</span><span class="p">)))</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">ms1</span><span class="o">.</span><span class="n">apply_to_maps</span><span class="p">(</span><span class="s1">&#39;__add__&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">ones</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>

    <span class="n">m1</span> <span class="o">=</span> <span class="n">Map</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;threes&#39;</span><span class="p">,</span> <span class="n">hist</span><span class="o">=</span><span class="mi">3</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_ebins</span><span class="p">,</span> <span class="n">n_czbins</span><span class="p">)),</span>
             <span class="n">binning</span><span class="o">=</span><span class="n">binning</span><span class="p">)</span>
    <span class="n">m2</span> <span class="o">=</span> <span class="n">Map</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;fours&#39;</span><span class="p">,</span> <span class="n">hist</span><span class="o">=</span><span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_ebins</span><span class="p">,</span> <span class="n">n_czbins</span><span class="p">)),</span> <span class="n">binning</span><span class="o">=</span><span class="n">binning</span><span class="p">)</span>
    <span class="n">ms2</span> <span class="o">=</span> <span class="n">MapSet</span><span class="p">(</span><span class="n">maps</span><span class="o">=</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;map set 2&#39;</span><span class="p">,</span> <span class="n">collate_by_name</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="n">ms1</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="n">ms2</span><span class="p">))))</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Should have errored out!&#39;</span><span class="p">)</span>

    <span class="n">m1</span> <span class="o">=</span> <span class="n">Map</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;fives&#39;</span><span class="p">,</span> <span class="n">hist</span><span class="o">=</span><span class="mi">5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_ebins</span><span class="p">,</span> <span class="n">n_czbins</span><span class="p">)),</span>
             <span class="n">binning</span><span class="o">=</span><span class="n">binning</span><span class="p">)</span>
    <span class="n">m2</span> <span class="o">=</span> <span class="n">Map</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;sixes&#39;</span><span class="p">,</span> <span class="n">hist</span><span class="o">=</span><span class="mi">6</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n_ebins</span><span class="p">,</span> <span class="n">n_czbins</span><span class="p">)),</span>
             <span class="n">binning</span><span class="o">=</span><span class="n">binning</span><span class="p">)</span>
    <span class="n">ms3</span> <span class="o">=</span> <span class="n">MapSet</span><span class="p">(</span><span class="n">maps</span><span class="o">=</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;map set 3&#39;</span><span class="p">,</span> <span class="n">collate_by_name</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">ms4</span> <span class="o">=</span> <span class="n">MapSet</span><span class="p">(</span><span class="n">maps</span><span class="o">=</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;map set 3&#39;</span><span class="p">,</span> <span class="n">collate_by_name</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">ms3</span> <span class="o">==</span> <span class="n">ms4</span>

    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="s1">&#39;ms2.maps:&#39;</span><span class="p">,</span> <span class="n">ms2</span><span class="o">.</span><span class="n">maps</span><span class="p">)))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="s2">&quot;(ms2 + ms3).names&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">ms2</span> <span class="o">+</span> <span class="n">ms3</span><span class="p">)</span><span class="o">.</span><span class="n">names</span><span class="p">)))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="s2">&quot;(ms2 + ms3)[0, 0].hist&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">ms2</span> <span class="o">+</span> <span class="n">ms3</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">hist</span><span class="p">)))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="s2">&quot;ms1[&#39;ones&#39;][0, 0]:&quot;</span><span class="p">,</span> <span class="n">ms1</span><span class="p">[</span><span class="s1">&#39;ones&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="s1">&#39;ms1.__mul__(2)[0, 0]:&#39;</span><span class="p">,</span> <span class="n">ms1</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="s1">&#39;(ms1 * 2)[0, 0]:&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">ms1</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="s1">&#39;ms1.__add__(ms1)[0, 0]:&#39;</span><span class="p">,</span> <span class="n">ms1</span><span class="o">.</span><span class="fm">__add__</span><span class="p">(</span><span class="n">ms1</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="s1">&#39;(ms1 + ms1)[0, 0]:&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">ms1</span> <span class="o">+</span> <span class="n">ms1</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="n">ms1</span><span class="o">.</span><span class="n">names</span><span class="p">)))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="s1">&#39;(ms1/ ms1)[0, 0]:&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">ms1</span> <span class="o">/</span> <span class="n">ms1</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="s1">&#39;(ms1/ms1 - 1)[0, 0]:&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">ms1</span><span class="o">/</span><span class="n">ms1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])))</span>
    <span class="c1">#logging.debug(str((&quot;ms1.log10()[&#39;ones&#39;]:&quot;, ms1.log10()[&#39;ones&#39;])))</span>
    <span class="c1">#logging.debug(str((&quot;ms1.log10()[0, 0][&#39;ones&#39;]:&quot;,</span>
    <span class="c1">#                   ms1.log10()[0, 0][&#39;ones&#39;])))</span>
    <span class="c1">#logging.debug(str((&#39;np.log10(ms1):&#39;, np.log10(ms1))))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="s1">&#39;(ms1 * np.e).binning:&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">ms1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="n">binning</span><span class="p">)))</span>
    <span class="c1">#logging.debug(str((&#39;np.log(ms1 * np.e)[0][0, 0]:&#39;,</span>
    <span class="c1">#                   (np.log(ms1 * np.e))[0][0, 0])))</span>
    <span class="c1">#logging.debug(str((&#39;np.sqrt(ms1)[0][0:4, 0:2].hist:&#39;,</span>
    <span class="c1">#                   np.sqrt(ms1)[0][0:4, 0:2].hist)))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="s1">&#39;str(ms1)&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">ms1</span><span class="p">))))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="s1">&#39;str(ms4)&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">ms4</span><span class="p">))))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="s1">&#39;ms3&#39;</span><span class="p">,</span> <span class="n">ms3</span><span class="p">)))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">((</span><span class="s1">&#39;ms4&#39;</span><span class="p">,</span> <span class="n">ms4</span><span class="p">)))</span>

    <span class="n">testdir</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkdtemp</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">ms</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ms01</span><span class="p">,</span> <span class="n">ms02</span><span class="p">,</span> <span class="n">ms1</span><span class="p">,</span> <span class="n">ms2</span><span class="p">,</span> <span class="n">ms3</span><span class="p">,</span> <span class="n">ms4</span><span class="p">]:</span>
            <span class="n">ms_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">testdir</span><span class="p">,</span> <span class="n">ms</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;.json&#39;</span><span class="p">)</span>
            <span class="n">ms</span><span class="o">.</span><span class="n">to_json</span><span class="p">(</span><span class="n">ms_file</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">ms_</span> <span class="o">=</span> <span class="n">MapSet</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">ms_file</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">ms_</span> <span class="o">==</span> <span class="n">ms</span><span class="p">,</span> <span class="s1">&#39;ms=</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="s1">ms_=</span><span class="se">\n</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">ms_</span><span class="p">)</span>
            <span class="n">jsons</span><span class="o">.</span><span class="n">to_json</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">ms_file</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">ms_</span> <span class="o">=</span> <span class="n">MapSet</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">ms_file</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">ms_</span> <span class="o">==</span> <span class="n">ms</span><span class="p">,</span> <span class="s1">&#39;ms=</span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="s1">ms_=</span><span class="se">\n</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">ms_</span><span class="p">)</span>

            <span class="c1"># Had bug where datastruct containing MapSet failed to be saved.</span>
            <span class="c1"># Test tuple containing list containing OrderedDict containing</span>
            <span class="c1"># MapSet.</span>
            <span class="n">struct</span> <span class="o">=</span> <span class="p">([</span><span class="n">OrderedDict</span><span class="p">(</span><span class="n">mapset</span><span class="o">=</span><span class="n">ms</span><span class="p">)],)</span>
            <span class="n">jsons</span><span class="o">.</span><span class="n">to_json</span><span class="p">(</span><span class="n">struct</span><span class="p">,</span> <span class="n">ms_file</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">loaded</span> <span class="o">=</span> <span class="n">jsons</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">ms_file</span><span class="p">)</span>
            <span class="n">ms_</span> <span class="o">=</span> <span class="n">MapSet</span><span class="p">(</span><span class="o">**</span><span class="n">loaded</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;mapset&#39;</span><span class="p">])</span>
            <span class="k">assert</span> <span class="n">ms_</span> <span class="o">==</span> <span class="n">ms</span>

            <span class="c1"># Now try with pickle</span>
            <span class="n">ms_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">testdir</span><span class="p">,</span> <span class="n">ms</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;.pkl&#39;</span><span class="p">)</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">struct</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">ms_file</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">),</span>
                        <span class="n">protocol</span><span class="o">=</span><span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span>
            <span class="n">loaded</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">ms_file</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">))</span>
            <span class="n">ms_</span> <span class="o">=</span> <span class="n">loaded</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;mapset&#39;</span><span class="p">]</span>
            <span class="k">assert</span> <span class="n">ms_</span> <span class="o">==</span> <span class="n">ms</span>

    <span class="k">finally</span><span class="p">:</span>
        <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">testdir</span><span class="p">,</span> <span class="n">ignore_errors</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">ms_copy</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">ms01</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">ms_copy</span> <span class="o">==</span> <span class="n">ms01</span>
    <span class="n">ms01</span> <span class="o">+=</span> <span class="mf">1.</span>
    <span class="c1"># make sure that the copy is indeed decoupled from the original</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="n">ms_copy</span> <span class="o">==</span> <span class="n">ms01</span><span class="p">)</span>
    
    <span class="c1"># Test reorder_dimensions (this just tests that it succeeds on the map set;</span>
    <span class="c1"># correctness of the reordering is tested in the unit test for Map)</span>
    <span class="k">for</span> <span class="n">ms</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ms01</span><span class="p">,</span> <span class="n">ms02</span><span class="p">,</span> <span class="n">ms1</span><span class="p">,</span> <span class="n">ms2</span><span class="p">,</span> <span class="n">ms3</span><span class="p">,</span> <span class="n">ms4</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">permutations</span><span class="p">(</span><span class="n">ms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">dimensions</span><span class="p">):</span>
            <span class="n">ms</span><span class="o">.</span><span class="n">reorder_dimensions</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;&lt;&lt; PASS : test_MapSet &gt;&gt;&#39;</span><span class="p">)</span></div>



<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">set_verbosity</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">test_Map</span><span class="p">()</span>
    <span class="n">test_MapSet</span><span class="p">()</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, The IceCube/PINGU Collaboration.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>