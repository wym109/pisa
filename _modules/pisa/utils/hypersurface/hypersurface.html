<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pisa.utils.hypersurface.hypersurface &mdash; PISA 4.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../../_static/documentation_options.js?v=9f5556dd"></script>
        <script src="../../../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            PISA
          </a>
              <div class="version">
                4.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../modules.html">API reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">PISA</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">pisa.utils.hypersurface.hypersurface</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for pisa.utils.hypersurface.hypersurface</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Tools for working with hypersurfaces, which are continuous functions in N-D</span>
<span class="sd">with arbitrary functional forms.</span>

<span class="sd">Hypersurfaces can be used to model systematic uncertainties derived from discrete</span>
<span class="sd">simulation datasets, for example for detedctor uncertainties.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Hypersurface&#39;</span><span class="p">,</span> <span class="s1">&#39;HypersurfaceParam&#39;</span><span class="p">,</span> <span class="s1">&#39;fit_hypersurfaces&#39;</span><span class="p">,</span>
           <span class="s1">&#39;load_hypersurfaces&#39;</span><span class="p">]</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s1">&#39;T. Stuttard, A. Trettin&#39;</span>

<span class="n">__license__</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;Copyright (c) 2014-2017, The IceCube Collaboration</span>

<span class="s1"> Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="s1"> you may not use this file except in compliance with the License.</span>
<span class="s1"> You may obtain a copy of the License at</span>

<span class="s1">   http://www.apache.org/licenses/LICENSE-2.0</span>

<span class="s1"> Unless required by applicable law or agreed to in writing, software</span>
<span class="s1"> distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="s1"> WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="s1"> See the License for the specific language governing permissions and</span>
<span class="s1"> limitations under the License.&#39;&#39;&#39;</span>


<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">copy</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">iminuit</span> <span class="kn">import</span> <span class="n">Minuit</span>

<span class="kn">from</span> <span class="nn">pisa</span> <span class="kn">import</span> <span class="n">FTYPE</span><span class="p">,</span> <span class="n">ureg</span>
<span class="kn">from</span> <span class="nn">pisa.utils.jsons</span> <span class="kn">import</span> <span class="n">from_json</span><span class="p">,</span> <span class="n">to_json</span>
<span class="kn">from</span> <span class="nn">pisa.core.pipeline</span> <span class="kn">import</span> <span class="n">Pipeline</span>
<span class="kn">from</span> <span class="nn">pisa.core.binning</span> <span class="kn">import</span> <span class="n">OneDimBinning</span><span class="p">,</span> <span class="n">MultiDimBinning</span><span class="p">,</span> <span class="n">is_binning</span>
<span class="kn">from</span> <span class="nn">pisa.core.map</span> <span class="kn">import</span> <span class="n">Map</span>
<span class="kn">from</span> <span class="nn">pisa.core.param</span> <span class="kn">import</span> <span class="n">Param</span><span class="p">,</span> <span class="n">ParamSet</span>
<span class="kn">from</span> <span class="nn">pisa.utils.resources</span> <span class="kn">import</span> <span class="n">find_resource</span>
<span class="kn">from</span> <span class="nn">pisa.utils.fileio</span> <span class="kn">import</span> <span class="n">mkdir</span>
<span class="kn">from</span> <span class="nn">pisa.utils.log</span> <span class="kn">import</span> <span class="n">logging</span><span class="p">,</span> <span class="n">set_verbosity</span>
<span class="kn">from</span> <span class="nn">pisa.utils.comparisons</span> <span class="kn">import</span> <span class="n">ALLCLOSE_KW</span>
<span class="kn">from</span> <span class="nn">uncertainties</span> <span class="kn">import</span> <span class="n">ufloat</span><span class="p">,</span> <span class="n">correlated_values</span>
<span class="kn">from</span> <span class="nn">uncertainties</span> <span class="kn">import</span> <span class="n">unumpy</span> <span class="k">as</span> <span class="n">unp</span>
<span class="kn">from</span> <span class="nn">.hypersurface_plotting</span> <span class="kn">import</span> <span class="n">plot_bin_fits</span><span class="p">,</span> <span class="n">plot_bin_fits_2d</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Hypersurface functional forms</span>

<span class="sd">   Define functional forms for HypersurfaceParam instances here.</span>

<span class="sd">   Functions defined here MUST:</span>
<span class="sd">     - Support numba guvectorization.</span>
<span class="sd">     - Function arguments must observed this convention:</span>
<span class="sd">         `p`, `&lt;coefficient 0&gt;`, ..., `&lt;coefficient N&gt;`, `out` where `p` is the</span>
<span class="sd">         systematic parameter, `out is the array to write the results to, and there are</span>
<span class="sd">         N coefficients of the parameterisation.</span>

<span class="sd">   The format of these arguments depends on the use case, of which there are two:</span>
<span class="sd">     - When fitting the function coefficients. This is done bin-wise using multiple</span>
<span class="sd">     datasets.</span>
<span class="sd">       - Params are then: `p` is array (one value per dataset), coefficients and `out`</span>
<span class="sd">         are scalar (representing a single bin).</span>
<span class="sd">     - Evaluating a fitted hypersurface. This is done for all bins simultaneously, using</span>
<span class="sd">       a single value for p.</span>
<span class="sd">       - Params are then: `p` is scalar (current value of systematic parameter,</span>
<span class="sd">         coefficients and `out` are arrays representing the hypersurfaces of all bins</span>
<span class="sd">         per bin.</span>
<span class="sd">&#39;&#39;&#39;</span>


<span class="k">class</span> <span class="nc">linear_hypersurface_func</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Linear hypersurface functional form</span>

<span class="sd">    f(p) = m * p</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nargs</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="n">p</span>
        <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="n">result</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="c1"># because m itself is not in the actual calculation, we have to broadcast</span>
        <span class="c1"># manually to yield the same shape as if we had done m*p and added one axis</span>
        <span class="n">foo</span> <span class="o">=</span> <span class="n">m</span><span class="o">*</span><span class="n">p</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">foo</span><span class="o">.</span><span class="n">shape</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="n">result</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">quadratic_hypersurface_func</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Quadratic hypersurface functional form</span>

<span class="sd">    f(p) = m1*p + m2*p**2</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nargs</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">m1</span><span class="o">*</span><span class="n">p</span> <span class="o">+</span> <span class="n">m2</span><span class="o">*</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="n">result</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
    <span class="c1"># the gradient *must* have all these arguments, even if they are un-used!</span>

    <span class="k">def</span> <span class="nf">grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="c1"># because m itself is not in the actual calculation, we have to broadcast</span>
        <span class="c1"># manually to yield the same shape as if we had done m*p and stacked on the last</span>
        <span class="c1"># axis</span>
        <span class="n">foo</span> <span class="o">=</span> <span class="n">m1</span><span class="o">*</span><span class="n">p</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">foo</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
                           <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">p</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">foo</span><span class="o">.</span><span class="n">shape</span><span class="p">)],</span>
                          <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span>
                          <span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="n">result</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">exponential_hypersurface_func</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Exponential hypersurface functional form</span>

<span class="sd">    f(p) = exp(b*p) - 1</span>

<span class="sd">    The functional form ensures that it is zero at the nominal point.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nargs</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.</span>
        <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="n">result</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="c1"># because parameters and coefficients both appear, everything is broadcast</span>
        <span class="c1"># automatically</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">p</span><span class="p">)])[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="n">result</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">scaled_exponential_hypersurface_func</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Exponential hypersurface functional form</span>

<span class="sd">    f(p) = (a + 1) * (exp(b*p) - 1)</span>

<span class="sd">    The functional form is chosen such that it is zero at the nominal point.</span>
<span class="sd">    If a strong prior is imposed on a, it becomes equivalent to the un-scaled</span>
<span class="sd">    exponential hypersurface function.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nargs</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="n">result</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="c1"># because parameters and coefficients both appear, everything is broadcast</span>
        <span class="c1"># automatically</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="mf">1.</span><span class="p">)</span><span class="o">*</span><span class="n">p</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">p</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="n">result</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">logarithmic_hypersurface_func</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Logarithmic hypersurface functional form</span>

<span class="sd">    f(p) = log(1 + mp)</span>

<span class="sd">    Allows the fit of an effectively linear multiplicative</span>
<span class="sd">    function while in logmode, since:</span>
<span class="sd">    exp(log(1 + mp) + h) = (1 + mp) exp(h)</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nargs</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">m</span><span class="o">*</span><span class="n">p</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="n">result</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">grad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
        <span class="c1"># because parameters and coefficients both appear, everything is broadcast</span>
        <span class="c1"># automatically</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">m</span><span class="o">*</span><span class="n">p</span><span class="p">))[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="n">result</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>


<span class="c1"># Container holding all possible functions</span>
<span class="n">HYPERSURFACE_PARAM_FUNCTIONS</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
<span class="n">HYPERSURFACE_PARAM_FUNCTIONS</span><span class="p">[</span><span class="s2">&quot;linear&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">linear_hypersurface_func</span>
<span class="n">HYPERSURFACE_PARAM_FUNCTIONS</span><span class="p">[</span><span class="s2">&quot;quadratic&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">quadratic_hypersurface_func</span>
<span class="n">HYPERSURFACE_PARAM_FUNCTIONS</span><span class="p">[</span><span class="s2">&quot;exponential&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">exponential_hypersurface_func</span>
<span class="n">HYPERSURFACE_PARAM_FUNCTIONS</span><span class="p">[</span><span class="s2">&quot;exponential_scaled&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">scaled_exponential_hypersurface_func</span>
<span class="n">HYPERSURFACE_PARAM_FUNCTIONS</span><span class="p">[</span><span class="s2">&quot;logarithmic&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">logarithmic_hypersurface_func</span>

<div class="viewcode-block" id="Hypersurface">
<a class="viewcode-back" href="../../../../pisa.utils.hypersurface.html#pisa.utils.hypersurface.hypersurface.Hypersurface">[docs]</a>
<span class="k">class</span> <span class="nc">Hypersurface</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A class defining the hypersurface</span>

<span class="sd">    Contains :</span>
<span class="sd">      - A single common intercept</span>
<span class="sd">      - N systematic parameters, inside which the functional form is defined</span>

<span class="sd">    This class can be configured to hold both the functional form of the hypersurface</span>
<span class="sd">    and values (likely fitted from simulation datasets) for the free parameters of this</span>
<span class="sd">    functional form.</span>

<span class="sd">    Fitting functionality is provided to fit these free parameters.</span>

<span class="sd">    This class can simultaneously hold hypersurfaces for every bin in a histogram (Map).</span>

<span class="sd">    The functional form of the systematic parameters can be arbitrarily complex.</span>

<span class="sd">    The class has a fit method for fitting the hypersurface to some data (e.g.</span>
<span class="sd">    discrete systematics sets).</span>

<span class="sd">    Serialization functionality is included to allow fitted hypersurfaces to be stored</span>
<span class="sd">    to a file and re-loaded later (e.g. to be used in analysis).</span>

<span class="sd">    The main use cases are:</span>
<span class="sd">        1) Fit hypersurfaces</span>
<span class="sd">             - Define the desired HypersurfaceParams (functional form, intial coefficient guesses).</span>
<span class="sd">             - Instantiate the `Hypersurface` class, providing the hypersurface params and initial intercept guess.</span>
<span class="sd">             - Use `Hypersurface.fit` function (or more likely the `fit_hypersurfaces` helper function provided below),</span>
<span class="sd">               to fit the hypersurface coefficients to some provided datasets.</span>
<span class="sd">             - Store to file</span>
<span class="sd">        2) Evaluate an existing hypersurface</span>
<span class="sd">             - Load existing fitted Hypersurface from a file (`load_hypersurfaces` helper function)</span>
<span class="sd">             - Get the resulting hypersurface value for each bin for a given set of systemaic param</span>
<span class="sd">               values using the `Hypersurface.evaluate` method.</span>
<span class="sd">             - Use the hypersurface value for each bin to re-weight events</span>

<span class="sd">    The class stores information about the datasets used to fit the hypersurfaces, including the Maps</span>
<span class="sd">    used and nominal and systematic parameter values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    params : list</span>
<span class="sd">        A list of HypersurfaceParam instances defining the hypersurface.</span>
<span class="sd">        The `initial_fit_coeffts` values in this instances will be used as the starting</span>
<span class="sd">        point for any fits.</span>

<span class="sd">    initial_intercept : float</span>
<span class="sd">        Starting point for the hypersurface intercept in any fits</span>

<span class="sd">    log : bool, optional</span>
<span class="sd">        Set hypersurface to log mode. The surface is fit to the log of the bin counts.</span>
<span class="sd">        The fitted surface is exponentiated during evaluation. Default: False</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">initial_intercept</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="c1"># Store args</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_intercept</span> <span class="o">=</span> <span class="n">initial_intercept</span>
        <span class="c1"># Store params as dict for ease of lookup</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="s2">&quot;Duplicate param name found : </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">param</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">log</span>
        <span class="c1"># Internal state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialized</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Containers for storing fitting information</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_complete</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_info_stored</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_maps_norm</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_maps_smooth</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_maps_raw</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_chi2</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_cov_mat</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_method</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Also add option store the pipeline param values used to generate the</span>
        <span class="c1"># maps that are the inouts to the fits for these hypersurfaces. They are</span>
        <span class="c1"># not actually used in the fit and so this variable is generally `None`,</span>
        <span class="c1"># but a user can set them externally during the fitting process so that</span>
        <span class="c1"># they can be stored for for future reference</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_pipeline_param_values</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Serialization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_serializable_state</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Legacy handling</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">using_legacy_data</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binning</span><span class="p">,</span> <span class="n">nominal_param_values</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Actually initialise the hypersurface.</span>

<span class="sd">        Internal function, not to be called by a user.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1">#</span>
        <span class="c1"># Binning</span>
        <span class="c1">#</span>

        <span class="c1"># Store the binning</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binning</span> <span class="o">=</span> <span class="n">binning</span>

        <span class="c1"># Set a default initial intercept value if none provided</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_intercept</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initial_intercept</span> <span class="o">=</span> <span class="mf">0.</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="k">else</span> <span class="mf">1.</span>

        <span class="c1"># Create the fit coefficient arrays</span>
        <span class="c1"># Have one fit per bin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intercept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_intercept</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">FTYPE</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intercept_sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intercept</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="n">param</span><span class="o">.</span><span class="n">_init_fit_coefft_arrays</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="p">)</span>

        <span class="c1">#</span>
        <span class="c1"># Nominal values</span>
        <span class="c1">#</span>

        <span class="c1"># Store the nominal param values</span>
        <span class="c1"># TODO better checks, including not already set</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="n">param</span><span class="o">.</span><span class="n">nominal_value</span> <span class="o">=</span> <span class="n">nominal_param_values</span><span class="p">[</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>

        <span class="c1">#</span>
        <span class="c1"># Done</span>
        <span class="c1">#</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_initialized</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">initialized</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return flag indicating if hypersurface has been initialized</span>
<span class="sd">        Not giving use direct write-access to the variable as they should nt be setting it themselves</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialized</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">param_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the (ordered) names of the systematic parameters</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

<div class="viewcode-block" id="Hypersurface.evaluate">
<a class="viewcode-back" href="../../../../pisa.utils.hypersurface.html#pisa.utils.hypersurface.hypersurface.Hypersurface.evaluate">[docs]</a>
    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param_values</span><span class="p">,</span> <span class="n">bin_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_uncertainty</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Evaluate the hypersurface, using the systematic parameter values provided.</span>
<span class="sd">        Uses the current internal values for all functional form coefficients.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        param_values : dict</span>
<span class="sd">            A dict specifying the values of the systematic parameters to use in the evaluation.</span>
<span class="sd">            Format is :</span>
<span class="sd">                { sys_param_name_0 : sys_param_0_val, ..., sys_param_name_N : sys_param_N_val }.</span>
<span class="sd">                The keys must be string and correspond to the HypersurfaceParam instances.</span>
<span class="sd">                The values must be scalars.</span>

<span class="sd">        bin_idx : tuple or None</span>
<span class="sd">            Optionally can specify a particular bin (using numpy indexing). d</span>
<span class="sd">            Othewise will evaluate all bins.</span>

<span class="sd">        return_uncertainty : bool, optional</span>
<span class="sd">            return the uncertainty on the output (default: False)</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialized</span><span class="p">,</span> <span class="s2">&quot;Cannot evaluate hypersurface, it haas not been initialized&quot;</span>

        <span class="c1">#</span>
        <span class="c1"># Check inputs</span>
        <span class="c1">#</span>

        <span class="c1"># Determine number of sys param values (per sys param)</span>
        <span class="c1"># This will be &gt;1 when fitting, and == 1 when evaluating the hypersurface within the stage</span>
        <span class="n">num_param_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">param_values</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">size</span>

        <span class="c1"># Check same number of values for all sys params</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">param_values</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">size</span>
            <span class="k">assert</span> <span class="n">n</span> <span class="o">==</span> <span class="n">num_param_values</span><span class="p">,</span> <span class="s2">&quot;All sys params must have the same number of values&quot;</span>

        <span class="c1"># Determine whether using single bin or not</span>
        <span class="n">single_bin_mode</span> <span class="o">=</span> <span class="n">bin_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="c1">#</span>
        <span class="c1"># Prepare output array</span>
        <span class="c1">#</span>

        <span class="c1"># Determine shape of output array</span>
        <span class="c1"># Two possible cases, with limitations on both based on how the sys param functional forms are defined</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">single_bin_mode</span><span class="p">:</span>
            <span class="c1"># Case 1 : Calculating for all bins simultaneously (e.g. `bin_idx is None`)</span>
            <span class="c1">#          Only support a single scalar value for each systematic parameters</span>
            <span class="c1">#          Use case is evaluating the hypersurfaces during the hypersurface stage</span>
            <span class="k">assert</span> <span class="n">num_param_values</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Can only provide one value per sys param when evaluating all bins simultaneously&quot;</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">param_values</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span>
                    <span class="n">v</span><span class="p">),</span> <span class="s2">&quot;sys param values must be a scalar when evaluating all bins simultaneously&quot;</span>
            <span class="n">out_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">bin_idx</span> <span class="o">=</span> <span class="bp">Ellipsis</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Case 2 : Calculating for multiple sys param values, but only a single bin</span>
            <span class="c1">#          Use case is fitting the hypersurfaces fucntional form fit params</span>
            <span class="n">out_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_param_values</span><span class="p">,)</span>

        <span class="c1"># Create the output array</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">out_shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">FTYPE</span><span class="p">)</span>

        <span class="c1">#</span>
        <span class="c1"># Evaluate the hypersurface</span>
        <span class="c1">#</span>

        <span class="c1"># Start with the intercept</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_param_values</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">single_bin_mode</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intercept</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">intercept</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">],</span> <span class="n">dst</span><span class="o">=</span><span class="n">out</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">])</span>

        <span class="c1"># Evaluate each individual parameter</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">param_val</span> <span class="o">=</span> <span class="n">param_values</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">using_legacy_data</span> <span class="k">else</span> <span class="n">param_values</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">p</span><span class="o">.</span><span class="n">nominal_value</span>
            <span class="n">p</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">param_val</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">bin_idx</span><span class="o">=</span><span class="n">bin_idx</span><span class="p">)</span>

        <span class="n">output_factors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="k">else</span> <span class="n">out</span>

        <span class="k">if</span> <span class="n">return_uncertainty</span><span class="p">:</span>
            <span class="c1"># create buffer array for the gradients</span>
            <span class="n">n_coeffs</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># start with 1 because intercept is an additional coefficient</span>
            <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="n">n_coeffs</span> <span class="o">+=</span> <span class="n">param</span><span class="o">.</span><span class="n">num_fit_coeffts</span>
            <span class="n">gradient_buffer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span>
                <span class="n">out_shape</span> <span class="o">+</span> <span class="p">(</span><span class="n">n_coeffs</span><span class="p">,),</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">FTYPE</span><span class="p">)</span>
            <span class="c1"># Start with the intercept, its gradient is always 1</span>
            <span class="n">gradient_buffer</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>

            <span class="c1"># Evaluate gradient each individual parameter and store in buffer.</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># start at one because the intercept was already treated</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="n">gbuf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">out_shape</span> <span class="o">+</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">num_fit_coeffts</span><span class="p">,),</span>
                               <span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">FTYPE</span><span class="p">)</span>
                <span class="n">param_val</span> <span class="o">=</span> <span class="n">param_values</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">using_legacy_data</span> <span class="k">else</span> <span class="n">param_values</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">p</span><span class="o">.</span><span class="n">nominal_value</span>
                <span class="n">p</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">param_val</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">gbuf</span><span class="p">,</span> <span class="n">bin_idx</span><span class="o">=</span><span class="n">bin_idx</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">num_fit_coeffts</span><span class="p">):</span>
                    <span class="n">gradient_buffer</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">gbuf</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># In log-mode, the output is exponentiated. For the gradient this simply means multiplying</span>
            <span class="c1"># with the output itself.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                <span class="n">gradient_buffer</span> <span class="o">=</span> <span class="n">output_factors</span><span class="p">[</span><span class="o">...</span><span class="p">,</span>
                                                 <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">gradient_buffer</span>
            <span class="c1"># Calculate uncertainty from gradients and covariance matrix</span>
            <span class="n">transformed_jacobian</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span>
                <span class="s1">&#39;...j,...kj-&gt;...k&#39;</span><span class="p">,</span> <span class="n">gradient_buffer</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_cov_mat</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">])</span>
            <span class="n">variance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span>
                <span class="s1">&#39;...j,...j&#39;</span><span class="p">,</span> <span class="n">transformed_jacobian</span><span class="p">,</span> <span class="n">gradient_buffer</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">variance</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">variance</span><span class="p">)]</span> <span class="o">&gt;=</span> <span class="mf">0.</span><span class="p">),</span> <span class="s2">&quot;invalid covariance&quot;</span>

        <span class="k">if</span> <span class="n">return_uncertainty</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output_factors</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">variance</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output_factors</span></div>


<div class="viewcode-block" id="Hypersurface.fit">
<a class="viewcode-back" href="../../../../pisa.utils.hypersurface.html#pisa.utils.hypersurface.hypersurface.Hypersurface.fit">[docs]</a>
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nominal_map</span><span class="p">,</span> <span class="n">nominal_param_values</span><span class="p">,</span> <span class="n">sys_maps</span><span class="p">,</span> <span class="n">sys_param_values</span><span class="p">,</span>
            <span class="n">norm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;L-BFGS-B&quot;</span><span class="p">,</span> <span class="n">fix_intercept</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">intercept_bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">intercept_sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">include_empty</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">keep_maps</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ref_bin_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">smooth_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">smooth_kw</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Fit the hypersurface coefficients (in every bin) to best match the provided</span>
<span class="sd">        nominal and systematic datasets.</span>

<span class="sd">        Writes the results directly into this data structure.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nominal_map : Map</span>
<span class="sd">            Map from the nominal dataset</span>

<span class="sd">        nominal_param_values : dict</span>
<span class="sd">            Value of each systematic param used to generate the nominal dataset</span>
<span class="sd">            Format: { param_0_name : param_0_nom_val, ..., param_N_name : param_N_nom_val }</span>

<span class="sd">        sys_maps : list of Maps</span>
<span class="sd">            List containing the Map from each systematic dataset</span>

<span class="sd">        sys_param_values : list of dicts</span>
<span class="sd">            List where each element if a dict containing the values of each systematic</span>
<span class="sd">            param used to generate the that dataset Each list element specified the</span>
<span class="sd">            parameters for the corresponding element in `sys_maps`</span>

<span class="sd">        norm : bool</span>
<span class="sd">            Normalise the maps to the nominal map. This is what you want to do when</span>
<span class="sd">            using the hypersurface to re-weight simulation (which is the main use case).</span>
<span class="sd">            In principal the hypersurfaces are more general though and could be used for</span>
<span class="sd">            other tasks too, hence this option.</span>

<span class="sd">        method : str</span>
<span class="sd">            `method` arg to pass to `scipy.optimize.minimiza`</span>

<span class="sd">        fix_intercept : bool</span>
<span class="sd">            Fix intercept to the initial intercept.</span>

<span class="sd">        intercept_bounds : 2-tuple, optional</span>
<span class="sd">            Bounds on the intercept. Default is None (no bounds)</span>

<span class="sd">        include_empty : bool</span>
<span class="sd">            Include empty bins in the fit. If True, empty bins are included with value 0</span>
<span class="sd">            and sigma 1.</span>
<span class="sd">            Default: False</span>

<span class="sd">        keep_maps : bool</span>
<span class="sd">            Keep maps used to make the fit. If False, maps will be set to None after</span>
<span class="sd">            the fit is complete. This helps to reduce the size of JSONS if the</span>
<span class="sd">            Hypersurface is to be stored on disk.</span>

<span class="sd">        ref_bin_idx : tuple</span>
<span class="sd">            An index specifying a reference bin that will be used for logging</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1">#</span>
        <span class="c1"># Check inputs</span>
        <span class="c1">#</span>

        <span class="c1"># Check nominal dataset definition</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nominal_map</span><span class="p">,</span> <span class="n">Map</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nominal_param_values</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Mapping</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">nominal_param_values</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Params mismatch : </span><span class="si">{</span><span class="nb">set</span><span class="p">(</span><span class="n">nominal_param_values</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2"> != </span><span class="si">{</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">nominal_param_values</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">nominal_param_values</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
        <span class="c1"># Check systematic dataset definitions</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sys_maps</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sys_param_values</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Sequence</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys_maps</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys_param_values</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">sys_map</span><span class="p">,</span> <span class="n">sys_param_vals</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sys_maps</span><span class="p">,</span> <span class="n">sys_param_values</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sys_map</span><span class="p">,</span> <span class="n">Map</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sys_param_vals</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Mapping</span><span class="p">)</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;self.param_names: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="si">}</span><span class="se">\n</span><span class="s2"> sys_param_vals.keys(): </span><span class="si">{</span><span class="n">sys_param_vals</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">sys_param_vals</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">param_names</span><span class="p">),</span> <span class="n">msg</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">sys_param_vals</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span>
            <span class="k">assert</span> <span class="nb">all</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">sys_param_vals</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
            <span class="k">assert</span> <span class="n">sys_map</span><span class="o">.</span><span class="n">binning</span> <span class="o">==</span> <span class="n">nominal_map</span><span class="o">.</span><span class="n">binning</span>

        <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="n">include_empty</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">),</span> <span class="s2">&quot;empty bins cannot be included in log mode&quot;</span>
        <span class="c1">#</span>
        <span class="c1"># Format things before getting started</span>
        <span class="c1">#</span>

        <span class="c1"># Store the fitting method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_method</span> <span class="o">=</span> <span class="n">method</span>

        <span class="c1"># Store smoothing info</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">smooth_method</span> <span class="o">=</span> <span class="n">smooth_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">smooth_kw</span> <span class="o">=</span> <span class="n">smooth_kw</span>

        <span class="c1"># Initialise hypersurface using nominal dataset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init</span><span class="p">(</span><span class="n">binning</span><span class="o">=</span><span class="n">nominal_map</span><span class="o">.</span><span class="n">binning</span><span class="p">,</span>
                   <span class="n">nominal_param_values</span><span class="o">=</span><span class="n">nominal_param_values</span><span class="p">)</span>

        <span class="c1"># Combine nominal and sys sets</span>
        <span class="n">maps</span> <span class="o">=</span> <span class="p">[</span><span class="n">nominal_map</span><span class="p">]</span> <span class="o">+</span> <span class="n">sys_maps</span>
        <span class="n">param_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">nominal_param_values</span><span class="p">]</span> <span class="o">+</span> <span class="n">sys_param_values</span>

        <span class="c1"># Store raw maps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_maps_raw</span> <span class="o">=</span> <span class="n">maps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_info_stored</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Convert params values from `list of dicts` to `dict of lists`</span>
        <span class="n">param_values_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">param_values</span><span class="p">])</span>
                             <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">param_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())}</span>

        <span class="c1"># Save the param values used for fitting in the param objects (useful for plotting later)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">param_values_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">fit_param_values</span> <span class="o">=</span> <span class="n">values</span>

        <span class="c1"># Format the fit `x` values : [ [sys param 0 values], [sys param 1 values], ... ]</span>
        <span class="c1"># Order of the params must match the order in `self.params`</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">param_values_dict</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">keys</span><span class="p">())],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">FTYPE</span><span class="p">)</span>
        <span class="c1"># Prepare covariance matrix array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_cov_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">+</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">num_fit_coeffts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_fit_coeffts</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">)</span>


        <span class="c1">#</span>
        <span class="c1"># Smoothing</span>
        <span class="c1">#</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fit_maps_smooth</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">smooth_method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="p">:</span>

            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Hypersurface smoothing needs some fixing&quot;</span><span class="p">)</span>

            <span class="n">fit_maps_smooth</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">smooth_method</span> <span class="o">==</span> <span class="s2">&quot;gaussian_filter&quot;</span> <span class="p">:</span>

                <span class="c1">#</span>
                <span class="c1"># Perform Gaussian filtering on the input maps</span>
                <span class="c1">#</span>



                <span class="c1">#TODO REMOVE</span>
                <span class="c1">#TODO REMOVE</span>
                <span class="c1">#TODO REMOVE</span>
                <span class="c1">#TODO REMOVE</span>
                <span class="c1">#TODO REMOVE</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&gt;&gt;&gt;&gt; STARTED gaussian_filter SMOOTHING&quot;</span><span class="p">)</span>
                <span class="c1">#TODO REMOVE</span>
                <span class="c1">#TODO REMOVE</span>
                <span class="c1">#TODO REMOVE</span>
                <span class="c1">#TODO REMOVE</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">smooth_kw</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">smooth_kw</span> <span class="o">=</span> <span class="p">{}</span>

                <span class="c1"># Treating each PID bin individually as a 2D hist (E, coszen)</span>
                <span class="c1">#TODO Make more general</span>
                <span class="c1">#TODO Can smooth in 3 dims here if desired with gaussian_filter (I think...)</span>
                <span class="n">split_dim</span> <span class="o">=</span> <span class="s2">&quot;pid&quot;</span>
                <span class="k">assert</span> <span class="n">split_dim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span>

                <span class="c1"># Loop over maps and apply filter</span>
                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_maps</span> <span class="p">:</span>
                    <span class="n">fit_maps_smooth</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">m</span><span class="o">.</span><span class="n">gaussian_filter</span><span class="p">(</span><span class="n">split_dim</span><span class="o">=</span><span class="n">split_dim</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">smooth_kw</span><span class="p">)</span> <span class="p">)</span>

            <span class="k">else</span> <span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown smooting method : </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">smooth_method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


            <span class="c1"># Store</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_maps_smooth</span> <span class="o">=</span> <span class="n">fit_maps_smooth</span>





        <span class="c1">#</span>
        <span class="c1"># Normalisation</span>
        <span class="c1">#</span>

        <span class="c1"># All map values are finite, but if have empty bins the nominal map will end up</span>
        <span class="c1"># with inf bins in the normalised map (divide by zero). Use a mask to handle</span>
        <span class="c1"># this.</span>
        <span class="n">finite_mask</span> <span class="o">=</span> <span class="n">nominal_map</span><span class="o">.</span><span class="n">nominal_values</span> <span class="o">!=</span> <span class="mi">0</span>

        <span class="c1"># Also include any binning mask in the finite mask (since these bin will be NaN)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="p">:</span>
            <span class="n">finite_mask</span> <span class="o">=</span> <span class="n">finite_mask</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">mask</span>

        <span class="c1"># Normalise bin values, if requested</span>
        <span class="k">if</span> <span class="n">norm</span><span class="p">:</span>

            <span class="c1"># Normalise the maps by dividing the nominal map This means the hypersurface</span>
            <span class="c1"># results can be interpretted as a re-weighting factor, relative to the</span>
            <span class="c1"># nominal</span>

            <span class="c1"># Formalise, handling inf values</span>
            <span class="n">fit_maps_norm</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_maps</span><span class="p">:</span>
                <span class="n">norm_m</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                <span class="n">norm_m</span><span class="o">.</span><span class="n">hist</span><span class="p">[</span><span class="n">finite_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">norm_m</span><span class="o">.</span><span class="n">hist</span><span class="p">[</span><span class="n">finite_mask</span><span class="p">]</span> <span class="o">/</span> \
                    <span class="n">unp</span><span class="o">.</span><span class="n">nominal_values</span><span class="p">(</span><span class="n">nominal_map</span><span class="o">.</span><span class="n">hist</span><span class="p">[</span><span class="n">finite_mask</span><span class="p">])</span>
                <span class="n">norm_m</span><span class="o">.</span><span class="n">hist</span><span class="p">[</span><span class="o">~</span><span class="n">finite_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">ufloat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">)</span>
                <span class="n">fit_maps_norm</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">norm_m</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_maps_norm</span> <span class="o">=</span> <span class="n">fit_maps_norm</span>

        <span class="c1">#</span>
        <span class="c1"># Some final checks</span>
        <span class="c1">#</span>

        <span class="c1"># Not expecting any bins to have negative values (negative counts doesn&#39;t make</span>
        <span class="c1"># sense)</span>
        <span class="c1"># TODO hypersurface in general could consider -ve values (not explicitly</span>
        <span class="c1"># tied to histograms), so maybe can relax this constraint</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_maps</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">nominal_values</span><span class="p">[</span><span class="n">finite_mask</span><span class="p">]</span>
                          <span class="o">&gt;=</span> <span class="mf">0.</span><span class="p">),</span> <span class="s2">&quot;Found negative bin counts&quot;</span>

        <span class="c1">#</span>
        <span class="c1"># Loop over bins</span>
        <span class="c1">#</span>

        <span class="k">for</span> <span class="n">bin_idx</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>  <span class="c1"># TODO grab from input map</span>

            <span class="c1"># Check if this bin is masked</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">mask</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">]</span> <span class="o">==</span> <span class="kc">False</span><span class="p">)</span> <span class="p">:</span>

                <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Skipping masked bin </span><span class="si">{bin_idx}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="n">p0_intercept</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intercept</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">]</span>
                <span class="n">p0_param_coeffts</span> <span class="o">=</span> <span class="p">[</span><span class="n">param</span><span class="o">.</span><span class="n">get_fit_coefft</span><span class="p">(</span><span class="n">bin_idx</span><span class="o">=</span><span class="n">bin_idx</span><span class="p">,</span> <span class="n">coefft_idx</span><span class="o">=</span><span class="n">i_cft</span><span class="p">)</span>
                                    <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
                                    <span class="k">for</span> <span class="n">i_cft</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">num_fit_coeffts</span><span class="p">)]</span>
                <span class="k">if</span> <span class="n">fix_intercept</span><span class="p">:</span>
                    <span class="n">p0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p0_param_coeffts</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">FTYPE</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">p0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p0_intercept</span><span class="p">]</span> <span class="o">+</span> <span class="n">p0_param_coeffts</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">FTYPE</span><span class="p">)</span>

                <span class="c1"># Not fitting, add empty variables</span>
                <span class="n">popt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">)</span>
                <span class="n">pcov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>


            <span class="k">else</span> <span class="p">:</span>

                <span class="c1"># Otherwise proceed to fitting...</span>

                <span class="c1">#</span>
                <span class="c1"># Format this bin&#39;s data for fitting</span>
                <span class="c1">#</span>

                <span class="c1"># Format the fit `y` values : [ bin value 0, bin_value 1, ... ]</span>
                <span class="c1"># Also get the corresonding uncertainty</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">m</span><span class="o">.</span><span class="n">nominal_values</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">]</span>
                                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_maps</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">FTYPE</span><span class="p">)</span>
                <span class="n">y_sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">m</span><span class="o">.</span><span class="n">std_devs</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">]</span>
                                      <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_maps</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">FTYPE</span><span class="p">)</span>

                <span class="c1"># Create a mask for keeping all these points</span>
                <span class="c1"># May remove some points before fitting if find issues</span>
                <span class="n">scan_point_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

                <span class="c1"># Cases where we have a y_sigma element = 0 (normally because the</span>
                <span class="c1"># corresponding y element = 0) screw up the fits (least squares divides by</span>
                <span class="c1"># sigma, so get infs) By default, we ignore empty bins. If the user wishes</span>
                <span class="c1"># to include them, it can be done with a value of zero and standard</span>
                <span class="c1"># deviation of 1.</span>
                <span class="n">bad_sigma_mask</span> <span class="o">=</span> <span class="n">y_sigma</span> <span class="o">==</span> <span class="mf">0.</span>
                <span class="k">if</span> <span class="n">bad_sigma_mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">include_empty</span><span class="p">:</span>
                        <span class="n">y_sigma</span><span class="p">[</span><span class="n">bad_sigma_mask</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">scan_point_mask</span> <span class="o">=</span> <span class="n">scan_point_mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">bad_sigma_mask</span>

                <span class="c1"># Apply the mask to get the values I will actually use</span>
                <span class="n">x_to_use</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xx</span><span class="p">[</span><span class="n">scan_point_mask</span><span class="p">]</span> <span class="k">for</span> <span class="n">xx</span> <span class="ow">in</span> <span class="n">x</span><span class="p">])</span>
                <span class="n">y_to_use</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">scan_point_mask</span><span class="p">]</span>
                <span class="n">y_sigma_to_use</span> <span class="o">=</span> <span class="n">y_sigma</span><span class="p">[</span><span class="n">scan_point_mask</span><span class="p">]</span>

                <span class="c1"># Checks</span>
                <span class="k">assert</span> <span class="n">x_to_use</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">x_to_use</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">y_to_use</span><span class="o">.</span><span class="n">size</span>

                <span class="c1"># Get flat list of the fit param guesses</span>
                <span class="c1"># The param coefficients are ordered as [ param 0 cft 0, ..., param 0 cft N,</span>
                <span class="c1"># ..., param M cft 0, ..., param M cft N ]</span>
                <span class="n">p0_intercept</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intercept</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">]</span>
                <span class="n">p0_param_coeffts</span> <span class="o">=</span> <span class="p">[</span><span class="n">param</span><span class="o">.</span><span class="n">get_fit_coefft</span><span class="p">(</span><span class="n">bin_idx</span><span class="o">=</span><span class="n">bin_idx</span><span class="p">,</span> <span class="n">coefft_idx</span><span class="o">=</span><span class="n">i_cft</span><span class="p">)</span>
                                    <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
                                    <span class="k">for</span> <span class="n">i_cft</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">num_fit_coeffts</span><span class="p">)]</span>
                <span class="k">if</span> <span class="n">fix_intercept</span><span class="p">:</span>
                    <span class="n">p0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p0_param_coeffts</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">FTYPE</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">p0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p0_intercept</span><span class="p">]</span> <span class="o">+</span> <span class="n">p0_param_coeffts</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">FTYPE</span><span class="p">)</span>

                <span class="c1">#</span>
                <span class="c1"># Check if have valid data in this bin</span>
                <span class="c1">#</span>

                <span class="c1"># If have empty bins, cannot fit In particular, if the nominal map has an</span>
                <span class="c1"># empty bin, it cannot be rescaled (x * 0 = 0) If this case, no need to try</span>
                <span class="c1"># fitting</span>

                <span class="c1"># Check if have NaNs/Infs</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">y_to_use</span><span class="p">)):</span>  <span class="c1"># TODO also handle missing sigma</span>
                    <span class="c1"># Not fitting, add empty variables</span>
                    <span class="n">popt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">)</span>
                    <span class="n">pcov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>

                <span class="c1"># Otherwise, fit...</span>
                <span class="k">else</span><span class="p">:</span>

                    <span class="c1">#</span>
                    <span class="c1"># Fit</span>
                    <span class="c1">#</span>

                    <span class="c1"># Must have at least as many sets as free params in fit or else curve_fit will fail</span>
                    <span class="k">assert</span> <span class="n">y</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">p0</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="s2">&quot;Number of datasets used for fitting (</span><span class="si">%i</span><span class="s2">) must be &gt;= num free params (</span><span class="si">%i</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span>
                        <span class="n">y</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">p0</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

                    <span class="c1"># Define a callback function for use with `curve_fit`</span>
                    <span class="c1">#   x : sys params</span>
                    <span class="c1">#   p : func/shape params</span>
                    <span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">):</span>

                        <span class="c1"># Note that this is using the dynamic variable `bin_idx`, which</span>
                        <span class="c1"># cannot be passed as an arg as `curve_fit` cannot handle fixed</span>
                        <span class="c1"># parameters.</span>
                        <span class="c1">#</span>
                        <span class="c1"># Unflatten list of the func/shape params, and write them to the</span>
                        <span class="c1"># hypersurface structure</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">intercept</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_intercept</span> <span class="k">if</span> <span class="n">fix_intercept</span> <span class="k">else</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">fix_intercept</span> <span class="k">else</span> <span class="mi">1</span>
                        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">num_fit_coeffts</span><span class="p">):</span>
                                <span class="n">bin_fit_idx</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">bin_idx</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">j</span><span class="p">])</span>
                                <span class="n">param</span><span class="o">.</span><span class="n">fit_coeffts</span><span class="p">[</span><span class="n">bin_fit_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

                        <span class="c1"># Unflatten sys param values</span>
                        <span class="n">params_unflattened</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">)):</span>
                            <span class="n">param_name</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="n">i</span><span class="p">]</span>
                            <span class="n">params_unflattened</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">params_unflattened</span><span class="p">,</span> <span class="n">bin_idx</span><span class="o">=</span><span class="n">bin_idx</span><span class="p">)</span>

                    <span class="n">inv_param_sigma</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">if</span> <span class="n">intercept_sigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">inv_param_sigma</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">intercept_sigma</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">inv_param_sigma</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                        <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">coeff_prior_sigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">num_fit_coeffts</span><span class="p">):</span>
                                <span class="n">inv_param_sigma</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                                    <span class="mf">1.</span><span class="o">/</span><span class="n">param</span><span class="o">.</span><span class="n">coeff_prior_sigma</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">num_fit_coeffts</span><span class="p">):</span>
                                <span class="n">inv_param_sigma</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
                    <span class="n">inv_param_sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">inv_param_sigma</span><span class="p">)</span>
                    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span>
                        <span class="n">inv_param_sigma</span><span class="p">)),</span> <span class="s2">&quot;invalid values found in prior sigma. They must not be zero.&quot;</span>

                    <span class="c1"># coefficient names to pass to Minuit. Not strictly necessary</span>
                    <span class="n">coeff_names</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">fix_intercept</span> <span class="k">else</span> <span class="p">[</span><span class="s1">&#39;intercept&#39;</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">num_fit_coeffts</span><span class="p">):</span>
                            <span class="n">coeff_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_p</span><span class="si">{:d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j</span><span class="p">))</span>

                    <span class="k">def</span> <span class="nf">loss</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">                        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">                        Loss to be minimized during the fit.</span>
<span class="sd">                        &#39;&#39;&#39;</span>
                        <span class="n">fvals</span> <span class="o">=</span> <span class="n">callback</span><span class="p">(</span><span class="n">x_to_use</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(((</span><span class="n">fvals</span> <span class="o">-</span> <span class="n">y_to_use</span><span class="p">)</span><span class="o">/</span><span class="n">y_sigma_to_use</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">inv_param_sigma</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

                    <span class="c1"># Define fit bounds for `minimize`. Bounds are pairs of (min, max)</span>
                    <span class="c1"># values for each parameter in the fit. Use &#39;None&#39; in place of min/max</span>
                    <span class="c1"># if there is</span>
                    <span class="c1"># no bound in that direction.</span>
                    <span class="n">fit_bounds</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">if</span> <span class="n">fix_intercept</span><span class="p">:</span>
                        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;fixed intercept needs no bounds&quot;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">intercept_bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">fit_bounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">intercept_bounds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">intercept_bounds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">),</span> <span class="s2">&quot;intercept bounds must be given as 2-tuple&quot;</span>
                        <span class="n">fit_bounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">intercept_bounds</span><span class="p">)</span>
                    
                    <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">fit_bounds</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                                <span class="p">((</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),)</span><span class="o">*</span><span class="n">param</span><span class="o">.</span><span class="n">num_fit_coeffts</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span>
                                    <span class="n">param</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;bounds on single coefficients must be given as 2-tuples&quot;</span>
                                <span class="n">fit_bounds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>
                            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">param</span><span class="o">.</span><span class="n">bounds</span><span class="p">]</span>
                                              <span class="p">),</span> <span class="s2">&quot;bounds must be given as a tuple of 2-tuples&quot;</span>
                                <span class="n">fit_bounds</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span>

                    <span class="c1"># Define the EPS (step length) used by the fitter Need to take care with</span>
                    <span class="c1"># floating type precision, don&#39;t want to go smaller than the FTYPE being</span>
                    <span class="c1"># used by PISA can handle</span>
                    <span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">FTYPE</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>

                    <span class="c1"># If no reference bin index was specified, used the first bin index to be fitted</span>
                    <span class="k">if</span> <span class="n">ref_bin_idx</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span>
                        <span class="n">ref_bin_idx</span> <span class="o">=</span> <span class="n">bin_idx</span>

                    <span class="c1"># Debug logging</span>
                    <span class="k">if</span> <span class="n">bin_idx</span> <span class="o">==</span> <span class="n">ref_bin_idx</span><span class="p">:</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;Curve fit inputs to bin </span><span class="si">%s</span><span class="s2"> :</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">bin_idx</span><span class="p">,)</span>
                        <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;  x           : </span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">x</span>
                        <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;  y           : </span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">y</span>
                        <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;  y sigma     : </span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">y_sigma</span>
                        <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;  x used      : </span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">x_to_use</span>
                        <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;  y used      : </span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">y_to_use</span>
                        <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;  y sigma used: </span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">y_sigma_to_use</span>
                        <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;  p0          : </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">p0</span>
                        <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;  bounds      : </span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">fit_bounds</span>
                        <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;  inv sigma   : </span><span class="se">\n</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">inv_param_sigma</span>
                        <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;  fit method  : </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_method</span>
                        <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>
                        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                    <span class="c1"># Perform fit</span>
                    <span class="c1"># errordef =1 for least squares fit and 0.5 for nllh fit</span>
                    <span class="n">m</span> <span class="o">=</span> <span class="n">Minuit</span><span class="p">(</span><span class="n">loss</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span>
                               <span class="c1"># only initial step size, not very important</span>
                               <span class="c1"># error=(0.1)*len(p0),</span>
                               <span class="c1"># limit=fit_bounds,</span>
                               <span class="n">name</span><span class="o">=</span><span class="n">coeff_names</span><span class="p">)</span>
                    <span class="n">m</span><span class="o">.</span><span class="n">errors</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">p0</span><span class="p">)</span>
                    <span class="n">m</span><span class="o">.</span><span class="n">limits</span> <span class="o">=</span> <span class="n">fit_bounds</span>
                    <span class="n">m</span><span class="o">.</span><span class="n">errordef</span> <span class="o">=</span> <span class="n">Minuit</span><span class="o">.</span><span class="n">LEAST_SQUARES</span>
                    <span class="n">m</span><span class="o">.</span><span class="n">migrad</span><span class="p">()</span>
                    <span class="n">m</span><span class="o">.</span><span class="n">hesse</span><span class="p">()</span>
                    <span class="n">popt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">pcov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">covariance</span><span class="p">))</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;HESSE call failed for bin </span><span class="si">{</span><span class="n">bin_idx</span><span class="si">}</span><span class="s2">, covariance matrix unavailable&quot;</span><span class="p">)</span>
                        <span class="n">pcov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">p0</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">p0</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">bin_idx</span> <span class="o">==</span> <span class="n">ref_bin_idx</span><span class="p">:</span>
                        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">fmin</span><span class="p">)</span>
                        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
                        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">covariance</span><span class="p">)</span>
            <span class="c1">#</span>
            <span class="c1"># Re-format fit results</span>
            <span class="c1">#</span>

            <span class="c1"># Use covariance matrix to get uncertainty in fit parameters Using</span>
            <span class="c1"># uncertainties.correlated_values, and will extract the std dev (including</span>
            <span class="c1"># correlations) shortly Fit may fail to determine covariance matrix</span>
            <span class="c1"># (method-dependent), so only do this if have a finite covariance matrix</span>
            <span class="n">corr_vals</span> <span class="o">=</span> <span class="n">correlated_values</span><span class="p">(</span><span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span><span class="p">)</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">pcov</span><span class="p">))</span> <span class="k">else</span> <span class="kc">None</span>

            <span class="c1"># Write the fitted param results (and sigma, if available) back to the</span>
            <span class="c1"># hypersurface structure</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">fix_intercept</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">intercept</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">popt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">intercept_sigma</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span> <span class="k">if</span> <span class="n">corr_vals</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">corr_vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">std_dev</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">num_fit_coeffts</span><span class="p">):</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">get_fit_coefft_idx</span><span class="p">(</span>
                        <span class="n">bin_idx</span><span class="o">=</span><span class="n">bin_idx</span><span class="p">,</span> <span class="n">coefft_idx</span><span class="o">=</span><span class="n">j</span><span class="p">)</span>
                    <span class="n">param</span><span class="o">.</span><span class="n">fit_coeffts</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">popt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">param</span><span class="o">.</span><span class="n">fit_coeffts_sigma</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span> <span class="k">if</span> <span class="n">corr_vals</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">corr_vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">std_dev</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="c1"># Store the covariance matrix</span>
            <span class="k">if</span> <span class="n">fix_intercept</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">pcov</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fit_cov_mat</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">pcov</span><span class="p">,</span> <span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fit_cov_mat</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">pcov</span>
        <span class="c1">#</span>
        <span class="c1"># chi2</span>
        <span class="c1">#</span>

        <span class="c1"># Compare the result of the fitted hypersurface function with the actual data</span>
        <span class="c1"># points used for fitting Compute the resulting chi2 to have an estimate of the</span>
        <span class="c1"># fit quality</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fit_chi2</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Loop over datasets</span>
        <span class="k">for</span> <span class="n">i_set</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_fit_sets</span><span class="p">):</span>

            <span class="c1"># Get expected bin values according tohypersurface value</span>
            <span class="n">predicted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span>
                <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="n">values</span><span class="p">[</span><span class="n">i_set</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">param_values_dict</span><span class="o">.</span><span class="n">items</span><span class="p">())})</span>

            <span class="c1"># Get the observed value</span>
            <span class="n">observed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_maps</span><span class="p">[</span><span class="n">i_set</span><span class="p">]</span><span class="o">.</span><span class="n">nominal_values</span>
            <span class="n">sigma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_maps</span><span class="p">[</span><span class="n">i_set</span><span class="p">]</span><span class="o">.</span><span class="n">std_devs</span>
            <span class="c1"># we have to apply the same condition on which values we include</span>
            <span class="c1"># as we did during the fit above</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                <span class="n">valid_idx</span> <span class="o">=</span> <span class="n">sigma</span> <span class="o">&gt;</span> <span class="mf">0.</span>  <span class="c1"># can be NaN</span>
            <span class="k">if</span> <span class="n">include_empty</span><span class="p">:</span>
                <span class="n">sigma</span><span class="p">[</span><span class="o">~</span><span class="n">valid_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>

            <span class="c1"># Compute chi2</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                <span class="n">chi2</span> <span class="o">=</span> <span class="p">((</span><span class="n">predicted</span> <span class="o">-</span> <span class="n">observed</span><span class="p">)</span> <span class="o">/</span> <span class="n">sigma</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>

            <span class="c1"># Add to container</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_chi2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chi2</span><span class="p">)</span>

        <span class="c1"># Combine into single array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_chi2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_chi2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">FTYPE</span><span class="p">)</span>
        
        <span class="c1"># Drop input maps if not keeping them</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">keep_maps</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_maps_raw</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_maps_smooth</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_maps_norm</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_info_stored</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Record some provenance info about the fits</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_complete</span> <span class="o">=</span> <span class="kc">True</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nominal_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the stored nominal parameter for each dataset</span>
<span class="sd">        Returns: { param_0_name : param_0_nom_val, ..., param_N_name : param_N_nom_val }</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_info_stored</span><span class="p">,</span> <span class="s2">&quot;Cannot get fit dataset nominal values, fit info not stored</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="s2">&quot; (using legacy data)&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">using_legacy_data</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">([(</span><span class="n">name</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">nominal_value</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">())])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fit_param_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the stored systematic parameters from the datasets used for fitting</span>
<span class="sd">        Returns: { param_0_name : [ param_0_sys_val_0, ..., param_0_sys_val_M ], ..., param_N_name : [ param_N_sys_val_0, ..., param_N_sys_val_M ] }</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_info_stored</span><span class="p">,</span> <span class="s2">&quot;Cannot get fit dataset param values, fit info not stored</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="s2">&quot; (using legacy data)&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">using_legacy_data</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">([(</span><span class="n">name</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">fit_param_values</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">())])</span>

<div class="viewcode-block" id="Hypersurface.get_nominal_mask">
<a class="viewcode-back" href="../../../../pisa.utils.hypersurface.html#pisa.utils.hypersurface.hypersurface.Hypersurface.get_nominal_mask">[docs]</a>
    <span class="k">def</span> <span class="nf">get_nominal_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a mask indicating which datasets have nominal values for all parameters</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_info_stored</span><span class="p">,</span> <span class="s2">&quot;Cannot get nominal mask, fit info not stored</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="s2">&quot; (using legacy data)&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">using_legacy_data</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="n">nom_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_fit_sets</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="n">nom_mask</span> <span class="o">=</span> <span class="n">nom_mask</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span>
                <span class="n">param</span><span class="o">.</span><span class="n">fit_param_values</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">nominal_value</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">nom_mask</span></div>


<div class="viewcode-block" id="Hypersurface.get_on_axis_mask">
<a class="viewcode-back" href="../../../../pisa.utils.hypersurface.html#pisa.utils.hypersurface.hypersurface.Hypersurface.get_on_axis_mask">[docs]</a>
    <span class="k">def</span> <span class="nf">get_on_axis_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a mask indicating which datasets are &quot;on-axis&quot; for a given parameter.</span>

<span class="sd">        &quot;On-axis&quot; means &quot;generated using the nominal value for this parameter&quot;. Parameters other</span>
<span class="sd">        than the one specified can have non-nominal values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        param_name : str</span>
<span class="sd">            The name of systematic parameter for which we want on-axis datasets</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_info_stored</span><span class="p">,</span> <span class="s2">&quot;Cannot get on-axis mask, fit info not stored</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="s2">&quot; (using legacy data)&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">using_legacy_data</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_names</span>

        <span class="n">on_axis_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_fit_sets</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="c1"># Loop over sys params</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>

            <span class="c1"># Ignore the chosen param</span>
            <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">param_name</span><span class="p">:</span>

                <span class="c1"># Define a &quot;nominal&quot; mask</span>
                <span class="n">on_axis_mask</span> <span class="o">=</span> <span class="n">on_axis_mask</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span>
                    <span class="n">param</span><span class="o">.</span><span class="n">fit_param_values</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">nominal_value</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">on_axis_mask</span></div>


<div class="viewcode-block" id="Hypersurface.report">
<a class="viewcode-back" href="../../../../pisa.utils.hypersurface.html#pisa.utils.hypersurface.hypersurface.Hypersurface.report">[docs]</a>
    <span class="k">def</span> <span class="nf">report</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bin_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a string version of the hypersurface contents</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bin_idx : tuple of None</span>
<span class="sd">            Specify a particular bin (using numpy indexing). In this case only report on that bin.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="c1"># Fit results</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;&gt;&gt;&gt;&gt;&gt;&gt; Fit coefficients &gt;&gt;&gt;&gt;&gt;&gt;&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">bin_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">if</span> <span class="n">bin_idx</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[</span><span class="n">bin_idx</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">bin_idx</span> <span class="ow">in</span> <span class="n">bin_indices</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;  Bin </span><span class="si">%s</span><span class="s2"> :&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">bin_idx</span><span class="p">,)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;     Intercept : </span><span class="si">%0.5g</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">intercept</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">],)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;     </span><span class="si">%s</span><span class="s2"> : </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;</span><span class="si">%0.5g</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">param</span><span class="o">.</span><span class="n">get_fit_coefft</span><span class="p">(</span>
                    <span class="n">bin_idx</span><span class="o">=</span><span class="n">bin_idx</span><span class="p">,</span> <span class="n">coefft_idx</span><span class="o">=</span><span class="n">cft_idx</span><span class="p">)</span> <span class="k">for</span> <span class="n">cft_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">num_fit_coeffts</span><span class="p">)]))</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;&lt;&lt;&lt;&lt;&lt;&lt; Fit coefficients &lt;&lt;&lt;&lt;&lt;&lt;&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="k">return</span> <span class="n">msg</span></div>


    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">report</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fit_maps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the `Map instances used for fitting</span>
<span class="sd">        These will be normalised if the fit was performend to normalised maps.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_info_stored</span><span class="p">,</span> <span class="s2">&quot;Cannot get fit maps, fit info not stored</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="s2">&quot; (using legacy data)&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">using_legacy_data</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="c1"># Return whatever the final processed map type was during the fitting process</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_maps_norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_maps_norm</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_maps_smooth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_maps_smooth</span> 

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_maps_raw</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_maps_raw</span>

        <span class="k">else</span> <span class="p">:</span> 
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Cannot find fit maps&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_fit_sets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return number of datasets used for fitting</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_info_stored</span><span class="p">,</span> <span class="s2">&quot;Cannot get fit sets, fit info not stored</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="s2">&quot; (using legacy data)&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">using_legacy_data</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_param_values</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_fit_coeffts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the total number of coefficients in the hypersurface fit</span>
<span class="sd">        This is the overall intercept, plus the coefficients for each individual param</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">param</span><span class="o">.</span><span class="n">num_fit_coeffts</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">())]))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fit_coeffts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return all coefficients, in all bins, as a single array</span>
<span class="sd">        This is the overall intercept, plus the coefficients for each individual param</span>
<span class="sd">        Dimensions are: [binning ..., fit coeffts]</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">array</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">intercept</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">num_fit_coeffts</span><span class="p">):</span>
                <span class="n">array</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">get_fit_coefft</span><span class="p">(</span><span class="n">coefft_idx</span><span class="o">=</span><span class="n">i</span><span class="p">))</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">array</span>

    <span class="nd">@fit_coeffts</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">fit_coeffts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fit_coeffts</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Setter to conveniently set the coefficients in the parameters</span>
<span class="sd">        of the hypersurface in the same order in which they are also</span>
<span class="sd">        returned by the getter.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">assert</span> <span class="n">fit_coeffts</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_coeffts</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;incorrect shape of coefficients&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intercept</span> <span class="o">=</span> <span class="n">fit_coeffts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">num_fit_coeffts</span><span class="p">):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">get_fit_coefft_idx</span><span class="p">(</span><span class="n">coefft_idx</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
                <span class="n">param</span><span class="o">.</span><span class="n">fit_coeffts</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">fit_coeffts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span>
                <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fit_coefft_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return labels for each fit coefficient</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;intercept&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> p</span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">num_fit_coeffts</span><span class="p">)]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">serializable_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        OrderedDict containing savable state attributes</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_serializable_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># TODO always redo?</span>

            <span class="n">state</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>

            <span class="n">state</span><span class="p">[</span><span class="s2">&quot;_initialized&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialized</span>
            <span class="n">state</span><span class="p">[</span><span class="s2">&quot;binning&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">serializable_state</span>
            <span class="n">state</span><span class="p">[</span><span class="s2">&quot;initial_intercept&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_intercept</span>
            <span class="n">state</span><span class="p">[</span><span class="s2">&quot;log&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span>
            <span class="n">state</span><span class="p">[</span><span class="s2">&quot;intercept&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intercept</span>
            <span class="n">state</span><span class="p">[</span><span class="s2">&quot;intercept_sigma&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intercept_sigma</span>
            <span class="n">state</span><span class="p">[</span><span class="s2">&quot;fit_complete&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_complete</span>
            <span class="n">state</span><span class="p">[</span><span class="s2">&quot;fit_info_stored&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_info_stored</span>
            <span class="n">state</span><span class="p">[</span><span class="s2">&quot;fit_maps_norm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_maps_norm</span>
            <span class="n">state</span><span class="p">[</span><span class="s2">&quot;fit_maps_smooth&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_maps_smooth</span>
            <span class="n">state</span><span class="p">[</span><span class="s2">&quot;fit_maps_raw&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_maps_raw</span>
            <span class="n">state</span><span class="p">[</span><span class="s2">&quot;fit_chi2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_chi2</span>
            <span class="n">state</span><span class="p">[</span><span class="s2">&quot;fit_cov_mat&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_cov_mat</span>
            <span class="n">state</span><span class="p">[</span><span class="s2">&quot;fit_method&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_method</span>
            <span class="n">state</span><span class="p">[</span><span class="s2">&quot;fit_pipeline_param_values&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_pipeline_param_values</span>
            <span class="n">state</span><span class="p">[</span><span class="s2">&quot;using_legacy_data&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">using_legacy_data</span>

            <span class="n">state</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="n">state</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">][</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">serializable_state</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_serializable_state</span> <span class="o">=</span> <span class="n">state</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_serializable_state</span>

<div class="viewcode-block" id="Hypersurface.from_state">
<a class="viewcode-back" href="../../../../pisa.utils.hypersurface.html#pisa.utils.hypersurface.hypersurface.Hypersurface.from_state">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_state</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Instantiate a new object from the contents of a serialized state dict</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        resource : dict</span>
<span class="sd">            A dict</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        to_json</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#</span>
        <span class="c1"># Get the state</span>
        <span class="c1">#</span>

        <span class="c1"># If it is not already a a state, alternativey try to load it in case a JSON</span>
        <span class="c1"># file was passed</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">abc</span><span class="o">.</span><span class="n">Mapping</span><span class="p">):</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">from_json</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

        <span class="c1">#</span>
        <span class="c1"># Create params</span>
        <span class="c1">#</span>

        <span class="n">params</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Loop through params in the state</span>
        <span class="n">params_state</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;params&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">param_state</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">params_state</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">param</span> <span class="o">=</span> <span class="n">HypersurfaceParam</span><span class="o">.</span><span class="n">from_state</span><span class="p">(</span><span class="n">param_state</span><span class="p">)</span>
            <span class="n">params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">param</span><span class="p">)</span>

        <span class="c1">#</span>
        <span class="c1"># Create hypersurface</span>
        <span class="c1">#</span>

        <span class="c1"># Instantiate</span>
        <span class="n">hypersurface</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
            <span class="n">initial_intercept</span><span class="o">=</span><span class="n">state</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;initial_intercept&quot;</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="c1"># Add binning</span>
        <span class="n">hypersurface</span><span class="o">.</span><span class="n">binning</span> <span class="o">=</span> <span class="n">MultiDimBinning</span><span class="p">(</span><span class="o">**</span><span class="n">state</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;binning&quot;</span><span class="p">))</span>

        <span class="c1"># Add maps</span>
        <span class="n">fit_maps_raw</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;fit_maps_raw&quot;</span><span class="p">)</span>
        <span class="n">hypersurface</span><span class="o">.</span><span class="n">fit_maps_raw</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">fit_maps_raw</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[</span>
            <span class="n">Map</span><span class="p">(</span><span class="o">**</span><span class="n">map_state</span><span class="p">)</span> <span class="k">for</span> <span class="n">map_state</span> <span class="ow">in</span> <span class="n">fit_maps_raw</span><span class="p">]</span>

        <span class="n">fit_maps_norm</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;fit_maps_norm&quot;</span><span class="p">)</span>
        <span class="n">hypersurface</span><span class="o">.</span><span class="n">fit_maps_norm</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">fit_maps_norm</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[</span>
            <span class="n">Map</span><span class="p">(</span><span class="o">**</span><span class="n">map_state</span><span class="p">)</span> <span class="k">for</span> <span class="n">map_state</span> <span class="ow">in</span> <span class="n">fit_maps_norm</span><span class="p">]</span>

        <span class="n">fit_maps_smooth</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;fit_maps_smooth&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="s2">&quot;fit_maps_smooth&quot;</span> <span class="ow">in</span> <span class="n">state</span> <span class="k">else</span> <span class="kc">None</span> <span class="c1"># Backwards compatibility </span>
        <span class="n">hypersurface</span><span class="o">.</span><span class="n">fit_maps_smooth</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">fit_maps_smooth</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[</span>
            <span class="n">Map</span><span class="p">(</span><span class="o">**</span><span class="n">map_state</span><span class="p">)</span> <span class="k">for</span> <span class="n">map_state</span> <span class="ow">in</span> <span class="n">fit_maps_smooth</span><span class="p">]</span>

        <span class="c1"># Define rest of state</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">hypersurface</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">hypersurface</span></div>



<div class="viewcode-block" id="Hypersurface.fluctuate">
<a class="viewcode-back" href="../../../../pisa.utils.hypersurface.html#pisa.utils.hypersurface.hypersurface.Hypersurface.fluctuate">[docs]</a>
    <span class="k">def</span> <span class="nf">fluctuate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="p">:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return a new hypersurface object whose coefficients have been randomly fluctuated according </span>
<span class="sd">        to the fit covariance matrix.</span>

<span class="sd">        Used for testing the impact of statistical uncertainty in the hypersurfaces fits on</span>
<span class="sd">        downstream analyses.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1">#TODO uncorrelated fluctuation option</span>

        <span class="c1"># Init random state</span>
        <span class="k">if</span> <span class="n">random_state</span> <span class="ow">is</span> <span class="kc">None</span> <span class="p">:</span>
            <span class="n">random_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="mi">12345</span><span class="p">)</span> <span class="c1">#TODO use PISA functions for this</span>

        <span class="c1"># Create a copy of this instance</span>
        <span class="n">new_hypersurface</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="c1">#TODO Use serialized state instead?</span>

        <span class="c1"># Loop over bins</span>
        <span class="k">for</span> <span class="n">bin_idx</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>

            <span class="c1"># Skip if this bin has no fits</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_coeffts</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">]))</span> <span class="p">:</span>

                <span class="c1"># Perform multivariate random sampling from the covariance matrix</span>
                <span class="c1"># This gives new coefficients, which are written to the output hyersurface instance</span>
                <span class="n">new_fit_coeffts</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_coeffts</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_cov_mat</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">])</span>

                <span class="c1"># Set the values in the output hypersurface</span>
                <span class="n">new_hypersurface</span><span class="o">.</span><span class="n">intercept</span><span class="p">[</span><span class="n">bin_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_fit_coeffts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">new_hypersurface</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">num_fit_coeffts</span><span class="p">):</span>
                        <span class="n">idx</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">get_fit_coefft_idx</span><span class="p">(</span><span class="n">bin_idx</span><span class="o">=</span><span class="n">bin_idx</span><span class="p">,</span> <span class="n">coefft_idx</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
                        <span class="n">param</span><span class="o">.</span><span class="n">fit_coeffts</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_fit_coeffts</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">new_hypersurface</span></div>
</div>



<div class="viewcode-block" id="HypersurfaceParam">
<a class="viewcode-back" href="../../../../pisa.utils.hypersurface.html#pisa.utils.hypersurface.hypersurface.HypersurfaceParam">[docs]</a>
<span class="k">class</span> <span class="nc">HypersurfaceParam</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A class representing one of the parameters (and corresponding functional forms) in</span>
<span class="sd">    the hypersurface.</span>

<span class="sd">    A user creates the initial instances of thse params, before passing the to the</span>
<span class="sd">    Hypersurface instance. Once this has happened, the user typically does not need to</span>
<span class="sd">    directly interact woth these HypersurfaceParam instances.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    name : str</span>
<span class="sd">        Name of the parameter</span>

<span class="sd">    func_name : str</span>
<span class="sd">        Name of the hypersurface function to use.</span>
<span class="sd">        See &quot;Hypersurface functional forms&quot; section for more details, including</span>
<span class="sd">        available functions.</span>

<span class="sd">    initial_fit_coeffts : array</span>
<span class="sd">        Initial values for the coefficients of the functional form</span>
<span class="sd">        Number and meaning of coefficients depends on functional form</span>

<span class="sd">    bounds : 2-tuple of array_like, optional</span>
<span class="sd">        Lower and upper bounds on independent variables. Defaults to no bounds. Each</span>
<span class="sd">        element of the tuple must be either an array with the length equal to the number</span>
<span class="sd">        of parameters, or a scalar (in which case the bound is taken to be the same for</span>
<span class="sd">        all parameters.) Use ``np.inf`` with an appropriate sign to disable bounds on</span>
<span class="sd">        all or some parameters.</span>

<span class="sd">    coeff_prior_sigma : array, optional</span>
<span class="sd">        Prior sigma values for the coefficients. If None (default), no regularization</span>
<span class="sd">        will be applied during the fit.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">func_name</span><span class="p">,</span> <span class="n">initial_fit_coeffts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">coeff_prior_sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="c1"># Store basic members</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

        <span class="c1"># Handle functional form fit parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_coeffts</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Fit params container, not yet populated</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_coeffts_sigma</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># Fit param sigma container, not yet populated</span>
        <span class="c1"># The initial values for the fit parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_fit_coeffts</span> <span class="o">=</span> <span class="n">initial_fit_coeffts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">bounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coeff_prior_sigma</span> <span class="o">=</span> <span class="n">coeff_prior_sigma</span>

        <span class="c1"># Record information relating to the fitting</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitted</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># Flag indicating whether fit has been performed</span>
        <span class="c1"># The values of this sys param in each of the fitting datasets</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_param_values</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Placeholder for nominal value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nominal_value</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Serialization</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_serializable_state</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binning_shape</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># initialized when used in Hypersurface</span>
        <span class="c1">#</span>
        <span class="c1"># Init the functional form</span>
        <span class="c1">#</span>

        <span class="c1"># Get the function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func_name</span> <span class="o">=</span> <span class="n">func_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hypersurface_func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_hypersurface_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func_name</span><span class="p">)</span>

        <span class="c1"># Get the number of functional form parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_fit_coeffts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hypersurface_func</span><span class="o">.</span><span class="n">nargs</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff_prior_sigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coeff_prior_sigma</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_fit_coeffts</span><span class="p">,</span> <span class="s2">&quot;number of prior sigma values must equal the number of parameters.&quot;</span>
        <span class="c1"># Check and init the fit param initial values</span>
        <span class="c1"># TODO Add support for &quot;per bin&quot; initial values</span>
        <span class="k">if</span> <span class="n">initial_fit_coeffts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># No values provided, use 0 for all</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initial_fit_coeffts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num_fit_coeffts</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">FTYPE</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Use the provided initial values</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initial_fit_coeffts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_fit_coeffts</span><span class="p">)</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_fit_coeffts</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_fit_coeffts</span><span class="p">,</span> <span class="s2">&quot;&#39;initial_fit_coeffts&#39; should have </span><span class="si">%i</span><span class="s2"> values, found </span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num_fit_coeffts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_fit_coeffts</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_hypersurface_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Find the function defining the hypersurface functional form.</span>

<span class="sd">        User specifies this by it&#39;s string name, which must correspond to a pre-defined</span>
<span class="sd">        function in `HYPERSURFACE_PARAM_FUNCTIONS`.</span>

<span class="sd">        Internal function, not to be called by a user.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s2">&quot;&#39;func_name&#39; must be a string&quot;</span>

        <span class="k">assert</span> <span class="n">func_name</span> <span class="ow">in</span> <span class="n">HYPERSURFACE_PARAM_FUNCTIONS</span><span class="p">,</span> <span class="s2">&quot;Cannot find hypersurface function &#39;</span><span class="si">%s</span><span class="s2">&#39;, choose from </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="n">func_name</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">HYPERSURFACE_PARAM_FUNCTIONS</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="k">return</span> <span class="n">HYPERSURFACE_PARAM_FUNCTIONS</span><span class="p">[</span><span class="n">func_name</span><span class="p">]()</span>

    <span class="k">def</span> <span class="nf">_init_fit_coefft_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">binning</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Create the arrays for storing the fit parameters</span>
<span class="sd">        Have one fit per bin, for each parameter</span>
<span class="sd">        The shape of the `self.fit_coeffts` arrays is: (binning shape ..., num fit params )</span>

<span class="sd">        Internal function, not to be called by a user.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">arrays</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">binning_shape</span> <span class="o">=</span> <span class="n">binning</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">for</span> <span class="n">fit_coefft_initial_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_fit_coeffts</span><span class="p">:</span>

            <span class="n">fit_coefft_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">binning_shape</span><span class="p">,</span> <span class="n">fit_coefft_initial_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">FTYPE</span><span class="p">)</span>
            <span class="n">arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fit_coefft_array</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fit_coeffts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_coeffts_sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit_coeffts</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">)</span>

<div class="viewcode-block" id="HypersurfaceParam.evaluate">
<a class="viewcode-back" href="../../../../pisa.utils.hypersurface.html#pisa.utils.hypersurface.hypersurface.HypersurfaceParam.evaluate">[docs]</a>
    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">bin_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Evaluate the functional form for the given `param` values.</span>
<span class="sd">        Uses the current values of the fit coefficients.</span>

<span class="sd">        By default evaluates all bins, but optionally can specify a particular bin (used</span>
<span class="sd">        when fitting).</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># Create an array to fill with this contribution</span>
        <span class="n">this_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">FTYPE</span><span class="p">)</span>

        <span class="c1"># Form the arguments to pass to the functional form</span>
        <span class="c1"># Need to be flexible in terms of the number of fit parameters</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">param</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">cft_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_fit_coeffts</span><span class="p">):</span>
            <span class="n">args</span> <span class="o">+=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_fit_coefft</span><span class="p">(</span><span class="n">bin_idx</span><span class="o">=</span><span class="n">bin_idx</span><span class="p">,</span> <span class="n">coefft_idx</span><span class="o">=</span><span class="n">cft_idx</span><span class="p">)]</span>
        <span class="n">args</span> <span class="o">+=</span> <span class="p">[</span><span class="n">this_out</span><span class="p">]</span>

        <span class="c1"># Call the function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hypersurface_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

        <span class="c1"># Add to overall hypersurface result</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="n">this_out</span></div>


<div class="viewcode-block" id="HypersurfaceParam.gradient">
<a class="viewcode-back" href="../../../../pisa.utils.hypersurface.html#pisa.utils.hypersurface.hypersurface.HypersurfaceParam.gradient">[docs]</a>
    <span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">bin_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Evaluate gradient of the functional form for the given `param` values.</span>
<span class="sd">        Uses the current values of the fit coefficients.</span>

<span class="sd">        By default evaluates all bins, but optionally can specify a particular bin (used when fitting).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># Create an array to fill with the gradient</span>
        <span class="n">this_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">FTYPE</span><span class="p">)</span>

        <span class="c1"># Form the arguments to pass to the functional form</span>
        <span class="c1"># Need to be flexible in terms of the number of fit parameters</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">param</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">cft_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_fit_coeffts</span><span class="p">):</span>
            <span class="n">args</span> <span class="o">+=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_fit_coefft</span><span class="p">(</span><span class="n">bin_idx</span><span class="o">=</span><span class="n">bin_idx</span><span class="p">,</span> <span class="n">coefft_idx</span><span class="o">=</span><span class="n">cft_idx</span><span class="p">)]</span>
        <span class="n">args</span> <span class="o">+=</span> <span class="p">[</span><span class="n">this_out</span><span class="p">]</span>

        <span class="c1"># Call the function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hypersurface_func</span><span class="o">.</span><span class="n">grad</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="c1"># Copy to wherever the gradient is to be stored</span>
        <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="n">this_out</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>


<div class="viewcode-block" id="HypersurfaceParam.get_fit_coefft_idx">
<a class="viewcode-back" href="../../../../pisa.utils.hypersurface.html#pisa.utils.hypersurface.hypersurface.HypersurfaceParam.get_fit_coefft_idx">[docs]</a>
    <span class="k">def</span> <span class="nf">get_fit_coefft_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bin_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">coefft_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Indexing the fit_coefft matrix is a bit of a pain</span>
<span class="sd">        This helper function eases things</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># TODO can probably do this more cleverly with numpy indexing, but works for now...</span>

        <span class="c1"># Indexing based on the bin</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bin_idx</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">bin_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span><span class="bp">Ellipsis</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">bin_idx</span><span class="p">)</span>

        <span class="c1"># Indexing based on the coefficent</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coefft_idx</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coefft_idx</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">coefft_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coefft_idx</span><span class="p">)</span>

        <span class="c1"># Put it all together</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">idx</span></div>


<div class="viewcode-block" id="HypersurfaceParam.get_fit_coefft">
<a class="viewcode-back" href="../../../../pisa.utils.hypersurface.html#pisa.utils.hypersurface.hypersurface.HypersurfaceParam.get_fit_coefft">[docs]</a>
    <span class="k">def</span> <span class="nf">get_fit_coefft</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Get a fit coefficient values from the matrix</span>
<span class="sd">        Basically just wrapping the indexing function</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_fit_coefft_idx</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_coeffts</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">serializable_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        OrderedDict containing savable state attributes</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_serializable_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># TODO always redo?</span>

            <span class="n">state</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
            <span class="n">state</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
            <span class="n">state</span><span class="p">[</span><span class="s2">&quot;func_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_name</span>
            <span class="n">state</span><span class="p">[</span><span class="s2">&quot;num_fit_coeffts&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_fit_coeffts</span>
            <span class="n">state</span><span class="p">[</span><span class="s2">&quot;fit_coeffts&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_coeffts</span>
            <span class="n">state</span><span class="p">[</span><span class="s2">&quot;fit_coeffts_sigma&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_coeffts_sigma</span>
            <span class="n">state</span><span class="p">[</span><span class="s2">&quot;initial_fit_coeffts&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_fit_coeffts</span>
            <span class="n">state</span><span class="p">[</span><span class="s2">&quot;fitted&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitted</span>
            <span class="n">state</span><span class="p">[</span><span class="s2">&quot;fit_param_values&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_param_values</span>
            <span class="n">state</span><span class="p">[</span><span class="s2">&quot;binning_shape&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binning_shape</span>
            <span class="n">state</span><span class="p">[</span><span class="s2">&quot;nominal_value&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nominal_value</span>
            <span class="n">state</span><span class="p">[</span><span class="s2">&quot;bounds&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span>
            <span class="n">state</span><span class="p">[</span><span class="s2">&quot;coeff_prior_sigma&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff_prior_sigma</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_serializable_state</span> <span class="o">=</span> <span class="n">state</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_serializable_state</span>

<div class="viewcode-block" id="HypersurfaceParam.from_state">
<a class="viewcode-back" href="../../../../pisa.utils.hypersurface.html#pisa.utils.hypersurface.hypersurface.HypersurfaceParam.from_state">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_state</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>

        <span class="c1"># Define param init kwargs</span>
        <span class="c1"># Special handling for `coeff_prior_sigma`, which was missing in older</span>
        <span class="c1"># files (due to a bug in `serializable_state`) so need to handle this</span>
        <span class="c1"># for backwards compatibility</span>
        <span class="n">param_init_kw</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="n">state</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">),</span>
            <span class="n">func_name</span><span class="o">=</span><span class="n">state</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;func_name&quot;</span><span class="p">),</span>
            <span class="n">initial_fit_coeffts</span><span class="o">=</span><span class="n">state</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;initial_fit_coeffts&quot;</span><span class="p">),</span>
            <span class="n">bounds</span><span class="o">=</span><span class="n">state</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;bounds&quot;</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;coeff_prior_sigma&quot;</span> <span class="ow">in</span> <span class="n">state</span> <span class="p">:</span>
            <span class="n">param_init_kw</span><span class="p">[</span><span class="s2">&quot;coeff_prior_sigma&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;coeff_prior_sigma&quot;</span><span class="p">)</span>
        <span class="k">else</span> <span class="p">:</span>
            <span class="n">param_init_kw</span><span class="p">[</span><span class="s2">&quot;coeff_prior_sigma&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Create the param</span>
        <span class="n">param</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">param_init_kw</span><span class="p">)</span>

        <span class="c1"># Define rest of state</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">param</span></div>
</div>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Hypersurface fitting and loading helper functions</span>
<span class="sd">&#39;&#39;&#39;</span>


<span class="k">def</span> <span class="nf">get_hypersurface_file_name</span><span class="p">(</span><span class="n">hypersurface</span><span class="p">,</span> <span class="n">tag</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Create a descriptive file name</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">num_dims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">hypersurface</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
    <span class="n">param_str</span> <span class="o">=</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">hypersurface</span><span class="o">.</span><span class="n">param_names</span><span class="p">)</span>
    <span class="n">output_file</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">__hypersurface_fits__</span><span class="si">%d</span><span class="s2">d__</span><span class="si">%s</span><span class="s2">.json&quot;</span> <span class="o">%</span> <span class="p">(</span>
        <span class="n">tag</span><span class="p">,</span> <span class="n">num_dims</span><span class="p">,</span> <span class="n">param_str</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">output_file</span>


<div class="viewcode-block" id="fit_hypersurfaces">
<a class="viewcode-back" href="../../../../pisa.utils.hypersurface.html#pisa.utils.hypersurface.hypersurface.fit_hypersurfaces">[docs]</a>
<span class="k">def</span> <span class="nf">fit_hypersurfaces</span><span class="p">(</span><span class="n">nominal_dataset</span><span class="p">,</span> <span class="n">sys_datasets</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">output_dir</span><span class="p">,</span> <span class="n">tag</span><span class="p">,</span> <span class="n">combine_regex</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">minimum_mc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">minimum_weight</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">hypersurface_fit_kw</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A helper function that a user can use to fit hypersurfaces to a bunch of simulation</span>
<span class="sd">    datasets, and save the results to a file. Basically a wrapper of Hypersurface.fit,</span>
<span class="sd">    handling common pre-fitting tasks like producing mapsets from piplelines, merging</span>
<span class="sd">    maps from similar specifies, etc.</span>

<span class="sd">    Note that this supports fitting multiple hypersurfaces to the datasets, e.g. one per</span>
<span class="sd">    simulated species. Returns a dict with format: { map_0_key : map_0_hypersurface,</span>
<span class="sd">    ..., map_N_key : map_N_hypersurface, }</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nominal_dataset : dict</span>
<span class="sd">        Definition of the nominal dataset. Specifies the pipleline with which the maps</span>
<span class="sd">        can be created, and the values of all systematic parameters used to produced the</span>
<span class="sd">        dataset.</span>
<span class="sd">        Format must be:</span>
<span class="sd">            nominal_dataset = {</span>
<span class="sd">                &quot;pipeline_cfg&quot; = &lt;pipeline cfg file (either cfg file path or dict)&gt;),</span>
<span class="sd">                &quot;sys_params&quot; = { param_0_name : param_0_value_in_dataset, ..., param_N_name : param_N_value_in_dataset }</span>
<span class="sd">            }</span>
<span class="sd">        Sys params must correspond to the provided HypersurfaceParam instances provided</span>
<span class="sd">        in the `params` arg.</span>

<span class="sd">    sys_datasets : list of dicts</span>
<span class="sd">        List of dicts, where each dict defines one of the systematics datasets to be</span>
<span class="sd">        fitted. The format of each dict is the same as explained for `nominal_dataset`</span>

<span class="sd">    params : list of HypersurfaceParams</span>
<span class="sd">        List of HypersurfaceParams instances that define the hypersurface. Note that</span>
<span class="sd">        this defined ALL hypersurfaces fitted in this function, e.g. only supports a</span>
<span class="sd">        single parameterisation for all maps (this is almost almost what you want).</span>

<span class="sd">    output_dir : str</span>
<span class="sd">        Path to directly to write results file in</span>

<span class="sd">    tag : str</span>
<span class="sd">        A string identifier that will be included in the file name to help you make</span>
<span class="sd">        sense of the file in the future. Note that additional information on the</span>
<span class="sd">        contents will be added to the file name by this function.</span>

<span class="sd">    combine_regex : list of str, or None</span>
<span class="sd">        List of string regex expressions that will be used for merging maps. Used to</span>
<span class="sd">        combine similar species. Must be something that can be passed to the</span>
<span class="sd">        `MapSet.combine_re` function (see that functions docs for more details). Choose</span>
<span class="sd">        `None` is do not want to perform this merging.</span>

<span class="sd">    minimum_mc : int, optional</span>
<span class="sd">        Minimum number of unweighted MC events required in each bin. If the number</span>
<span class="sd">        of unweighted MC events in a bin in any MC set is less than this number, the</span>
<span class="sd">        value is set to exactly zero and will be excluded from the fit.</span>

<span class="sd">    minimum_weight : float, optional</span>
<span class="sd">        Minimum weight per bin. Bins with a total summed weight of less than this</span>
<span class="sd">        number are excluded from the fit. Intended use is to exclude extremely small</span>
<span class="sd">        values from KDE histograms that would pull the fit to zero.</span>

<span class="sd">    hypersurface_fit_kw : kwargs</span>
<span class="sd">        kwargs will be passed on to the calls to `Hypersurface.fit`</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># TODO Current yneed to manually ensure consistency between `combine_regex` here and</span>
    <span class="c1"># the `links` param in `hypersurface` Need to make `hypersurface` directly use</span>
    <span class="c1"># the value of `combine_regex` from the Hypersurface instance</span>

    <span class="c1">#</span>
    <span class="c1"># Make copies</span>
    <span class="c1">#</span>

    <span class="c1"># Take (deep) copies of lists/dicts to avoid modifying the originals</span>
    <span class="c1"># Useful for cases where this function is called in a loop (e.g. leave-one-out tests)</span>
    <span class="n">nominal_dataset</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">nominal_dataset</span><span class="p">)</span>
    <span class="n">sys_datasets</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">sys_datasets</span><span class="p">)</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>


    <span class="c1">#</span>
    <span class="c1"># Check inputs</span>
    <span class="c1">#</span>

    <span class="c1"># Check types</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sys_datasets</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Sequence</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Sequence</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>

    <span class="c1"># Check formatting of datasets is as expected</span>
    <span class="n">all_datasets</span> <span class="o">=</span> <span class="p">[</span><span class="n">nominal_dataset</span><span class="p">]</span> <span class="o">+</span> <span class="n">sys_datasets</span>
    <span class="k">for</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="n">all_datasets</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Mapping</span><span class="p">)</span>
        <span class="k">assert</span> <span class="s2">&quot;pipeline_cfg&quot;</span> <span class="ow">in</span> <span class="n">dataset</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s2">&quot;pipeline_cfg&quot;</span><span class="p">],</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Mapping</span><span class="p">))</span>
        <span class="k">assert</span> <span class="s2">&quot;sys_params&quot;</span> <span class="ow">in</span> <span class="n">dataset</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s2">&quot;sys_params&quot;</span><span class="p">],</span> <span class="n">collections</span><span class="o">.</span><span class="n">Mapping</span><span class="p">)</span>

    <span class="c1"># Check params</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">HypersurfaceParam</span><span class="p">)</span>

    <span class="c1"># Report inputs</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Hypersurface fit details :&quot;</span>
    <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;  Num params            : </span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;  Num fit coefficients  : </span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">sum</span><span class="p">(</span>
        <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">num_fit_coeffts</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">])</span>
    <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;  Num datasets          : 1 nominal + </span><span class="si">%i</span><span class="s2"> systematics&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span>
        <span class="n">sys_datasets</span><span class="p">)</span>
    <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;  Nominal values        : </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">nominal_dataset</span><span class="p">[</span><span class="s2">&quot;sys_params&quot;</span><span class="p">]</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="c1">#</span>
    <span class="c1"># Generate MapSets</span>
    <span class="c1">#</span>

    <span class="k">def</span> <span class="nf">find_hist_stage</span><span class="p">(</span><span class="n">pipeline</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Locate the index of the hist stage in a pipeline.&quot;&quot;&quot;</span>
        <span class="n">hist_idx_found</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">kde_idx_found</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pipeline</span><span class="o">.</span><span class="n">stages</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;hist&quot;</span><span class="p">:</span>
                <span class="n">hist_idx</span> <span class="o">=</span> <span class="n">i</span>
                <span class="n">hist_idx_found</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;kde&quot;</span><span class="p">:</span>
                <span class="n">hist_idx</span> <span class="o">=</span> <span class="n">i</span>
                <span class="n">kde_idx_found</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">hist_idx_found</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">kde_idx_found</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Could not find hist or kde stage in pipeline, aborting.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hist_idx</span><span class="p">,</span> <span class="n">kde_idx_found</span>

    <span class="c1"># Get maps and param values from nominal pipeline</span>
    <span class="n">nominal_pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">(</span><span class="n">nominal_dataset</span><span class="p">[</span><span class="s2">&quot;pipeline_cfg&quot;</span><span class="p">])</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Nominal pipeline parameters:</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">nominal_pipeline</span><span class="o">.</span><span class="n">params</span><span class="p">))</span>
    <span class="n">pipeline_param_values</span> <span class="o">=</span> <span class="p">{</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="p">:</span><span class="n">p</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">nominal_pipeline</span><span class="o">.</span><span class="n">params</span> <span class="p">}</span>
    <span class="n">nominal_dataset</span><span class="p">[</span><span class="s2">&quot;mapset&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nominal_pipeline</span><span class="o">.</span><span class="n">get_outputs</span><span class="p">()</span>  <span class="c1"># return_sum=False)</span>
    <span class="c1"># get the un-weighted event counts as well so that we can exclude bins</span>
    <span class="c1"># with too little statistics</span>
    <span class="c1"># First, find out which stage is the hist stage</span>
    <span class="n">hist_idx</span><span class="p">,</span> <span class="n">is_kde</span> <span class="o">=</span> <span class="n">find_hist_stage</span><span class="p">(</span><span class="n">nominal_pipeline</span><span class="p">)</span>
    <span class="c1"># minimum MC is only applicable to hist stage, not to KDE</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_kde</span><span class="p">:</span>
        <span class="n">nominal_pipeline</span><span class="o">.</span><span class="n">stages</span><span class="p">[</span><span class="n">hist_idx</span><span class="p">]</span><span class="o">.</span><span class="n">unweighted</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">nominal_dataset</span><span class="p">[</span><span class="s2">&quot;mapset_unweighted&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nominal_pipeline</span><span class="o">.</span><span class="n">get_outputs</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nominal_dataset</span><span class="p">[</span><span class="s2">&quot;mapset_unweighted&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Bootstrapping is required to calculate errors on the histograms</span>
        <span class="k">assert</span> <span class="n">nominal_pipeline</span><span class="o">.</span><span class="n">stages</span><span class="p">[</span><span class="n">hist_idx</span><span class="p">]</span><span class="o">.</span><span class="n">bootstrap</span><span class="p">,</span> <span class="p">(</span>
            <span class="s2">&quot;Hypersurfaces can only be fit to KDE histograms if bootstrapping is enabled.&quot;</span>
        <span class="p">)</span>
    <span class="k">del</span> <span class="n">nominal_pipeline</span> <span class="c1"># Save memory</span>

    <span class="c1"># Loop over sys datasets and grap the maps from them too</span>
    <span class="c1"># Also make sure the pipeline params match the nominal pipeline (only the input file should differ between them)</span>
    <span class="k">for</span> <span class="n">sys_dataset</span> <span class="ow">in</span> <span class="n">sys_datasets</span><span class="p">:</span>
        <span class="n">sys_pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">(</span><span class="n">sys_dataset</span><span class="p">[</span><span class="s2">&quot;pipeline_cfg&quot;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">sys_pipeline</span><span class="o">.</span><span class="n">params</span> <span class="p">:</span>
            <span class="k">assert</span> <span class="n">param</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">pipeline_param_values</span><span class="p">[</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">],</span> <span class="s2">&quot;Mismatch in pipeline param &#39;</span><span class="si">%s</span><span class="s2">&#39; value between nominal and systematic pipelines : </span><span class="si">%s</span><span class="s2"> != </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">param</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">pipeline_param_values</span><span class="p">[</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">])</span>
        <span class="n">sys_dataset</span><span class="p">[</span><span class="s2">&quot;mapset&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sys_pipeline</span><span class="o">.</span><span class="n">get_outputs</span><span class="p">()</span>  <span class="c1"># return_sum=False)</span>
        <span class="c1"># get the un-weighted event counts as well so that we can exclude bins</span>
        <span class="c1"># with too little statistics</span>
        <span class="c1"># First, find out which stage is the hist stage</span>
        <span class="n">hist_idx</span><span class="p">,</span> <span class="n">is_kde</span> <span class="o">=</span> <span class="n">find_hist_stage</span><span class="p">(</span><span class="n">sys_pipeline</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_kde</span><span class="p">:</span>
            <span class="n">sys_pipeline</span><span class="o">.</span><span class="n">stages</span><span class="p">[</span><span class="n">hist_idx</span><span class="p">]</span><span class="o">.</span><span class="n">unweighted</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">sys_dataset</span><span class="p">[</span><span class="s2">&quot;mapset_unweighted&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sys_pipeline</span><span class="o">.</span><span class="n">get_outputs</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sys_dataset</span><span class="p">[</span><span class="s2">&quot;mapset_unweighted&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">assert</span> <span class="n">sys_pipeline</span><span class="o">.</span><span class="n">stages</span><span class="p">[</span><span class="n">hist_idx</span><span class="p">]</span><span class="o">.</span><span class="n">bootstrap</span><span class="p">,</span> <span class="p">(</span>
                <span class="s2">&quot;Hypersurfaces can only be fit to KDE histograms if bootstrapping is &quot;</span>
                <span class="s2">&quot;enabled.&quot;</span>
            <span class="p">)</span>
        <span class="k">del</span> <span class="n">sys_pipeline</span>

    <span class="c1"># Merge maps according to the combine regex, if one was provided</span>
    <span class="k">if</span> <span class="n">combine_regex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nominal_dataset</span><span class="p">[</span><span class="s2">&quot;mapset&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nominal_dataset</span><span class="p">[</span><span class="s2">&quot;mapset&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">combine_re</span><span class="p">(</span><span class="n">combine_regex</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nominal_dataset</span><span class="p">[</span><span class="s2">&quot;mapset_unweighted&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nominal_dataset</span><span class="p">[</span><span class="s2">&quot;mapset_unweighted&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">nominal_dataset</span><span class="p">[</span><span class="s2">&quot;mapset_unweighted&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">combine_re</span><span class="p">(</span><span class="n">combine_regex</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">sys_dataset</span> <span class="ow">in</span> <span class="n">sys_datasets</span><span class="p">:</span>
            <span class="n">sys_dataset</span><span class="p">[</span><span class="s2">&quot;mapset&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sys_dataset</span><span class="p">[</span><span class="s2">&quot;mapset&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">combine_re</span><span class="p">(</span><span class="n">combine_regex</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sys_dataset</span><span class="p">[</span><span class="s2">&quot;mapset_unweighted&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">continue</span>
            <span class="n">sys_dataset</span><span class="p">[</span><span class="s2">&quot;mapset_unweighted&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">sys_dataset</span><span class="p">[</span><span class="s2">&quot;mapset_unweighted&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">combine_re</span><span class="p">(</span><span class="n">combine_regex</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="c1"># Remove bins (i.e. set their count to zero) that have too few MC events or too little</span>
    <span class="c1"># total weight</span>
    <span class="k">for</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="n">sys_datasets</span> <span class="o">+</span> <span class="p">[</span><span class="n">nominal_dataset</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">map_name</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">[</span><span class="s2">&quot;mapset&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dataset</span><span class="p">[</span><span class="s2">&quot;mapset_unweighted&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">insuff_mc</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="s2">&quot;mapset_unweighted&quot;</span><span class="p">][</span><span class="n">map_name</span><span class="p">]</span><span class="o">.</span><span class="n">nominal_values</span> <span class="o">&lt;</span> <span class="n">minimum_mc</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">insuff_mc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s2">&quot;mapset&quot;</span><span class="p">][</span><span class="n">map_name</span><span class="p">]</span><span class="o">.</span><span class="n">nominal_values</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">insuff_weight</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="s2">&quot;mapset&quot;</span><span class="p">][</span><span class="n">map_name</span><span class="p">]</span><span class="o">.</span><span class="n">nominal_values</span> <span class="o">&lt;</span> <span class="n">minimum_weight</span>
            <span class="c1"># Setting the hist to zero sets both nominal value and std_dev to zero</span>
            <span class="n">dataset</span><span class="p">[</span><span class="s2">&quot;mapset&quot;</span><span class="p">][</span><span class="n">map_name</span><span class="p">]</span><span class="o">.</span><span class="n">hist</span><span class="p">[</span><span class="n">insuff_mc</span> <span class="o">|</span> <span class="n">insuff_weight</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>

    <span class="c1"># TODO check every mapset has the same elements</span>



    <span class="c1">#</span>
    <span class="c1"># Loop over maps</span>
    <span class="c1">#</span>

    <span class="c1"># Create the container to fill</span>
    <span class="n">hypersurfaces</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>

    <span class="c1"># Loop over maps</span>
    <span class="k">for</span> <span class="n">map_name</span> <span class="ow">in</span> <span class="n">nominal_dataset</span><span class="p">[</span><span class="s2">&quot;mapset&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>

        <span class="c1">#</span>
        <span class="c1"># Prepare data for fit</span>
        <span class="c1">#</span>

        <span class="n">nominal_map</span> <span class="o">=</span> <span class="n">nominal_dataset</span><span class="p">[</span><span class="s2">&quot;mapset&quot;</span><span class="p">][</span><span class="n">map_name</span><span class="p">]</span>
        <span class="n">nominal_param_values</span> <span class="o">=</span> <span class="n">nominal_dataset</span><span class="p">[</span><span class="s2">&quot;sys_params&quot;</span><span class="p">]</span>

        <span class="n">sys_maps</span> <span class="o">=</span> <span class="p">[</span><span class="n">sys_dataset</span><span class="p">[</span><span class="s2">&quot;mapset&quot;</span><span class="p">][</span><span class="n">map_name</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">sys_dataset</span> <span class="ow">in</span> <span class="n">sys_datasets</span><span class="p">]</span>
        <span class="n">sys_param_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">sys_dataset</span><span class="p">[</span><span class="s2">&quot;sys_params&quot;</span><span class="p">]</span>
                            <span class="k">for</span> <span class="n">sys_dataset</span> <span class="ow">in</span> <span class="n">sys_datasets</span><span class="p">]</span>

        <span class="c1">#</span>
        <span class="c1"># Fit the hypersurface</span>
        <span class="c1">#</span>

        <span class="c1"># Create the hypersurface</span>
        <span class="n">hypersurface</span> <span class="o">=</span> <span class="n">Hypersurface</span><span class="p">(</span>
            <span class="n">params</span><span class="o">=</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">params</span><span class="p">),</span> <span class="c1"># Need the deepcopy, as want one set of params per map</span>
            <span class="n">initial_intercept</span><span class="o">=</span><span class="mf">0.</span> <span class="k">if</span> <span class="n">log</span> <span class="k">else</span> <span class="mf">1.</span><span class="p">,</span>  <span class="c1"># Initial value for intercept</span>
            <span class="n">log</span><span class="o">=</span><span class="n">log</span>
        <span class="p">)</span>

        <span class="c1"># Perform fit</span>
        <span class="n">hypersurface</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
            <span class="n">nominal_map</span><span class="o">=</span><span class="n">nominal_map</span><span class="p">,</span>
            <span class="n">nominal_param_values</span><span class="o">=</span><span class="n">nominal_param_values</span><span class="p">,</span>
            <span class="n">sys_maps</span><span class="o">=</span><span class="n">sys_maps</span><span class="p">,</span>
            <span class="n">sys_param_values</span><span class="o">=</span><span class="n">sys_param_values</span><span class="p">,</span>
            <span class="n">norm</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="o">**</span><span class="n">hypersurface_fit_kw</span>
        <span class="p">)</span>

        <span class="c1"># Record the pipeline params used to generate the maps used for</span>
        <span class="c1"># the fits, for data provenance purposes only</span>
        <span class="n">hypersurface</span><span class="o">.</span><span class="n">fit_pipeline_param_values</span> <span class="o">=</span> <span class="n">pipeline_param_values</span>

        <span class="c1"># Report the results</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Fitted hypersurface report:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">hypersurface</span><span class="p">)</span>

        <span class="c1"># Store for later write to disk</span>
        <span class="n">hypersurfaces</span><span class="p">[</span><span class="n">map_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">hypersurface</span>


    <span class="c1">#</span>
    <span class="c1"># Store results</span>
    <span class="c1">#</span>

    <span class="c1"># Create a file name</span>
    <span class="n">output_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">get_hypersurface_file_name</span><span class="p">(</span>
        <span class="nb">list</span><span class="p">(</span><span class="n">hypersurfaces</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tag</span><span class="p">))</span>

    <span class="c1"># Create the output directory</span>
    <span class="n">mkdir</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span>

    <span class="c1"># Write to a json file</span>
    <span class="n">to_json</span><span class="p">(</span><span class="n">hypersurfaces</span><span class="p">,</span> <span class="n">output_path</span><span class="p">)</span>

    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Fit results written : </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">output_path</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">output_path</span></div>



<div class="viewcode-block" id="load_hypersurfaces">
<a class="viewcode-back" href="../../../../pisa.utils.hypersurface.html#pisa.utils.hypersurface.hypersurface.load_hypersurfaces">[docs]</a>
<span class="k">def</span> <span class="nf">load_hypersurfaces</span><span class="p">(</span><span class="n">input_file</span><span class="p">,</span> <span class="n">expected_binning</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    User function to load file containing hypersurface fits, as written using `fit_hypersurfaces`.</span>
<span class="sd">    Can be multiple hypersurfaces assosicated with different maps.</span>

<span class="sd">    Returns a dict with the format: { map_0_key : map_0_hypersurface, ..., map_N_key : map_N_hypersurface, }</span>

<span class="sd">    Hnadling the following input files cases:</span>
<span class="sd">        1) Load files produced using this code (recommended)</span>
<span class="sd">        2) Load files producing using older versions of PISA</span>
<span class="sd">        3) Load public data releases csv formatted files</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input_file : str</span>
<span class="sd">        Path to the file contsaining the hypersurface fits.</span>
<span class="sd">        For the special case of the datareleases these needs to be the path to all</span>
<span class="sd">        relevent CSV fles, e.g. &quot;&lt;path/to/datarelease&gt;/hyperplanes_*.csv&quot;.</span>
<span class="sd">    expected_binning : One/MultiDimBinning</span>
<span class="sd">        (Optional) Expected binning for hypersurface.</span>
<span class="sd">        It will checked enforced that this mathes the binning found in the parsed</span>
<span class="sd">        hypersurfaces. For certain legacy cases where binning info is not stored, this</span>
<span class="sd">        will be assumed to be the actual binning.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1">#</span>
    <span class="c1"># Check inputs</span>
    <span class="c1">#</span>

    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_file</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">expected_binning</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">is_binning</span><span class="p">(</span><span class="n">expected_binning</span><span class="p">)</span>

    <span class="c1">#</span>
    <span class="c1"># PISA hypersurface files</span>
    <span class="c1">#</span>

    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Loading non-interpolated hypersurfaces from file: </span><span class="si">{</span><span class="n">input_file</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">hypersurfaces</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">input_file</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;json&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">input_file</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;json.bz2&quot;</span><span class="p">):</span>

        <span class="c1"># Load file</span>
        <span class="n">input_data</span> <span class="o">=</span> <span class="n">from_json</span><span class="p">(</span><span class="n">input_file</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_data</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Mapping</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Reading file complete, generating hypersurfaces...&quot;</span><span class="p">)</span>

        <span class="c1"># Testing various cases to support older files as well as modern ones...</span>
        <span class="k">if</span> <span class="s2">&quot;sys_list&quot;</span> <span class="ow">in</span> <span class="n">input_data</span><span class="p">:</span>

            <span class="c1"># Legacy case, create a modern hypersurface instance using old hyperplane fits</span>
            <span class="n">hypersurfaces</span> <span class="o">=</span> <span class="n">_load_hypersurfaces_legacy</span><span class="p">(</span><span class="n">input_data</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Old fit files detected, loaded via legacy mode&quot;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># Otherwise assume file is using the modern format</span>
            <span class="n">hypersurfaces</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">map_name</span><span class="p">,</span> <span class="n">hypersurface_state</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">input_data</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="n">hypersurfaces</span><span class="p">[</span><span class="n">map_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">Hypersurface</span><span class="o">.</span><span class="n">from_state</span><span class="p">(</span>
                    <span class="n">hypersurface_state</span><span class="p">)</span>

    <span class="c1">#</span>
    <span class="c1"># Public data release file</span>
    <span class="c1">#</span>

    <span class="k">elif</span> <span class="n">input_file</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;csv&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">input_file</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;csv.bz2&quot;</span><span class="p">):</span>

        <span class="n">hypersurfaces</span> <span class="o">=</span> <span class="n">_load_hypersurfaces_data_release</span><span class="p">(</span>
            <span class="n">input_file</span><span class="p">,</span> <span class="n">expected_binning</span><span class="p">)</span>

    <span class="c1">#</span>
    <span class="c1"># Done</span>
    <span class="c1">#</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unknown file format : </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">input_file</span><span class="p">)</span>

    <span class="c1"># Check binning</span>
    <span class="k">if</span> <span class="n">expected_binning</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">hypersurface</span> <span class="ow">in</span> <span class="n">hypersurfaces</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">hypersurface</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">hash</span> <span class="o">==</span> <span class="n">expected_binning</span><span class="o">.</span><span class="n">hash</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hypersurface</span><span class="o">.</span><span class="n">binning</span><span class="o">.</span><span class="n">dims</span><span class="p">,</span> <span class="n">expected_binning</span><span class="o">.</span><span class="n">dims</span><span class="p">):</span>
                    <span class="k">assert</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">,</span> <span class="s2">&quot;Incompatible binning dimension </span><span class="si">%s</span><span class="s2"> and </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Generated hypersurfaces&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">hypersurfaces</span></div>



<span class="k">def</span> <span class="nf">_load_hypersurfaces_legacy</span><span class="p">(</span><span class="n">input_data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Load an old hyperpane (not surface) fit file from older PISA version.</span>

<span class="sd">    Put the results into an instance the new `Hypersurface` class so can use the</span>
<span class="sd">    resulting hypersurface in modern code.</span>

<span class="sd">    User should not use this directly, instead call `load_hypersurfaces`.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">hypersurfaces</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>

    <span class="c1">#</span>
    <span class="c1"># Loop over map names</span>
    <span class="c1">#</span>

    <span class="k">for</span> <span class="n">map_name</span> <span class="ow">in</span> <span class="n">input_data</span><span class="p">[</span><span class="s2">&quot;map_names&quot;</span><span class="p">]:</span>

        <span class="c1">#</span>
        <span class="c1"># Create the params</span>
        <span class="c1">#</span>

        <span class="c1"># Get the param names</span>
        <span class="n">param_names</span> <span class="o">=</span> <span class="n">input_data</span><span class="p">[</span><span class="s2">&quot;sys_list&quot;</span><span class="p">]</span>

        <span class="c1"># Create the param instances.</span>
        <span class="c1"># Using linear functional forms (legacy files only supported linear forms, e.g.</span>
        <span class="c1"># hyperplanes rather than surfaces).</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">HypersurfaceParam</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">func_name</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="n">initial_fit_coeffts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">param_names</span><span class="p">]</span>

        <span class="c1">#</span>
        <span class="c1"># Get binning</span>
        <span class="c1">#</span>

        <span class="c1"># This varies depending on how old the file is...</span>
        <span class="c1"># Note that the hypersurface class really only needs to know the binning</span>
        <span class="c1"># shape (to create the coefficient arrays).</span>

        <span class="c1"># If the (serialized version of the) binning is stored, great! Use it</span>
        <span class="k">if</span> <span class="s2">&quot;binning&quot;</span> <span class="ow">in</span> <span class="n">input_data</span><span class="p">:</span>
            <span class="n">binning</span> <span class="o">=</span> <span class="n">MultiDimBinning</span><span class="p">(</span><span class="o">**</span><span class="n">input_data</span><span class="p">[</span><span class="s2">&quot;binning&quot;</span><span class="p">])</span>

        <span class="c1"># If no binning is available, can at least get the correct shape (using</span>
        <span class="c1"># one of the map arrays) and create a dummy binning instance.</span>
        <span class="c1"># Remember that the final dimension is the sys params, not binning</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Remove last dimension</span>
            <span class="n">binning_shape</span> <span class="o">=</span> <span class="n">input_data</span><span class="p">[</span><span class="n">map_name</span><span class="p">][</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">binning</span> <span class="o">=</span> <span class="n">MultiDimBinning</span><span class="p">([</span><span class="n">OneDimBinning</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;dummy_</span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="p">[</span>
                                      <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="n">is_lin</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">num_bins</span><span class="o">=</span><span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">binning_shape</span><span class="p">)])</span>

        <span class="c1">#</span>
        <span class="c1"># Create the hypersurface instance</span>
        <span class="c1">#</span>

        <span class="c1"># Create the hypersurface</span>
        <span class="n">hypersurface</span> <span class="o">=</span> <span class="n">Hypersurface</span><span class="p">(</span>
            <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>  <span class="c1"># Specify the systematic parameters</span>
            <span class="n">initial_intercept</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span>  <span class="c1"># Intercept value (or first guess for fit)</span>
        <span class="p">)</span>

        <span class="c1"># Set some internal members that would normally be configured during fitting</span>
        <span class="c1"># Don&#39;t know the nominal values with legacy files, so just stores NaNs</span>
        <span class="n">hypersurface</span><span class="o">.</span><span class="n">_init</span><span class="p">(</span>
            <span class="n">binning</span><span class="o">=</span><span class="n">binning</span><span class="p">,</span>
            <span class="n">nominal_param_values</span><span class="o">=</span><span class="p">{</span>
                <span class="n">name</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">hypersurface</span><span class="o">.</span><span class="n">param_names</span><span class="p">},</span>
        <span class="p">)</span>

        <span class="c1"># Indicate this is legacy data (not all functionality will work)</span>
        <span class="n">hypersurface</span><span class="o">.</span><span class="n">using_legacy_data</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1">#</span>
        <span class="c1"># Get the fit values</span>
        <span class="c1">#</span>

        <span class="c1"># Handling two different legacy cases here...</span>
        <span class="n">fitted_coefficients</span> <span class="o">=</span> <span class="n">input_data</span><span class="p">[</span><span class="s2">&quot;hyperplanes&quot;</span><span class="p">][</span><span class="n">map_name</span><span class="p">][</span>
            <span class="s2">&quot;fit_params&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="s2">&quot;hyperplanes&quot;</span> <span class="ow">in</span> <span class="n">input_data</span> <span class="k">else</span> <span class="n">input_data</span><span class="p">[</span><span class="n">map_name</span><span class="p">]</span>

        <span class="c1"># Fitted coefficients have following array shape: [ binning dim 0,  ..., binning dim N, sys params (inc. intercept) ]</span>
        <span class="n">intercept_values</span> <span class="o">=</span> <span class="n">fitted_coefficients</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">sys_param_gradient_values</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">n</span><span class="p">:</span> <span class="n">fitted_coefficients</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">param_names</span><span class="p">)}</span>

        <span class="c1"># Write the values to the hypersurface</span>
        <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="n">intercept_values</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="n">hypersurface</span><span class="o">.</span><span class="n">intercept</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">hypersurface</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span>
                <span class="n">src</span><span class="o">=</span><span class="n">sys_param_gradient_values</span><span class="p">[</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">],</span> <span class="n">dst</span><span class="o">=</span><span class="n">param</span><span class="o">.</span><span class="n">fit_coeffts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Done, store the hypersurface</span>
        <span class="n">hypersurfaces</span><span class="p">[</span><span class="n">map_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">hypersurface</span>

    <span class="k">return</span> <span class="n">hypersurfaces</span>


<span class="k">def</span> <span class="nf">_load_hypersurfaces_data_release</span><span class="p">(</span><span class="n">input_file_prototype</span><span class="p">,</span> <span class="n">binning</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Load the hypersurface CSV files from an official IceCube data release</span>

<span class="sd">    User should not use this directly, instead call `load_hypersurfaces`.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># TODO Current only handles DRAGON (analysis B) data release (as was also the case for</span>
    <span class="c1"># the older hyperplane code)</span>
    <span class="c1"># TODO Would need to add support for muon hypersurface (including non-linear params)</span>
    <span class="c1"># as well as a different binning</span>

    <span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

    <span class="n">hypersurfaces</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">OrderedDict</span><span class="p">()</span>

    <span class="c1">#</span>
    <span class="c1"># Check inputs</span>
    <span class="c1">#</span>

    <span class="k">assert</span> <span class="n">binning</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Must provide binning when loading data release hypersurfaces&quot;</span>

    <span class="c1">#</span>
    <span class="c1"># Load CSV files</span>
    <span class="c1">#</span>

    <span class="n">fit_results</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">fit_results</span><span class="p">[</span><span class="s1">&#39;nue_cc+nuebar_cc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">find_resource</span><span class="p">(</span>
        <span class="n">input_file_prototype</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;nue_cc&#39;</span><span class="p">)))</span>
    <span class="n">fit_results</span><span class="p">[</span><span class="s1">&#39;numu_cc+numubar_cc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">find_resource</span><span class="p">(</span>
        <span class="n">input_file_prototype</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;numu_cc&#39;</span><span class="p">)))</span>
    <span class="n">fit_results</span><span class="p">[</span><span class="s1">&#39;nutau_cc+nutaubar_cc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">find_resource</span><span class="p">(</span>
        <span class="n">input_file_prototype</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;nutau_cc&#39;</span><span class="p">)))</span>
    <span class="n">fit_results</span><span class="p">[</span><span class="s1">&#39;nu_nc+nubar_nc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">find_resource</span><span class="p">(</span>
        <span class="n">input_file_prototype</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;all_nc&#39;</span><span class="p">)))</span>

    <span class="c1">#</span>
    <span class="c1"># Get hyperplane info</span>
    <span class="c1">#</span>

    <span class="n">param_names</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">for</span> <span class="n">map_name</span><span class="p">,</span> <span class="n">map_fit_results</span> <span class="ow">in</span> <span class="n">fit_results</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

        <span class="c1">#</span>
        <span class="c1"># Get hypersurface params</span>
        <span class="c1">#</span>

        <span class="c1"># Remove the bin info from the data frame (only want hyperplane params)</span>
        <span class="c1"># Check that find the same dimensions as the expected binning</span>
        <span class="c1"># TODO Also check bin centers are within expected bins</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">binning</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="n">midpoints_found</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">map_fit_results</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">midpoints_found</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">binning</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">num_bins</span><span class="p">,</span> <span class="s2">&quot;Mismatch between expected and actual binning dimensions&quot;</span>

        <span class="c1"># Also extract the special case of the offset</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">map_fit_results</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;offset&quot;</span><span class="p">)</span>

        <span class="c1"># Get the param names (everything remaining is a hypersurface param)</span>
        <span class="k">if</span> <span class="n">param_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">param_names</span> <span class="o">=</span> <span class="n">map_fit_results</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">param_names</span> <span class="o">==</span> <span class="n">map_fit_results</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">(</span>
            <span class="p">),</span> <span class="s2">&quot;Mismatch between hypersurface params in different files&quot;</span>

        <span class="c1"># Create the params</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">HypersurfaceParam</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">func_name</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="n">initial_fit_coeffts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">param_names</span><span class="p">]</span>

        <span class="c1">#</span>
        <span class="c1"># Create the hypersurface instance</span>
        <span class="c1">#</span>

        <span class="c1"># Create the hypersurface</span>
        <span class="n">hypersurface</span> <span class="o">=</span> <span class="n">Hypersurface</span><span class="p">(</span>
            <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>  <span class="c1"># Specify the systematic parameters</span>
            <span class="n">initial_intercept</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span>  <span class="c1"># Intercept value (or first guess for fit)</span>
        <span class="p">)</span>

        <span class="c1"># Set some internal members that would normally be configured during fitting</span>
        <span class="c1"># Don&#39;t know the nominal values with legacy files, so just stores NaNs</span>
        <span class="n">hypersurface</span><span class="o">.</span><span class="n">_init</span><span class="p">(</span>
            <span class="n">binning</span><span class="o">=</span><span class="n">binning</span><span class="p">,</span>
            <span class="n">nominal_param_values</span><span class="o">=</span><span class="p">{</span>
                <span class="n">name</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">hypersurface</span><span class="o">.</span><span class="n">param_names</span><span class="p">},</span>
        <span class="p">)</span>

        <span class="c1"># Indicate this is legacy data (not all functionality will work)</span>
        <span class="n">hypersurface</span><span class="o">.</span><span class="n">using_legacy_data</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1">#</span>
        <span class="c1"># Get the fit values</span>
        <span class="c1">#</span>

        <span class="c1"># Intercept</span>
        <span class="n">intercept_values</span> <span class="o">=</span> <span class="n">offset</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">binning</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="n">intercept_values</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="n">hypersurface</span><span class="o">.</span><span class="n">intercept</span><span class="p">)</span>

        <span class="c1"># Param gradients</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">hypersurface</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">sys_param_gradient_values</span> <span class="o">=</span> <span class="n">map_fit_results</span><span class="p">[</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="n">binning</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="n">sys_param_gradient_values</span><span class="p">,</span>
                      <span class="n">dst</span><span class="o">=</span><span class="n">param</span><span class="o">.</span><span class="n">fit_coeffts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Done, store the hypersurface</span>
        <span class="n">hypersurfaces</span><span class="p">[</span><span class="n">map_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">hypersurface</span>

    <span class="k">return</span> <span class="n">hypersurfaces</span>


<span class="c1">#</span>
<span class="c1"># Test/example</span>
<span class="c1">#</span>
<span class="k">def</span> <span class="nf">generate_asimov_testdata</span><span class="p">(</span><span class="n">binning</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">true_param_coeffs</span><span class="p">,</span>
                             <span class="n">nominal_param_values</span><span class="p">,</span> <span class="n">sys_param_values</span><span class="p">,</span>
                             <span class="n">error_scale</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">intercept</span><span class="o">=</span><span class="mf">2.</span><span class="p">,</span>
                             <span class="p">):</span>
    <span class="n">hypersurface</span> <span class="o">=</span> <span class="n">Hypersurface</span><span class="p">(</span>
        <span class="n">params</span><span class="o">=</span><span class="n">parameters</span><span class="p">,</span>  <span class="c1"># Specify the systematic parameters</span>
        <span class="c1"># Intercept value (or first guess for fit)</span>
        <span class="n">initial_intercept</span><span class="o">=</span><span class="n">intercept</span><span class="p">,</span>
        <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">hypersurface</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">nominal_param_values</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">hypersurface</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">true_param_coeffs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="n">hypersurface</span><span class="o">.</span><span class="n">_init</span><span class="p">(</span><span class="n">binning</span><span class="o">=</span><span class="n">binning</span><span class="p">,</span> <span class="n">nominal_param_values</span><span class="o">=</span><span class="n">nominal_param_values</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">pisa.core.map</span> <span class="kn">import</span> <span class="n">Map</span><span class="p">,</span> <span class="n">MapSet</span>
    <span class="k">for</span> <span class="n">bin_idx</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">binning</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">coeffs</span> <span class="ow">in</span> <span class="n">true_param_coeffs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span> <span class="o">==</span> <span class="n">hypersurface</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">num_fit_coeffts</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;number &quot;</span>
                                                                              <span class="s2">&quot;of coefficients in the parameter must match&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coeffs</span><span class="p">):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">hypersurface</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">get_fit_coefft_idx</span><span class="p">(</span><span class="n">bin_idx</span><span class="o">=</span><span class="n">bin_idx</span><span class="p">,</span>
                                                                   <span class="n">coefft_idx</span><span class="o">=</span><span class="n">j</span><span class="p">,</span>
                                                                   <span class="p">)</span>
                <span class="n">hypersurface</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">fit_coeffts</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Truth hypersurface report:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">hypersurface</span><span class="p">))</span>

    <span class="c1"># Only consider one particle type for simplicity</span>
    <span class="n">particle_key</span> <span class="o">=</span> <span class="s2">&quot;nue_cc&quot;</span>
    <span class="c1"># Create each dataset, e.g. set the systematic parameter values, calculate a bin count</span>
    <span class="n">hist</span> <span class="o">=</span> <span class="n">hypersurface</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">nominal_param_values</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">hist</span> <span class="o">&gt;=</span> <span class="mf">0.</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;nominal map has negative values! &quot;</span>
                                <span class="s2">&quot;Choose different true parameters.&quot;</span><span class="p">)</span>
    <span class="n">nom_map</span> <span class="o">=</span> <span class="n">Map</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">particle_key</span><span class="p">,</span> <span class="n">binning</span><span class="o">=</span><span class="n">binning</span><span class="p">,</span>
                  <span class="n">hist</span><span class="o">=</span><span class="n">hist</span><span class="p">,</span> <span class="n">error_hist</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">hist</span><span class="p">)</span><span class="o">*</span><span class="n">error_scale</span><span class="p">,</span>
                  <span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Nominal hist: </span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">nom_map</span><span class="o">.</span><span class="n">hist</span><span class="p">))</span>
    <span class="n">sys_maps</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sys_param_values</span><span class="p">)):</span>
        <span class="n">hist</span> <span class="o">=</span> <span class="n">hypersurface</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">sys_param_values</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">hist</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;a systematic map has negative values! values: &quot;</span>
                                   <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> systematics: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">hist</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">sys_param_values</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span>
        <span class="n">sys_maps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Map</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">particle_key</span><span class="p">,</span> <span class="n">binning</span><span class="o">=</span><span class="n">binning</span><span class="p">,</span>
                            <span class="n">hist</span><span class="o">=</span><span class="n">hist</span><span class="p">,</span> <span class="n">error_hist</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">hist</span><span class="p">)</span><span class="o">*</span><span class="n">error_scale</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">nom_map</span><span class="p">,</span> <span class="n">sys_maps</span>


<span class="k">def</span> <span class="nf">test_hypersurface_uncertainty</span><span class="p">(</span><span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Simple test of hypersurface fits + uncertainty</span>
<span class="sd">    1. Creates some Asimov test data matching a true hypersurface and checks the ability</span>
<span class="sd">       to fit back the truth.</span>
<span class="sd">    2. Fluctuates Asimov test data randomly to check uncertainties of hypersurface</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># Define systematic parameters in the hypersurface</span>
    <span class="n">params</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">HypersurfaceParam</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="n">func_name</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
                          <span class="n">initial_fit_coeffts</span><span class="o">=</span><span class="p">[</span><span class="mf">1.</span><span class="p">]),</span>
        <span class="n">HypersurfaceParam</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;bar&quot;</span><span class="p">,</span> <span class="n">func_name</span><span class="o">=</span><span class="s2">&quot;quadratic&quot;</span><span class="p">,</span>
                          <span class="n">initial_fit_coeffts</span><span class="o">=</span><span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">]),</span>
    <span class="p">]</span>
    <span class="c1"># Create the hypersurface</span>
    <span class="n">hypersurface</span> <span class="o">=</span> <span class="n">Hypersurface</span><span class="p">(</span>
        <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>  <span class="c1"># Specify the systematic parameters</span>
        <span class="n">initial_intercept</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span>  <span class="c1"># Intercept value (or first guess for fit)</span>
        <span class="n">log</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>
    <span class="c1"># Define binning with one dummy bin</span>
    <span class="n">binning</span> <span class="o">=</span> <span class="n">MultiDimBinning</span><span class="p">([</span><span class="n">OneDimBinning</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;reco_energy&quot;</span><span class="p">,</span>
                                             <span class="n">domain</span><span class="o">=</span><span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">10.</span><span class="p">],</span>
                                             <span class="n">num_bins</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                             <span class="n">units</span><span class="o">=</span><span class="n">ureg</span><span class="o">.</span><span class="n">GeV</span><span class="p">,</span>
                                             <span class="n">is_lin</span><span class="o">=</span><span class="kc">True</span>
                                             <span class="p">)])</span>
    <span class="c1"># Define true coefficients</span>
    <span class="n">true_coeffs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;foo&#39;</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.4</span><span class="p">],</span> <span class="s1">&#39;bar&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]}</span>
    <span class="n">true_intercept</span> <span class="o">=</span> <span class="mf">5.</span>
    <span class="n">nominal_param_values</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;foo&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">:</span> <span class="mf">0.</span><span class="p">}</span>
    <span class="c1"># making combinations of systematic values</span>
    <span class="n">foo_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
    <span class="n">bar_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
    <span class="n">sys_param_values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">foo_vals</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bar_vals</span><span class="p">:</span>
            <span class="n">sys_param_values</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;foo&#39;</span><span class="p">:</span> <span class="n">f</span><span class="p">,</span> <span class="s1">&#39;bar&#39;</span><span class="p">:</span> <span class="n">b</span><span class="p">})</span>

    <span class="n">nom_map</span><span class="p">,</span> <span class="n">sys_maps</span> <span class="o">=</span> <span class="n">generate_asimov_testdata</span><span class="p">(</span><span class="n">binning</span><span class="p">,</span>
                                                 <span class="n">params</span><span class="p">,</span>
                                                 <span class="n">true_coeffs</span><span class="p">,</span>
                                                 <span class="n">nominal_param_values</span><span class="p">,</span>
                                                 <span class="n">sys_param_values</span><span class="p">,</span>
                                                 <span class="n">intercept</span><span class="o">=</span><span class="n">true_intercept</span><span class="p">,</span>
                                                 <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                 <span class="n">error_scale</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
                                                 <span class="p">)</span>
    <span class="c1"># Perform fit</span>
    <span class="n">hypersurface</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
        <span class="n">nominal_map</span><span class="o">=</span><span class="n">nom_map</span><span class="p">,</span>
        <span class="n">nominal_param_values</span><span class="o">=</span><span class="n">nominal_param_values</span><span class="p">,</span>
        <span class="n">sys_maps</span><span class="o">=</span><span class="n">sys_maps</span><span class="p">,</span>
        <span class="n">sys_param_values</span><span class="o">=</span><span class="n">sys_param_values</span><span class="p">,</span>
        <span class="n">norm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="c1"># Report the results</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Fitted hypersurface report:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">hypersurface</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">hypersurface</span><span class="o">.</span><span class="n">intercept</span><span class="p">,</span> <span class="n">true_intercept</span><span class="p">,</span>
                       <span class="n">rtol</span><span class="o">=</span><span class="n">ALLCLOSE_KW</span><span class="p">[</span><span class="s1">&#39;rtol&#39;</span><span class="p">]</span><span class="o">*</span><span class="mf">10.</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="n">hypersurface</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">hypersurface</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span><span class="o">.</span><span class="n">fit_coeffts</span><span class="p">,</span>
                           <span class="n">true_coeffs</span><span class="p">[</span><span class="n">param_name</span><span class="p">],</span> <span class="n">rtol</span><span class="o">=</span><span class="n">ALLCLOSE_KW</span><span class="p">[</span><span class="s1">&#39;rtol&#39;</span><span class="p">]</span><span class="o">*</span><span class="mf">10.</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">plot_bin_fits</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">hypersurface</span><span class="p">,</span> <span class="n">bin_idx</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">param_name</span><span class="o">=</span><span class="s1">&#39;foo&#39;</span><span class="p">,</span>
                      <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Asimov test map&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;test_hypersurface_foo.pdf&#39;</span><span class="p">)</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">plot_bin_fits</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">hypersurface</span><span class="p">,</span> <span class="n">bin_idx</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">param_name</span><span class="o">=</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span>
                      <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Asimov test map&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;test_hypersurface_bar.pdf&#39;</span><span class="p">)</span>

    <span class="c1"># Evaluate hypersurface and uncertainties at some points</span>
    <span class="c1"># that just happen to be the systematic values (but choice could be different)</span>
    <span class="n">asimov_true_points</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">asimov_fit_points</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">asimov_fit_errs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sys_param_values</span><span class="p">)):</span>
        <span class="n">hist</span><span class="p">,</span> <span class="n">errs</span> <span class="o">=</span> <span class="n">hypersurface</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span>
            <span class="n">sys_param_values</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">return_uncertainty</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">asimov_fit_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hist</span><span class="p">)</span>
        <span class="n">asimov_fit_errs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">errs</span><span class="p">)</span>
        <span class="n">asimov_true_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sys_maps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">nominal_values</span><span class="p">)</span>
    <span class="n">asimov_true_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">asimov_true_points</span><span class="p">)</span>
    <span class="n">asimov_fit_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">asimov_fit_points</span><span class="p">)</span>
    <span class="n">asimov_fit_errs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">asimov_fit_errs</span><span class="p">)</span>

    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Asimov true points:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">asimov_true_points</span><span class="p">))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Asimov fit points:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">asimov_fit_points</span><span class="p">))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Asimov fit error estimates:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">asimov_fit_errs</span><span class="p">))</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">asimov_true_points</span><span class="p">,</span> <span class="n">asimov_fit_points</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">ALLCLOSE_KW</span><span class="p">[</span><span class="s1">&#39;rtol&#39;</span><span class="p">]</span><span class="o">*</span><span class="mf">10.</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Fluctuating maps and re-fitting...&quot;</span><span class="p">)</span>
    <span class="c1"># do several rounds of fluctuation, re-fit and storage of results</span>
    <span class="n">n_rounds</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="n">fluctuated_fit_points</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_rounds</span><span class="p">):</span>
        <span class="c1">#logging.info(&quot;Round %d/%d&quot; % (i+1, n_rounds))</span>
        <span class="n">nom_map_fluct</span> <span class="o">=</span> <span class="n">nom_map</span><span class="o">.</span><span class="n">fluctuate</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;gauss&#39;</span><span class="p">)</span>
        <span class="n">sys_maps_fluct</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sys_maps</span><span class="p">:</span>
            <span class="n">sys_maps_fluct</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">fluctuate</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;gauss&#39;</span><span class="p">))</span>
        <span class="n">hypersurface</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span>
            <span class="n">nominal_map</span><span class="o">=</span><span class="n">nom_map_fluct</span><span class="p">,</span>
            <span class="n">nominal_param_values</span><span class="o">=</span><span class="n">nominal_param_values</span><span class="p">,</span>
            <span class="n">sys_maps</span><span class="o">=</span><span class="n">sys_maps_fluct</span><span class="p">,</span>
            <span class="n">sys_param_values</span><span class="o">=</span><span class="n">sys_param_values</span><span class="p">,</span>
            <span class="n">norm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">fluctuated_fit_points</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sys_param_values</span><span class="p">)):</span>
            <span class="n">hist</span> <span class="o">=</span> <span class="n">hypersurface</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span>
                <span class="n">sys_param_values</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">return_uncertainty</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">fluctuated_fit_points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hist</span><span class="p">)</span>
        <span class="n">fluctuated_fit_points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">fluctuated_fit_points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="s2">&quot;Fluctuated fit points:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                      <span class="nb">str</span><span class="p">(</span><span class="n">fluctuated_fit_points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="c1"># evaluate whether the actual fluctuations match the estimated errors</span>
    <span class="n">fluctuated_fit_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fluctuated_fit_points</span><span class="p">)</span>
    <span class="n">fit_differences</span> <span class="o">=</span> <span class="n">fluctuated_fit_points</span> <span class="o">-</span> <span class="n">asimov_fit_points</span>
    <span class="n">all_pulls</span> <span class="o">=</span> <span class="n">fit_differences</span> <span class="o">/</span> <span class="n">asimov_fit_errs</span>
    <span class="n">avg_fit_differences</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">fit_differences</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">std_pulls</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">all_pulls</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Average fluctuated fit difference:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                  <span class="nb">str</span><span class="p">(</span><span class="n">avg_fit_differences</span><span class="p">))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Mean pulls per point:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">std_pulls</span><span class="p">))</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Mean pull: </span><span class="si">%.3f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">std_pulls</span><span class="p">))</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">std_pulls</span><span class="p">)</span> <span class="o">-</span>
                  <span class="mf">1.</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">,</span> <span class="s2">&quot;avg. pulls too far from expectation&quot;</span>

    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">all_pulls</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">bins</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
                 <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;fluctuated fits&#39;</span><span class="p">)</span>
        <span class="n">x_plot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_plot</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x_plot</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span> <span class="o">/</span>
                 <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">),</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;expectation&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;pull distribution&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;pull&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;density&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;test_hypersurface_pull.pdf&#39;</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;&lt;&lt; PASS : test_hypersurface_uncertainty &gt;&gt;&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">test_hypersurface_basics</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Test basic fitting, inject/recover, storing and loading</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="kn">import</span> <span class="nn">tempfile</span>
    <span class="kn">from</span> <span class="nn">pisa.core.map</span> <span class="kn">import</span> <span class="n">Map</span>

    <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">HypersurfaceParam</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="n">func_name</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span>
                                <span class="n">initial_fit_coeffts</span><span class="o">=</span><span class="p">[</span><span class="mf">1.</span><span class="p">],</span>
                                <span class="p">),</span>
              <span class="c1"># the exponential HS function did not reliably recover injected true</span>
              <span class="c1"># parameters, probably due to the degeneracy with the intercept.</span>
              <span class="n">HypersurfaceParam</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;bar&quot;</span><span class="p">,</span> <span class="n">func_name</span><span class="o">=</span><span class="s2">&quot;quadratic&quot;</span><span class="p">,</span>
                                <span class="n">initial_fit_coeffts</span><span class="o">=</span><span class="p">[</span><span class="mf">.1</span><span class="p">,</span> <span class="mf">.1</span><span class="p">],</span>
                                <span class="p">),</span>
              <span class="p">]</span>

    <span class="c1"># Create the hypersurface</span>
    <span class="n">hypersurface</span> <span class="o">=</span> <span class="n">Hypersurface</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>  <span class="c1"># Specify the systematic parameters</span>
                                <span class="n">initial_intercept</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span>  <span class="c1"># Intercept first guess for fit)</span>
                                <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                <span class="p">)</span>

    <span class="n">binning</span> <span class="o">=</span> <span class="n">MultiDimBinning</span><span class="p">([</span><span class="n">OneDimBinning</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;reco_energy&quot;</span><span class="p">,</span>
                                             <span class="n">domain</span><span class="o">=</span><span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">10.</span><span class="p">],</span>
                                             <span class="n">num_bins</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                                             <span class="n">units</span><span class="o">=</span><span class="n">ureg</span><span class="o">.</span><span class="n">GeV</span><span class="p">,</span>
                                             <span class="n">is_lin</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                             <span class="p">)])</span>

    <span class="c1"># Define the values for the parameters for each dataset</span>
    <span class="n">nom_param_values</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">sys_param_values_dict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="s2">&quot;foo&quot;</span> <span class="ow">in</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">]:</span>
        <span class="n">nom_param_values</span><span class="p">[</span><span class="s2">&quot;foo&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="n">sys_param_values_dict</span><span class="p">[</span><span class="s2">&quot;foo&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="o">+</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]</span>

    <span class="k">if</span> <span class="s2">&quot;bar&quot;</span> <span class="ow">in</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">]:</span>
        <span class="n">nom_param_values</span><span class="p">[</span><span class="s2">&quot;bar&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">10.</span>
        <span class="n">sys_param_values_dict</span><span class="p">[</span><span class="s2">&quot;bar&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">20.</span><span class="p">,</span> <span class="mf">30.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">10.</span><span class="p">,</span> <span class="mf">10.</span><span class="p">,</span> <span class="mf">15.</span><span class="p">]</span>

    <span class="c1"># Get number of datasets</span>
    <span class="n">num_sys_datasets</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">sys_param_values_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Only consider one particle type for simplicity</span>
    <span class="n">particle_key</span> <span class="o">=</span> <span class="s2">&quot;nue_cc&quot;</span>

    <span class="c1"># Create a dummy &quot;true&quot; hypersurface that can be used to generate</span>
    <span class="c1"># some fake bin values for the dataset</span>
    <span class="n">true_hypersurface</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">hypersurface</span><span class="p">)</span>
    <span class="n">true_hypersurface</span><span class="o">.</span><span class="n">_init</span><span class="p">(</span>
        <span class="n">binning</span><span class="o">=</span><span class="n">binning</span><span class="p">,</span> <span class="n">nominal_param_values</span><span class="o">=</span><span class="n">nom_param_values</span><span class="p">)</span>
    <span class="n">true_hypersurface</span><span class="o">.</span><span class="n">intercept</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mf">10.</span><span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;foo&quot;</span> <span class="ow">in</span> <span class="n">true_hypersurface</span><span class="o">.</span><span class="n">params</span><span class="p">:</span>
        <span class="n">true_hypersurface</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;foo&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fit_coeffts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mf">2.</span><span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;bar&quot;</span> <span class="ow">in</span> <span class="n">true_hypersurface</span><span class="o">.</span><span class="n">params</span><span class="p">:</span>
        <span class="n">true_hypersurface</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;bar&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fit_coeffts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="o">-</span><span class="mf">.1</span><span class="p">)</span>
        <span class="n">true_hypersurface</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;bar&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">fit_coeffts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span>

    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Truth hypersurface report:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">true_hypersurface</span><span class="p">))</span>

    <span class="c1"># Create each dataset, e.g. set the systematic parameter values, calculate bin count</span>
    <span class="n">hist</span> <span class="o">=</span> <span class="n">true_hypersurface</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">nom_param_values</span><span class="p">)</span>
    <span class="n">nom_map</span> <span class="o">=</span> <span class="n">Map</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">particle_key</span><span class="p">,</span> <span class="n">binning</span><span class="o">=</span><span class="n">binning</span><span class="p">,</span>
                  <span class="n">hist</span><span class="o">=</span><span class="n">hist</span><span class="p">,</span> <span class="n">error_hist</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">hist</span><span class="p">),</span>
                  <span class="p">)</span>
    <span class="n">sys_maps</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sys_param_values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_sys_datasets</span><span class="p">):</span>
        <span class="n">sys_param_values</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="n">name</span><span class="p">:</span> <span class="n">sys_param_values_dict</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                                 <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">true_hypersurface</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                                 <span class="p">})</span>
        <span class="n">hist</span> <span class="o">=</span> <span class="n">true_hypersurface</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">sys_param_values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">sys_maps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Map</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">particle_key</span><span class="p">,</span> <span class="n">binning</span><span class="o">=</span><span class="n">binning</span><span class="p">,</span>
                            <span class="n">hist</span><span class="o">=</span><span class="n">hist</span><span class="p">,</span> <span class="n">error_hist</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">hist</span><span class="p">),</span>
                            <span class="p">)</span>
                        <span class="p">)</span>

    <span class="c1"># Perform fit</span>
    <span class="n">hypersurface</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">nominal_map</span><span class="o">=</span><span class="n">nom_map</span><span class="p">,</span>
                     <span class="n">nominal_param_values</span><span class="o">=</span><span class="n">nom_param_values</span><span class="p">,</span>
                     <span class="n">sys_maps</span><span class="o">=</span><span class="n">sys_maps</span><span class="p">,</span>
                     <span class="n">sys_param_values</span><span class="o">=</span><span class="n">sys_param_values</span><span class="p">,</span>
                     <span class="n">norm</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="p">)</span>

    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Fitted hypersurface report:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">hypersurface</span><span class="p">)</span>

    <span class="c1"># Check the fitted parameter values match the truth</span>
    <span class="c1"># This only works if `norm=False` in the `hypersurface.fit` call just above</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Checking fit recovered truth...&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">hypersurface</span><span class="o">.</span><span class="n">intercept</span><span class="p">,</span>
                       <span class="n">true_hypersurface</span><span class="o">.</span><span class="n">intercept</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">ALLCLOSE_KW</span><span class="p">[</span><span class="s1">&#39;rtol&#39;</span><span class="p">]</span><span class="o">*</span><span class="mf">10.</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="n">hypersurface</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">hypersurface</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span><span class="o">.</span><span class="n">fit_coeffts</span><span class="p">,</span>
                           <span class="n">true_hypersurface</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span><span class="o">.</span><span class="n">fit_coeffts</span><span class="p">,</span>
                           <span class="n">rtol</span><span class="o">=</span><span class="n">ALLCLOSE_KW</span><span class="p">[</span><span class="s1">&#39;rtol&#39;</span><span class="p">]</span><span class="o">*</span><span class="mf">10.</span>
                           <span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;... fit was successful!&quot;</span><span class="p">)</span>

    <span class="c1"># testing save/reload</span>
    <span class="k">with</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">TemporaryDirectory</span><span class="p">()</span> <span class="k">as</span> <span class="n">tmpdirname</span><span class="p">:</span>
        <span class="n">file_name</span> <span class="o">=</span> <span class="s2">&quot;hypersurface.json.bz2&quot;</span>
        <span class="n">file_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmpdirname</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span>
        <span class="n">to_json</span><span class="p">(</span><span class="n">hypersurface</span><span class="p">,</span> <span class="n">file_path</span><span class="p">)</span>

        <span class="n">reloaded_hypersurface</span> <span class="o">=</span> <span class="n">Hypersurface</span><span class="o">.</span><span class="n">from_state</span><span class="p">(</span><span class="n">file_path</span><span class="p">)</span>

        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s2">&quot;Checking saved and re-loaded hypersurfaces are identical...&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">hypersurface</span><span class="o">.</span><span class="n">intercept</span><span class="p">,</span>
                           <span class="n">reloaded_hypersurface</span><span class="o">.</span><span class="n">intercept</span><span class="p">,</span>
                           <span class="n">rtol</span><span class="o">=</span><span class="n">ALLCLOSE_KW</span><span class="p">[</span><span class="s1">&#39;rtol&#39;</span><span class="p">]</span><span class="o">*</span><span class="mf">10.</span>
                           <span class="p">)</span>
        <span class="k">for</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="n">hypersurface</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">hypersurface</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span><span class="o">.</span><span class="n">fit_coeffts</span><span class="p">,</span>
                               <span class="n">reloaded_hypersurface</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span><span class="o">.</span><span class="n">fit_coeffts</span><span class="p">,</span>
                               <span class="n">rtol</span><span class="o">=</span><span class="n">ALLCLOSE_KW</span><span class="p">[</span><span class="s1">&#39;rtol&#39;</span><span class="p">]</span><span class="o">*</span><span class="mf">10.</span>
                               <span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;... save+re-load was successful!&quot;</span><span class="p">)</span>

    <span class="c1"># test getting and setting coefficients</span>
    <span class="n">coeffts</span> <span class="o">=</span> <span class="n">hypersurface</span><span class="o">.</span><span class="n">fit_coeffts</span>
    <span class="n">reloaded_hypersurface</span><span class="o">.</span><span class="n">fit_coeffts</span> <span class="o">=</span> <span class="n">coeffts</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
        <span class="s2">&quot;Checking hypersurfaces are identical after getting and setting coeffts...&quot;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">hypersurface</span><span class="o">.</span><span class="n">intercept</span><span class="p">,</span> <span class="n">reloaded_hypersurface</span><span class="o">.</span><span class="n">intercept</span><span class="p">,</span>
                       <span class="n">rtol</span><span class="o">=</span><span class="n">ALLCLOSE_KW</span><span class="p">[</span><span class="s1">&#39;rtol&#39;</span><span class="p">]</span><span class="o">*</span><span class="mf">10.</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">param_name</span> <span class="ow">in</span> <span class="n">hypersurface</span><span class="o">.</span><span class="n">param_names</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">hypersurface</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span><span class="o">.</span><span class="n">fit_coeffts</span><span class="p">,</span>
                           <span class="n">reloaded_hypersurface</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span><span class="o">.</span><span class="n">fit_coeffts</span><span class="p">,</span>
                           <span class="n">rtol</span><span class="o">=</span><span class="n">ALLCLOSE_KW</span><span class="p">[</span><span class="s1">&#39;rtol&#39;</span><span class="p">]</span><span class="o">*</span><span class="mf">10.</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;... setting and getting coefficients was successful!&quot;</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;&lt;&lt; PASS : test_hypersurface_basics &gt;&gt;&#39;</span><span class="p">)</span>


<span class="c1"># Run the examp&#39;es/tests</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">set_verbosity</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">test_hypersurface_basics</span><span class="p">()</span>
    <span class="n">test_hypersurface_uncertainty</span><span class="p">()</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, The IceCube/PINGU Collaboration.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>